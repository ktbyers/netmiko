<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>netmiko.nokia.nokia_sros API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>netmiko.nokia.nokia_sros</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/python
# -*- coding: utf-8 -*-
# Copyright (c) 2014 - 2022 Kirk Byers
# Copyright (c) 2014 - 2022 Twin Bridges Technology
# Copyright (c) 2019 - 2020 NOKIA Inc.
# MIT License - See License file at:
#   https://github.com/ktbyers/netmiko/blob/develop/LICENSE

import re
import os
import time
from typing import Any, Optional, Union, Sequence, Iterator, TextIO, Callable

from netmiko import log
from netmiko.base_connection import BaseConnection
from netmiko.scp_handler import BaseFileTransfer
from netmiko.utilities import nokia_context_filter


class NokiaSros(BaseConnection):
    &#34;&#34;&#34;
    Implement methods for interacting with Nokia SR OS devices
    for both SSH and telnet.

    Not applicable in Nokia SR OS (disabled):
        - exit_enable_mode()

    Overriden methods to adapt Nokia SR OS behavior (changed):
        - session_preparation()
        - set_base_prompt()
        - config_mode()
        - exit_config_mode()
        - check_config_mode()
        - save_config()
        - commit()
        - strip_prompt()
        - enable()
        - check_enable_mode()
    &#34;&#34;&#34;

    def session_preparation(self) -&gt; None:
        self._test_channel_read()
        self.set_base_prompt()
        # &#34;@&#34; indicates model-driven CLI (vs Classical CLI)
        if &#34;@&#34; in self.base_prompt:
            self._disable_complete_on_space()
            self.set_terminal_width(
                command=&#34;environment console width 512&#34;, pattern=&#34;environment&#34;
            )
            self.disable_paging(command=&#34;environment more false&#34;)
            # To perform file operations we need to disable paging in classical-CLI also
            self.disable_paging(command=&#34;//environment no more&#34;)
        else:
            # Classical CLI has no method to set the terminal width nor to disable command
            # complete on space; consequently, cmd_verify needs disabled.
            # Only disabled if not set under the ConnectHandler.
            if self.global_cmd_verify is None:
                self.global_cmd_verify = False
            self.disable_paging(command=&#34;environment no more&#34;, pattern=&#34;environment&#34;)

        # Clear the read buffer
        time.sleep(0.3 * self.global_delay_factor)
        self.clear_buffer()

    def set_base_prompt(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Remove the &gt; when navigating into the different config level.&#34;&#34;&#34;
        cur_base_prompt = super().set_base_prompt(*args, **kwargs)
        match = re.search(r&#34;\*?(.*?)(&gt;.*)*#&#34;, cur_base_prompt)
        if match:
            # strip off &gt;... from base_prompt; strip off leading *
            self.base_prompt: str = match.group(1)

        return self.base_prompt

    def _disable_complete_on_space(self) -&gt; str:
        &#34;&#34;&#34;
        SR-OS tries to auto complete commands when you type a &#34;space&#34; character.

        This is a bad idea for automation as what your program is sending no longer matches
        the command echo from the device, so we disable this behavior.
        &#34;&#34;&#34;
        delay_factor = self.select_delay_factor(delay_factor=0)
        time.sleep(delay_factor * 0.1)
        command = &#34;environment command-completion space false&#34;
        self.write_channel(self.normalize_cmd(command))
        time.sleep(delay_factor * 0.1)
        return self.read_channel()

    def enable(
        self,
        cmd: str = &#34;enable&#34;,
        pattern: str = &#34;ssword&#34;,
        enable_pattern: Optional[str] = None,
        re_flags: int = re.IGNORECASE,
    ) -&gt; str:
        &#34;&#34;&#34;Enable SR OS administrative mode&#34;&#34;&#34;
        if &#34;@&#34; not in self.base_prompt:
            cmd = &#34;enable-admin&#34;
        return super().enable(cmd=cmd, pattern=pattern, re_flags=re_flags)

    def check_enable_mode(self, check_string: str = &#34;in admin mode&#34;) -&gt; bool:
        &#34;&#34;&#34;Check if in enable mode.&#34;&#34;&#34;
        cmd = &#34;enable&#34;
        if &#34;@&#34; not in self.base_prompt:
            cmd = &#34;enable-admin&#34;
        self.write_channel(self.normalize_cmd(cmd))
        output = self.read_until_prompt_or_pattern(
            pattern=&#34;ssword&#34;, read_entire_line=True
        )
        if &#34;ssword&#34; in output:
            self.write_channel(self.RETURN)  # send ENTER to pass the password prompt
            self.read_until_prompt(read_entire_line=True)
        return check_string in output

    def exit_enable_mode(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Nokia SR OS does not have a notion of exiting administrative mode&#34;&#34;&#34;
        return &#34;&#34;

    def config_mode(
        self,
        config_command: str = &#34;edit-config exclusive&#34;,
        pattern: str = &#34;&#34;,
        re_flags: int = 0,
    ) -&gt; str:
        &#34;&#34;&#34;Enable config edit-mode for Nokia SR OS&#34;&#34;&#34;
        output = &#34;&#34;
        if not pattern:
            pattern = rf&#34;\(ex\)\[.*{self.base_prompt}.*$&#34;
            re_flags = re.DOTALL
        # Only model-driven CLI supports config-mode
        if &#34;@&#34; in self.base_prompt:
            output += super().config_mode(
                config_command=config_command, pattern=pattern, re_flags=re_flags
            )
        return output

    def exit_config_mode(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Disable config edit-mode for Nokia SR OS&#34;&#34;&#34;
        output = self._exit_all()
        # Model-driven CLI
        if &#34;@&#34; in self.base_prompt and &#34;(ex)[&#34; in output:
            # Asterisk indicates changes were made.
            if &#34;*(ex)[&#34; in output:
                log.warning(&#34;Uncommitted changes! Discarding changes!&#34;)
                output += self._discard()
            cmd = &#34;quit-config&#34;
            self.write_channel(self.normalize_cmd(cmd))
            if self.global_cmd_verify is not False:
                output += self.read_until_pattern(pattern=re.escape(cmd))
                output += self.read_until_prompt(read_entire_line=True)
            else:
                output += self.read_until_prompt(read_entire_line=True)
        if self.check_config_mode():
            raise ValueError(&#34;Failed to exit configuration mode&#34;)
        return output

    def check_config_mode(
        self,
        check_string: str = r&#34;(ex)[&#34;,
        pattern: str = r&#34;@&#34;,
        force_regex: bool = False,
    ) -&gt; bool:
        &#34;&#34;&#34;Check config mode for Nokia SR OS&#34;&#34;&#34;
        if &#34;@&#34; not in self.base_prompt:
            # Classical CLI
            return False
        else:
            # Model-driven CLI look for &#34;exclusive&#34;
            return super().check_config_mode(check_string=check_string, pattern=pattern)

    def save_config(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Persist configuration to cflash for Nokia SR OS&#34;&#34;&#34;
        return self._send_command_str(command_string=&#34;/admin save&#34;, expect_string=r&#34;#&#34;)

    def send_config_set(
        self,
        config_commands: Union[str, Sequence[str], Iterator[str], TextIO, None] = None,
        exit_config_mode: bool = None,
        **kwargs: Any,
    ) -&gt; str:
        &#34;&#34;&#34;Model driven CLI requires you not exit from configuration mode.&#34;&#34;&#34;
        if exit_config_mode is None:
            # Set to False if model-driven CLI
            exit_config_mode = False if &#34;@&#34; in self.base_prompt else True
        return super().send_config_set(
            config_commands=config_commands, exit_config_mode=exit_config_mode, **kwargs
        )

    def commit(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Activate changes from private candidate for Nokia SR OS&#34;&#34;&#34;
        output = self._exit_all()
        if &#34;@&#34; in self.base_prompt and &#34;*(ex)[&#34; in output:
            log.info(&#34;Apply uncommitted changes!&#34;)
            cmd = &#34;commit&#34;
            self.write_channel(self.normalize_cmd(cmd))
            new_output = &#34;&#34;
            if self.global_cmd_verify is not False:
                new_output += self.read_until_pattern(pattern=re.escape(cmd))
            if &#34;@&#34; not in new_output:
                new_output += self.read_until_pattern(r&#34;@&#34;)
            output += new_output
        return output

    def _exit_all(self) -&gt; str:
        &#34;&#34;&#34;Return to the &#39;root&#39; context.&#34;&#34;&#34;
        output = &#34;&#34;
        exit_cmd = &#34;exit all&#34;
        self.write_channel(self.normalize_cmd(exit_cmd))
        # Make sure you read until you detect the command echo (avoid getting out of sync)
        if self.global_cmd_verify is not False:
            output += self.read_until_pattern(pattern=re.escape(exit_cmd))
            output += self.read_until_prompt(read_entire_line=True)
        else:
            output += self.read_until_prompt(read_entire_line=True)
        return output

    def _discard(self) -&gt; str:
        &#34;&#34;&#34;Discard changes from private candidate for Nokia SR OS&#34;&#34;&#34;
        output = &#34;&#34;
        if &#34;@&#34; in self.base_prompt:
            cmd = &#34;discard&#34;
            self.write_channel(self.normalize_cmd(cmd))
            new_output = &#34;&#34;
            if self.global_cmd_verify is not False:
                new_output += self.read_until_pattern(pattern=re.escape(cmd))
            if &#34;@&#34; not in new_output:
                new_output += self.read_until_prompt(read_entire_line=True)
            output += new_output
        return output

    def strip_prompt(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Strip prompt from the output.&#34;&#34;&#34;
        output = super().strip_prompt(*args, **kwargs)
        if &#34;@&#34; in self.base_prompt:
            # Remove Nokia context prompt too
            output_list = output.rstrip().splitlines()
            last_line = output_list[-1]
            other_lines = output_list[:-1]
            last_line = nokia_context_filter(last_line)
            output_list = other_lines + [last_line]
            return &#34;\n&#34;.join(output_list).rstrip()
        else:
            return output

    def cleanup(self, command: str = &#34;logout&#34;) -&gt; None:
        &#34;&#34;&#34;Gracefully exit the SSH session.&#34;&#34;&#34;
        try:
            # The pattern=&#34;&#34; forces use of send_command_timing
            if self.check_config_mode(pattern=&#34;&#34;):
                self.exit_config_mode()
        except Exception:
            pass
        # Always try to send final &#39;logout&#39;.
        self._session_log_fin = True
        self.write_channel(command + self.RETURN)


class NokiaSrosSSH(NokiaSros):
    &#34;&#34;&#34;Nokia SR OS SSH driver.&#34;&#34;&#34;

    pass


class NokiaSrosTelnet(NokiaSros):
    &#34;&#34;&#34;Nokia SR OS Telnet driver.&#34;&#34;&#34;

    pass


class NokiaSrosFileTransfer(BaseFileTransfer):
    def __init__(
        self,
        ssh_conn: BaseConnection,
        source_file: str,
        dest_file: str,
        file_system: Optional[str] = None,
        direction: str = &#34;put&#34;,
        socket_timeout: float = 10.0,
        progress: Optional[Callable[..., Any]] = None,
        progress4: Optional[Callable[..., Any]] = None,
        hash_supported: bool = False,
    ) -&gt; None:
        super().__init__(
            ssh_conn=ssh_conn,
            source_file=source_file,
            dest_file=dest_file,
            file_system=file_system,
            direction=direction,
            socket_timeout=socket_timeout,
            progress=progress,
            progress4=progress4,
            hash_supported=hash_supported,
        )

    def _file_cmd_prefix(self) -&gt; str:
        &#34;&#34;&#34;
        Allow MD-CLI to execute file operations by using classical CLI.

        Returns &#34;//&#34; if the current prompt is MD-CLI (empty string otherwise).
        &#34;&#34;&#34;
        return &#34;//&#34; if &#34;@&#34; in self.ssh_ctl_chan.base_prompt else &#34;&#34;

    def remote_space_available(
        self, search_pattern: str = r&#34;(\d+)\s+\w+\s+free&#34;
    ) -&gt; int:
        &#34;&#34;&#34;Return space available on remote device.&#34;&#34;&#34;

        # Sample text for search_pattern.
        # &#34;               3 Dir(s)               961531904 bytes free.&#34;
        remote_cmd = self._file_cmd_prefix() + &#34;file dir {}&#34;.format(self.file_system)
        remote_output = self.ssh_ctl_chan._send_command_str(remote_cmd)
        match = re.search(search_pattern, remote_output)
        assert match is not None
        return int(match.group(1))

    def check_file_exists(self, remote_cmd: str = &#34;&#34;) -&gt; bool:
        &#34;&#34;&#34;Check if destination file exists (returns boolean).&#34;&#34;&#34;

        if self.direction == &#34;put&#34;:
            if not remote_cmd:
                remote_cmd = self._file_cmd_prefix() + &#34;file dir {}/{}&#34;.format(
                    self.file_system, self.dest_file
                )
            dest_file_name = self.dest_file.replace(&#34;\\&#34;, &#34;/&#34;).split(&#34;/&#34;)[-1]
            remote_out = self.ssh_ctl_chan.send_command(remote_cmd)
            if &#34;File Not Found&#34; in remote_out:
                return False
            elif dest_file_name in remote_out:
                return True
            else:
                raise ValueError(&#34;Unexpected output from check_file_exists&#34;)
        elif self.direction == &#34;get&#34;:
            return os.path.exists(self.dest_file)
        else:
            raise ValueError(&#34;Unexpected value for self.direction&#34;)

    def remote_file_size(
        self, remote_cmd: str = &#34;&#34;, remote_file: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;Get the file size of the remote file.&#34;&#34;&#34;

        if remote_file is None:
            if self.direction == &#34;put&#34;:
                remote_file = self.dest_file
            elif self.direction == &#34;get&#34;:
                remote_file = self.source_file
            else:
                raise ValueError(&#34;Unexpected value for self.direction&#34;)
        if not remote_cmd:
            remote_cmd = self._file_cmd_prefix() + &#34;file dir {}/{}&#34;.format(
                self.file_system, remote_file
            )
        remote_out = self.ssh_ctl_chan._send_command_str(remote_cmd)

        if &#34;File Not Found&#34; in remote_out:
            raise IOError(&#34;Unable to find file on remote system&#34;)

        dest_file_name = remote_file.replace(&#34;\\&#34;, &#34;/&#34;).split(&#34;/&#34;)[-1]
        # Parse dir output for filename. Output format is:
        # &#34;10/16/2019  10:00p                6738 {dest_file_name}&#34;

        pattern = r&#34;\S+\s+\S+\s+(\d+)\s+{}&#34;.format(re.escape(dest_file_name))
        match = re.search(pattern, remote_out)

        if not match:
            raise ValueError(&#34;Filename entry not found in dir output&#34;)

        file_size = int(match.group(1))
        return file_size

    def verify_file(self) -&gt; bool:
        &#34;&#34;&#34;Verify the file has been transferred correctly based on filesize.&#34;&#34;&#34;
        if self.direction == &#34;put&#34;:
            return os.stat(self.source_file).st_size == self.remote_file_size(
                remote_file=self.dest_file
            )
        elif self.direction == &#34;get&#34;:
            return (
                self.remote_file_size(remote_file=self.source_file)
                == os.stat(self.dest_file).st_size
            )
        else:
            raise ValueError(&#34;Unexpected value of self.direction&#34;)

    def file_md5(self, file_name: str, add_newline: bool = False) -&gt; str:
        raise AttributeError(&#34;SR-OS does not support an MD5-hash operation.&#34;)

    @staticmethod
    def process_md5(md5_output: str, pattern: str = &#34;&#34;) -&gt; str:
        raise AttributeError(&#34;SR-OS does not support an MD5-hash operation.&#34;)

    def compare_md5(self) -&gt; bool:
        raise AttributeError(&#34;SR-OS does not support an MD5-hash operation.&#34;)

    def remote_md5(self, base_cmd: str = &#34;&#34;, remote_file: Optional[str] = None) -&gt; str:
        raise AttributeError(&#34;SR-OS does not support an MD5-hash operation.&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="netmiko.nokia.nokia_sros.NokiaSros"><code class="flex name class">
<span>class <span class="ident">NokiaSros</span></span>
<span>(</span><span>ip: str = '', host: str = '', username: str = '', password: Optional[str] = None, secret: str = '', port: Optional[int] = None, device_type: str = '', verbose: bool = False, global_delay_factor: float = 1.0, global_cmd_verify: Optional[bool] = None, use_keys: bool = False, key_file: Optional[str] = None, pkey: Optional[paramiko.pkey.PKey] = None, passphrase: Optional[str] = None, disabled_algorithms: Optional[Dict[str, Any]] = None, allow_agent: bool = False, ssh_strict: bool = False, system_host_keys: bool = False, alt_host_keys: bool = False, alt_key_file: str = '', ssh_config_file: Optional[str] = None, conn_timeout: int = 10, auth_timeout: Optional[int] = None, banner_timeout: int = 15, blocking_timeout: int = 20, timeout: int = 100, session_timeout: int = 60, read_timeout_override: Optional[float] = None, keepalive: int = 0, default_enter: Optional[str] = None, response_return: Optional[str] = None, serial_settings: Optional[Dict[str, Any]] = None, fast_cli: bool = True, session_log: Optional[<a title="netmiko.session_log.SessionLog" href="../session_log.html#netmiko.session_log.SessionLog">SessionLog</a>] = None, session_log_record_writes: bool = False, session_log_file_mode: str = 'write', allow_auto_change: bool = False, encoding: str = 'utf-8', sock: Optional[socket.socket] = None, auto_connect: bool = True, delay_factor_compat: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement methods for interacting with Nokia SR OS devices
for both SSH and telnet.</p>
<p>Not applicable in Nokia SR OS (disabled):
- exit_enable_mode()</p>
<p>Overriden methods to adapt Nokia SR OS behavior (changed):
- session_preparation()
- set_base_prompt()
- config_mode()
- exit_config_mode()
- check_config_mode()
- save_config()
- commit()
- strip_prompt()
- enable()
- check_enable_mode()</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if &lt;code&gt;host&lt;/code&gt; is
        provided.

    :param host: Hostname of target device. Not required if &lt;code&gt;ip&lt;/code&gt; is
            provided.

    :param username: Username to authenticate against target device if
            required.

    :param password: Password to authenticate against target device if
            required.

    :param secret: The enable password if target device requires one.

    :param port: The destination port used to connect to the target
            device.

    :param device_type: Class selection based on device type.

    :param verbose: Enable additional messages to standard output.

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).

    :param use_keys: Connect to target device using SSH keys.

    :param key_file: Filename path of the SSH key file to use.

    :param pkey: SSH key object to use.

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.

    :param disabled_algorithms: Dictionary of SSH algorithms to disable. Refer to the Paramiko
            documentation for a description of the expected format.

    :param allow_agent: Enable use of SSH key-agent.

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).

    :param system_host_keys: Load host keys from the users known_hosts file.

    :param alt_host_keys: If &lt;code&gt;True&lt;/code&gt; host keys will be loaded from the file specified in
            alt_key_file.

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).

    :param ssh_config_file: File name of OpenSSH configuration file.

    :param timeout: Connection timeout.

    :param session_timeout: Set a timeout for parallel requests.

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: True)

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)

    :param sock: An open socket or socket-like object (such as a &lt;code&gt;.Channel&lt;/code&gt;) to use for
            communication to the target host (default: None).

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function &lt;code&gt;cmd\_verify&lt;/code&gt;
            argument. Value of &lt;code&gt;None&lt;/code&gt; indicates to use function &lt;code&gt;cmd\_verify&lt;/code&gt; argument.

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).

    :param delay_factor_compat: Set send_command and send_command_timing back to using Netmiko
            3.x behavior for delay_factor/global_delay_factor/max_loops. This argument will be
            eliminated in Netmiko 5.x (default: False).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NokiaSros(BaseConnection):
    &#34;&#34;&#34;
    Implement methods for interacting with Nokia SR OS devices
    for both SSH and telnet.

    Not applicable in Nokia SR OS (disabled):
        - exit_enable_mode()

    Overriden methods to adapt Nokia SR OS behavior (changed):
        - session_preparation()
        - set_base_prompt()
        - config_mode()
        - exit_config_mode()
        - check_config_mode()
        - save_config()
        - commit()
        - strip_prompt()
        - enable()
        - check_enable_mode()
    &#34;&#34;&#34;

    def session_preparation(self) -&gt; None:
        self._test_channel_read()
        self.set_base_prompt()
        # &#34;@&#34; indicates model-driven CLI (vs Classical CLI)
        if &#34;@&#34; in self.base_prompt:
            self._disable_complete_on_space()
            self.set_terminal_width(
                command=&#34;environment console width 512&#34;, pattern=&#34;environment&#34;
            )
            self.disable_paging(command=&#34;environment more false&#34;)
            # To perform file operations we need to disable paging in classical-CLI also
            self.disable_paging(command=&#34;//environment no more&#34;)
        else:
            # Classical CLI has no method to set the terminal width nor to disable command
            # complete on space; consequently, cmd_verify needs disabled.
            # Only disabled if not set under the ConnectHandler.
            if self.global_cmd_verify is None:
                self.global_cmd_verify = False
            self.disable_paging(command=&#34;environment no more&#34;, pattern=&#34;environment&#34;)

        # Clear the read buffer
        time.sleep(0.3 * self.global_delay_factor)
        self.clear_buffer()

    def set_base_prompt(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Remove the &gt; when navigating into the different config level.&#34;&#34;&#34;
        cur_base_prompt = super().set_base_prompt(*args, **kwargs)
        match = re.search(r&#34;\*?(.*?)(&gt;.*)*#&#34;, cur_base_prompt)
        if match:
            # strip off &gt;... from base_prompt; strip off leading *
            self.base_prompt: str = match.group(1)

        return self.base_prompt

    def _disable_complete_on_space(self) -&gt; str:
        &#34;&#34;&#34;
        SR-OS tries to auto complete commands when you type a &#34;space&#34; character.

        This is a bad idea for automation as what your program is sending no longer matches
        the command echo from the device, so we disable this behavior.
        &#34;&#34;&#34;
        delay_factor = self.select_delay_factor(delay_factor=0)
        time.sleep(delay_factor * 0.1)
        command = &#34;environment command-completion space false&#34;
        self.write_channel(self.normalize_cmd(command))
        time.sleep(delay_factor * 0.1)
        return self.read_channel()

    def enable(
        self,
        cmd: str = &#34;enable&#34;,
        pattern: str = &#34;ssword&#34;,
        enable_pattern: Optional[str] = None,
        re_flags: int = re.IGNORECASE,
    ) -&gt; str:
        &#34;&#34;&#34;Enable SR OS administrative mode&#34;&#34;&#34;
        if &#34;@&#34; not in self.base_prompt:
            cmd = &#34;enable-admin&#34;
        return super().enable(cmd=cmd, pattern=pattern, re_flags=re_flags)

    def check_enable_mode(self, check_string: str = &#34;in admin mode&#34;) -&gt; bool:
        &#34;&#34;&#34;Check if in enable mode.&#34;&#34;&#34;
        cmd = &#34;enable&#34;
        if &#34;@&#34; not in self.base_prompt:
            cmd = &#34;enable-admin&#34;
        self.write_channel(self.normalize_cmd(cmd))
        output = self.read_until_prompt_or_pattern(
            pattern=&#34;ssword&#34;, read_entire_line=True
        )
        if &#34;ssword&#34; in output:
            self.write_channel(self.RETURN)  # send ENTER to pass the password prompt
            self.read_until_prompt(read_entire_line=True)
        return check_string in output

    def exit_enable_mode(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Nokia SR OS does not have a notion of exiting administrative mode&#34;&#34;&#34;
        return &#34;&#34;

    def config_mode(
        self,
        config_command: str = &#34;edit-config exclusive&#34;,
        pattern: str = &#34;&#34;,
        re_flags: int = 0,
    ) -&gt; str:
        &#34;&#34;&#34;Enable config edit-mode for Nokia SR OS&#34;&#34;&#34;
        output = &#34;&#34;
        if not pattern:
            pattern = rf&#34;\(ex\)\[.*{self.base_prompt}.*$&#34;
            re_flags = re.DOTALL
        # Only model-driven CLI supports config-mode
        if &#34;@&#34; in self.base_prompt:
            output += super().config_mode(
                config_command=config_command, pattern=pattern, re_flags=re_flags
            )
        return output

    def exit_config_mode(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Disable config edit-mode for Nokia SR OS&#34;&#34;&#34;
        output = self._exit_all()
        # Model-driven CLI
        if &#34;@&#34; in self.base_prompt and &#34;(ex)[&#34; in output:
            # Asterisk indicates changes were made.
            if &#34;*(ex)[&#34; in output:
                log.warning(&#34;Uncommitted changes! Discarding changes!&#34;)
                output += self._discard()
            cmd = &#34;quit-config&#34;
            self.write_channel(self.normalize_cmd(cmd))
            if self.global_cmd_verify is not False:
                output += self.read_until_pattern(pattern=re.escape(cmd))
                output += self.read_until_prompt(read_entire_line=True)
            else:
                output += self.read_until_prompt(read_entire_line=True)
        if self.check_config_mode():
            raise ValueError(&#34;Failed to exit configuration mode&#34;)
        return output

    def check_config_mode(
        self,
        check_string: str = r&#34;(ex)[&#34;,
        pattern: str = r&#34;@&#34;,
        force_regex: bool = False,
    ) -&gt; bool:
        &#34;&#34;&#34;Check config mode for Nokia SR OS&#34;&#34;&#34;
        if &#34;@&#34; not in self.base_prompt:
            # Classical CLI
            return False
        else:
            # Model-driven CLI look for &#34;exclusive&#34;
            return super().check_config_mode(check_string=check_string, pattern=pattern)

    def save_config(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Persist configuration to cflash for Nokia SR OS&#34;&#34;&#34;
        return self._send_command_str(command_string=&#34;/admin save&#34;, expect_string=r&#34;#&#34;)

    def send_config_set(
        self,
        config_commands: Union[str, Sequence[str], Iterator[str], TextIO, None] = None,
        exit_config_mode: bool = None,
        **kwargs: Any,
    ) -&gt; str:
        &#34;&#34;&#34;Model driven CLI requires you not exit from configuration mode.&#34;&#34;&#34;
        if exit_config_mode is None:
            # Set to False if model-driven CLI
            exit_config_mode = False if &#34;@&#34; in self.base_prompt else True
        return super().send_config_set(
            config_commands=config_commands, exit_config_mode=exit_config_mode, **kwargs
        )

    def commit(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Activate changes from private candidate for Nokia SR OS&#34;&#34;&#34;
        output = self._exit_all()
        if &#34;@&#34; in self.base_prompt and &#34;*(ex)[&#34; in output:
            log.info(&#34;Apply uncommitted changes!&#34;)
            cmd = &#34;commit&#34;
            self.write_channel(self.normalize_cmd(cmd))
            new_output = &#34;&#34;
            if self.global_cmd_verify is not False:
                new_output += self.read_until_pattern(pattern=re.escape(cmd))
            if &#34;@&#34; not in new_output:
                new_output += self.read_until_pattern(r&#34;@&#34;)
            output += new_output
        return output

    def _exit_all(self) -&gt; str:
        &#34;&#34;&#34;Return to the &#39;root&#39; context.&#34;&#34;&#34;
        output = &#34;&#34;
        exit_cmd = &#34;exit all&#34;
        self.write_channel(self.normalize_cmd(exit_cmd))
        # Make sure you read until you detect the command echo (avoid getting out of sync)
        if self.global_cmd_verify is not False:
            output += self.read_until_pattern(pattern=re.escape(exit_cmd))
            output += self.read_until_prompt(read_entire_line=True)
        else:
            output += self.read_until_prompt(read_entire_line=True)
        return output

    def _discard(self) -&gt; str:
        &#34;&#34;&#34;Discard changes from private candidate for Nokia SR OS&#34;&#34;&#34;
        output = &#34;&#34;
        if &#34;@&#34; in self.base_prompt:
            cmd = &#34;discard&#34;
            self.write_channel(self.normalize_cmd(cmd))
            new_output = &#34;&#34;
            if self.global_cmd_verify is not False:
                new_output += self.read_until_pattern(pattern=re.escape(cmd))
            if &#34;@&#34; not in new_output:
                new_output += self.read_until_prompt(read_entire_line=True)
            output += new_output
        return output

    def strip_prompt(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Strip prompt from the output.&#34;&#34;&#34;
        output = super().strip_prompt(*args, **kwargs)
        if &#34;@&#34; in self.base_prompt:
            # Remove Nokia context prompt too
            output_list = output.rstrip().splitlines()
            last_line = output_list[-1]
            other_lines = output_list[:-1]
            last_line = nokia_context_filter(last_line)
            output_list = other_lines + [last_line]
            return &#34;\n&#34;.join(output_list).rstrip()
        else:
            return output

    def cleanup(self, command: str = &#34;logout&#34;) -&gt; None:
        &#34;&#34;&#34;Gracefully exit the SSH session.&#34;&#34;&#34;
        try:
            # The pattern=&#34;&#34; forces use of send_command_timing
            if self.check_config_mode(pattern=&#34;&#34;):
                self.exit_config_mode()
        except Exception:
            pass
        # Always try to send final &#39;logout&#39;.
        self._session_log_fin = True
        self.write_channel(command + self.RETURN)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="netmiko.nokia.nokia_sros.NokiaSrosSSH" href="#netmiko.nokia.nokia_sros.NokiaSrosSSH">NokiaSrosSSH</a></li>
<li><a title="netmiko.nokia.nokia_sros.NokiaSrosTelnet" href="#netmiko.nokia.nokia_sros.NokiaSrosTelnet">NokiaSrosTelnet</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.check_config_mode"><code class="name flex">
<span>def <span class="ident">check_config_mode</span></span>(<span>self, check_string: str = '(ex)[', pattern: str = '@', force_regex: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check config mode for Nokia SR OS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_config_mode(
    self,
    check_string: str = r&#34;(ex)[&#34;,
    pattern: str = r&#34;@&#34;,
    force_regex: bool = False,
) -&gt; bool:
    &#34;&#34;&#34;Check config mode for Nokia SR OS&#34;&#34;&#34;
    if &#34;@&#34; not in self.base_prompt:
        # Classical CLI
        return False
    else:
        # Model-driven CLI look for &#34;exclusive&#34;
        return super().check_config_mode(check_string=check_string, pattern=pattern)</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.check_enable_mode"><code class="name flex">
<span>def <span class="ident">check_enable_mode</span></span>(<span>self, check_string: str = 'in admin mode') ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if in enable mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_enable_mode(self, check_string: str = &#34;in admin mode&#34;) -&gt; bool:
    &#34;&#34;&#34;Check if in enable mode.&#34;&#34;&#34;
    cmd = &#34;enable&#34;
    if &#34;@&#34; not in self.base_prompt:
        cmd = &#34;enable-admin&#34;
    self.write_channel(self.normalize_cmd(cmd))
    output = self.read_until_prompt_or_pattern(
        pattern=&#34;ssword&#34;, read_entire_line=True
    )
    if &#34;ssword&#34; in output:
        self.write_channel(self.RETURN)  # send ENTER to pass the password prompt
        self.read_until_prompt(read_entire_line=True)
    return check_string in output</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self, command: str = 'logout') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Gracefully exit the SSH session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self, command: str = &#34;logout&#34;) -&gt; None:
    &#34;&#34;&#34;Gracefully exit the SSH session.&#34;&#34;&#34;
    try:
        # The pattern=&#34;&#34; forces use of send_command_timing
        if self.check_config_mode(pattern=&#34;&#34;):
            self.exit_config_mode()
    except Exception:
        pass
    # Always try to send final &#39;logout&#39;.
    self._session_log_fin = True
    self.write_channel(command + self.RETURN)</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Activate changes from private candidate for Nokia SR OS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(self, *args: Any, **kwargs: Any) -&gt; str:
    &#34;&#34;&#34;Activate changes from private candidate for Nokia SR OS&#34;&#34;&#34;
    output = self._exit_all()
    if &#34;@&#34; in self.base_prompt and &#34;*(ex)[&#34; in output:
        log.info(&#34;Apply uncommitted changes!&#34;)
        cmd = &#34;commit&#34;
        self.write_channel(self.normalize_cmd(cmd))
        new_output = &#34;&#34;
        if self.global_cmd_verify is not False:
            new_output += self.read_until_pattern(pattern=re.escape(cmd))
        if &#34;@&#34; not in new_output:
            new_output += self.read_until_pattern(r&#34;@&#34;)
        output += new_output
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.config_mode"><code class="name flex">
<span>def <span class="ident">config_mode</span></span>(<span>self, config_command: str = 'edit-config exclusive', pattern: str = '', re_flags: int = 0) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Enable config edit-mode for Nokia SR OS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_mode(
    self,
    config_command: str = &#34;edit-config exclusive&#34;,
    pattern: str = &#34;&#34;,
    re_flags: int = 0,
) -&gt; str:
    &#34;&#34;&#34;Enable config edit-mode for Nokia SR OS&#34;&#34;&#34;
    output = &#34;&#34;
    if not pattern:
        pattern = rf&#34;\(ex\)\[.*{self.base_prompt}.*$&#34;
        re_flags = re.DOTALL
    # Only model-driven CLI supports config-mode
    if &#34;@&#34; in self.base_prompt:
        output += super().config_mode(
            config_command=config_command, pattern=pattern, re_flags=re_flags
        )
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.enable"><code class="name flex">
<span>def <span class="ident">enable</span></span>(<span>self, cmd: str = 'enable', pattern: str = 'ssword', enable_pattern: Optional[str] = None, re_flags: int = re.IGNORECASE) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Enable SR OS administrative mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable(
    self,
    cmd: str = &#34;enable&#34;,
    pattern: str = &#34;ssword&#34;,
    enable_pattern: Optional[str] = None,
    re_flags: int = re.IGNORECASE,
) -&gt; str:
    &#34;&#34;&#34;Enable SR OS administrative mode&#34;&#34;&#34;
    if &#34;@&#34; not in self.base_prompt:
        cmd = &#34;enable-admin&#34;
    return super().enable(cmd=cmd, pattern=pattern, re_flags=re_flags)</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.exit_config_mode"><code class="name flex">
<span>def <span class="ident">exit_config_mode</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Disable config edit-mode for Nokia SR OS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_config_mode(self, *args: Any, **kwargs: Any) -&gt; str:
    &#34;&#34;&#34;Disable config edit-mode for Nokia SR OS&#34;&#34;&#34;
    output = self._exit_all()
    # Model-driven CLI
    if &#34;@&#34; in self.base_prompt and &#34;(ex)[&#34; in output:
        # Asterisk indicates changes were made.
        if &#34;*(ex)[&#34; in output:
            log.warning(&#34;Uncommitted changes! Discarding changes!&#34;)
            output += self._discard()
        cmd = &#34;quit-config&#34;
        self.write_channel(self.normalize_cmd(cmd))
        if self.global_cmd_verify is not False:
            output += self.read_until_pattern(pattern=re.escape(cmd))
            output += self.read_until_prompt(read_entire_line=True)
        else:
            output += self.read_until_prompt(read_entire_line=True)
    if self.check_config_mode():
        raise ValueError(&#34;Failed to exit configuration mode&#34;)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.exit_enable_mode"><code class="name flex">
<span>def <span class="ident">exit_enable_mode</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Nokia SR OS does not have a notion of exiting administrative mode</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_enable_mode(self, *args: Any, **kwargs: Any) -&gt; str:
    &#34;&#34;&#34;Nokia SR OS does not have a notion of exiting administrative mode&#34;&#34;&#34;
    return &#34;&#34;</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.save_config"><code class="name flex">
<span>def <span class="ident">save_config</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Persist configuration to cflash for Nokia SR OS</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_config(self, *args: Any, **kwargs: Any) -&gt; str:
    &#34;&#34;&#34;Persist configuration to cflash for Nokia SR OS&#34;&#34;&#34;
    return self._send_command_str(command_string=&#34;/admin save&#34;, expect_string=r&#34;#&#34;)</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.send_config_set"><code class="name flex">
<span>def <span class="ident">send_config_set</span></span>(<span>self, config_commands: Union[str, Sequence[str], Iterator[str], TextIO, ForwardRef(None)] = None, exit_config_mode: bool = None, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Model driven CLI requires you not exit from configuration mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_config_set(
    self,
    config_commands: Union[str, Sequence[str], Iterator[str], TextIO, None] = None,
    exit_config_mode: bool = None,
    **kwargs: Any,
) -&gt; str:
    &#34;&#34;&#34;Model driven CLI requires you not exit from configuration mode.&#34;&#34;&#34;
    if exit_config_mode is None:
        # Set to False if model-driven CLI
        exit_config_mode = False if &#34;@&#34; in self.base_prompt else True
    return super().send_config_set(
        config_commands=config_commands, exit_config_mode=exit_config_mode, **kwargs
    )</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.set_base_prompt"><code class="name flex">
<span>def <span class="ident">set_base_prompt</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Remove the &gt; when navigating into the different config level.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_base_prompt(self, *args: Any, **kwargs: Any) -&gt; str:
    &#34;&#34;&#34;Remove the &gt; when navigating into the different config level.&#34;&#34;&#34;
    cur_base_prompt = super().set_base_prompt(*args, **kwargs)
    match = re.search(r&#34;\*?(.*?)(&gt;.*)*#&#34;, cur_base_prompt)
    if match:
        # strip off &gt;... from base_prompt; strip off leading *
        self.base_prompt: str = match.group(1)

    return self.base_prompt</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSros.strip_prompt"><code class="name flex">
<span>def <span class="ident">strip_prompt</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Strip prompt from the output.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_prompt(self, *args: Any, **kwargs: Any) -&gt; str:
    &#34;&#34;&#34;Strip prompt from the output.&#34;&#34;&#34;
    output = super().strip_prompt(*args, **kwargs)
    if &#34;@&#34; in self.base_prompt:
        # Remove Nokia context prompt too
        output_list = output.rstrip().splitlines()
        last_line = output_list[-1]
        other_lines = output_list[:-1]
        last_line = nokia_context_filter(last_line)
        output_list = other_lines + [last_line]
        return &#34;\n&#34;.join(output_list).rstrip()
    else:
        return output</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.base_connection.BaseConnection.clear_buffer" href="../base_connection.html#netmiko.base_connection.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.disable_paging" href="../base_connection.html#netmiko.base_connection.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.disconnect" href="../base_connection.html#netmiko.base_connection.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.establish_connection" href="../base_connection.html#netmiko.base_connection.BaseConnection.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.find_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.is_alive" href="../base_connection.html#netmiko.base_connection.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.normalize_cmd" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.normalize_linefeeds" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.paramiko_cleanup" href="../base_connection.html#netmiko.base_connection.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_channel_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel_timing">read_channel_timing</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_until_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_until_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.run_ttp" href="../base_connection.html#netmiko.base_connection.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.select_delay_factor" href="../base_connection.html#netmiko.base_connection.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_command_expect" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_command_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_config_from_file" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_multiline" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_multiline">send_multiline</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.session_preparation" href="../base_connection.html#netmiko.base_connection.BaseConnection.session_preparation">session_preparation</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.set_terminal_width" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.special_login_handler" href="../base_connection.html#netmiko.base_connection.BaseConnection.special_login_handler">special_login_handler</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.strip_ansi_escape_codes" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.strip_backspaces" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.strip_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.telnet_login" href="../base_connection.html#netmiko.base_connection.BaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.write_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSrosFileTransfer"><code class="flex name class">
<span>class <span class="ident">NokiaSrosFileTransfer</span></span>
<span>(</span><span>ssh_conn: <a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a>, source_file: str, dest_file: str, file_system: Optional[str] = None, direction: str = 'put', socket_timeout: float = 10.0, progress: Optional[Callable[..., Any]] = None, progress4: Optional[Callable[..., Any]] = None, hash_supported: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class to manage SCP file transfer and associated SSH control channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NokiaSrosFileTransfer(BaseFileTransfer):
    def __init__(
        self,
        ssh_conn: BaseConnection,
        source_file: str,
        dest_file: str,
        file_system: Optional[str] = None,
        direction: str = &#34;put&#34;,
        socket_timeout: float = 10.0,
        progress: Optional[Callable[..., Any]] = None,
        progress4: Optional[Callable[..., Any]] = None,
        hash_supported: bool = False,
    ) -&gt; None:
        super().__init__(
            ssh_conn=ssh_conn,
            source_file=source_file,
            dest_file=dest_file,
            file_system=file_system,
            direction=direction,
            socket_timeout=socket_timeout,
            progress=progress,
            progress4=progress4,
            hash_supported=hash_supported,
        )

    def _file_cmd_prefix(self) -&gt; str:
        &#34;&#34;&#34;
        Allow MD-CLI to execute file operations by using classical CLI.

        Returns &#34;//&#34; if the current prompt is MD-CLI (empty string otherwise).
        &#34;&#34;&#34;
        return &#34;//&#34; if &#34;@&#34; in self.ssh_ctl_chan.base_prompt else &#34;&#34;

    def remote_space_available(
        self, search_pattern: str = r&#34;(\d+)\s+\w+\s+free&#34;
    ) -&gt; int:
        &#34;&#34;&#34;Return space available on remote device.&#34;&#34;&#34;

        # Sample text for search_pattern.
        # &#34;               3 Dir(s)               961531904 bytes free.&#34;
        remote_cmd = self._file_cmd_prefix() + &#34;file dir {}&#34;.format(self.file_system)
        remote_output = self.ssh_ctl_chan._send_command_str(remote_cmd)
        match = re.search(search_pattern, remote_output)
        assert match is not None
        return int(match.group(1))

    def check_file_exists(self, remote_cmd: str = &#34;&#34;) -&gt; bool:
        &#34;&#34;&#34;Check if destination file exists (returns boolean).&#34;&#34;&#34;

        if self.direction == &#34;put&#34;:
            if not remote_cmd:
                remote_cmd = self._file_cmd_prefix() + &#34;file dir {}/{}&#34;.format(
                    self.file_system, self.dest_file
                )
            dest_file_name = self.dest_file.replace(&#34;\\&#34;, &#34;/&#34;).split(&#34;/&#34;)[-1]
            remote_out = self.ssh_ctl_chan.send_command(remote_cmd)
            if &#34;File Not Found&#34; in remote_out:
                return False
            elif dest_file_name in remote_out:
                return True
            else:
                raise ValueError(&#34;Unexpected output from check_file_exists&#34;)
        elif self.direction == &#34;get&#34;:
            return os.path.exists(self.dest_file)
        else:
            raise ValueError(&#34;Unexpected value for self.direction&#34;)

    def remote_file_size(
        self, remote_cmd: str = &#34;&#34;, remote_file: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;Get the file size of the remote file.&#34;&#34;&#34;

        if remote_file is None:
            if self.direction == &#34;put&#34;:
                remote_file = self.dest_file
            elif self.direction == &#34;get&#34;:
                remote_file = self.source_file
            else:
                raise ValueError(&#34;Unexpected value for self.direction&#34;)
        if not remote_cmd:
            remote_cmd = self._file_cmd_prefix() + &#34;file dir {}/{}&#34;.format(
                self.file_system, remote_file
            )
        remote_out = self.ssh_ctl_chan._send_command_str(remote_cmd)

        if &#34;File Not Found&#34; in remote_out:
            raise IOError(&#34;Unable to find file on remote system&#34;)

        dest_file_name = remote_file.replace(&#34;\\&#34;, &#34;/&#34;).split(&#34;/&#34;)[-1]
        # Parse dir output for filename. Output format is:
        # &#34;10/16/2019  10:00p                6738 {dest_file_name}&#34;

        pattern = r&#34;\S+\s+\S+\s+(\d+)\s+{}&#34;.format(re.escape(dest_file_name))
        match = re.search(pattern, remote_out)

        if not match:
            raise ValueError(&#34;Filename entry not found in dir output&#34;)

        file_size = int(match.group(1))
        return file_size

    def verify_file(self) -&gt; bool:
        &#34;&#34;&#34;Verify the file has been transferred correctly based on filesize.&#34;&#34;&#34;
        if self.direction == &#34;put&#34;:
            return os.stat(self.source_file).st_size == self.remote_file_size(
                remote_file=self.dest_file
            )
        elif self.direction == &#34;get&#34;:
            return (
                self.remote_file_size(remote_file=self.source_file)
                == os.stat(self.dest_file).st_size
            )
        else:
            raise ValueError(&#34;Unexpected value of self.direction&#34;)

    def file_md5(self, file_name: str, add_newline: bool = False) -&gt; str:
        raise AttributeError(&#34;SR-OS does not support an MD5-hash operation.&#34;)

    @staticmethod
    def process_md5(md5_output: str, pattern: str = &#34;&#34;) -&gt; str:
        raise AttributeError(&#34;SR-OS does not support an MD5-hash operation.&#34;)

    def compare_md5(self) -&gt; bool:
        raise AttributeError(&#34;SR-OS does not support an MD5-hash operation.&#34;)

    def remote_md5(self, base_cmd: str = &#34;&#34;, remote_file: Optional[str] = None) -&gt; str:
        raise AttributeError(&#34;SR-OS does not support an MD5-hash operation.&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.scp_handler.BaseFileTransfer" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer">BaseFileTransfer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="netmiko.nokia.nokia_sros.NokiaSrosFileTransfer.check_file_exists"><code class="name flex">
<span>def <span class="ident">check_file_exists</span></span>(<span>self, remote_cmd: str = '') ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if destination file exists (returns boolean).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_file_exists(self, remote_cmd: str = &#34;&#34;) -&gt; bool:
    &#34;&#34;&#34;Check if destination file exists (returns boolean).&#34;&#34;&#34;

    if self.direction == &#34;put&#34;:
        if not remote_cmd:
            remote_cmd = self._file_cmd_prefix() + &#34;file dir {}/{}&#34;.format(
                self.file_system, self.dest_file
            )
        dest_file_name = self.dest_file.replace(&#34;\\&#34;, &#34;/&#34;).split(&#34;/&#34;)[-1]
        remote_out = self.ssh_ctl_chan.send_command(remote_cmd)
        if &#34;File Not Found&#34; in remote_out:
            return False
        elif dest_file_name in remote_out:
            return True
        else:
            raise ValueError(&#34;Unexpected output from check_file_exists&#34;)
    elif self.direction == &#34;get&#34;:
        return os.path.exists(self.dest_file)
    else:
        raise ValueError(&#34;Unexpected value for self.direction&#34;)</code></pre>
</details>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSrosFileTransfer.verify_file"><code class="name flex">
<span>def <span class="ident">verify_file</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Verify the file has been transferred correctly based on filesize.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def verify_file(self) -&gt; bool:
    &#34;&#34;&#34;Verify the file has been transferred correctly based on filesize.&#34;&#34;&#34;
    if self.direction == &#34;put&#34;:
        return os.stat(self.source_file).st_size == self.remote_file_size(
            remote_file=self.dest_file
        )
    elif self.direction == &#34;get&#34;:
        return (
            self.remote_file_size(remote_file=self.source_file)
            == os.stat(self.dest_file).st_size
        )
    else:
        raise ValueError(&#34;Unexpected value of self.direction&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.scp_handler.BaseFileTransfer" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer">BaseFileTransfer</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.close_scp_chan" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.close_scp_chan">close_scp_chan</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.compare_md5" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.compare_md5">compare_md5</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.disable_scp" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.disable_scp">disable_scp</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.enable_scp" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.enable_scp">enable_scp</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.establish_scp_conn" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.establish_scp_conn">establish_scp_conn</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.file_md5" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.file_md5">file_md5</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.get_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.get_file">get_file</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.local_space_available" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.local_space_available">local_space_available</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.process_md5" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.process_md5">process_md5</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.put_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.put_file">put_file</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.remote_file_size" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_file_size">remote_file_size</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.remote_md5" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_md5">remote_md5</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.remote_space_available" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_space_available">remote_space_available</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.transfer_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.transfer_file">transfer_file</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.verify_space_available" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.verify_space_available">verify_space_available</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSrosSSH"><code class="flex name class">
<span>class <span class="ident">NokiaSrosSSH</span></span>
<span>(</span><span>ip: str = '', host: str = '', username: str = '', password: Optional[str] = None, secret: str = '', port: Optional[int] = None, device_type: str = '', verbose: bool = False, global_delay_factor: float = 1.0, global_cmd_verify: Optional[bool] = None, use_keys: bool = False, key_file: Optional[str] = None, pkey: Optional[paramiko.pkey.PKey] = None, passphrase: Optional[str] = None, disabled_algorithms: Optional[Dict[str, Any]] = None, allow_agent: bool = False, ssh_strict: bool = False, system_host_keys: bool = False, alt_host_keys: bool = False, alt_key_file: str = '', ssh_config_file: Optional[str] = None, conn_timeout: int = 10, auth_timeout: Optional[int] = None, banner_timeout: int = 15, blocking_timeout: int = 20, timeout: int = 100, session_timeout: int = 60, read_timeout_override: Optional[float] = None, keepalive: int = 0, default_enter: Optional[str] = None, response_return: Optional[str] = None, serial_settings: Optional[Dict[str, Any]] = None, fast_cli: bool = True, session_log: Optional[<a title="netmiko.session_log.SessionLog" href="../session_log.html#netmiko.session_log.SessionLog">SessionLog</a>] = None, session_log_record_writes: bool = False, session_log_file_mode: str = 'write', allow_auto_change: bool = False, encoding: str = 'utf-8', sock: Optional[socket.socket] = None, auto_connect: bool = True, delay_factor_compat: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Nokia SR OS SSH driver.</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if &lt;code&gt;host&lt;/code&gt; is
        provided.

    :param host: Hostname of target device. Not required if &lt;code&gt;ip&lt;/code&gt; is
            provided.

    :param username: Username to authenticate against target device if
            required.

    :param password: Password to authenticate against target device if
            required.

    :param secret: The enable password if target device requires one.

    :param port: The destination port used to connect to the target
            device.

    :param device_type: Class selection based on device type.

    :param verbose: Enable additional messages to standard output.

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).

    :param use_keys: Connect to target device using SSH keys.

    :param key_file: Filename path of the SSH key file to use.

    :param pkey: SSH key object to use.

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.

    :param disabled_algorithms: Dictionary of SSH algorithms to disable. Refer to the Paramiko
            documentation for a description of the expected format.

    :param allow_agent: Enable use of SSH key-agent.

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).

    :param system_host_keys: Load host keys from the users known_hosts file.

    :param alt_host_keys: If &lt;code&gt;True&lt;/code&gt; host keys will be loaded from the file specified in
            alt_key_file.

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).

    :param ssh_config_file: File name of OpenSSH configuration file.

    :param timeout: Connection timeout.

    :param session_timeout: Set a timeout for parallel requests.

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: True)

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)

    :param sock: An open socket or socket-like object (such as a &lt;code&gt;.Channel&lt;/code&gt;) to use for
            communication to the target host (default: None).

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function &lt;code&gt;cmd\_verify&lt;/code&gt;
            argument. Value of &lt;code&gt;None&lt;/code&gt; indicates to use function &lt;code&gt;cmd\_verify&lt;/code&gt; argument.

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).

    :param delay_factor_compat: Set send_command and send_command_timing back to using Netmiko
            3.x behavior for delay_factor/global_delay_factor/max_loops. This argument will be
            eliminated in Netmiko 5.x (default: False).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NokiaSrosSSH(NokiaSros):
    &#34;&#34;&#34;Nokia SR OS SSH driver.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.nokia.nokia_sros.NokiaSros" href="#netmiko.nokia.nokia_sros.NokiaSros">NokiaSros</a></li>
<li><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.nokia.nokia_sros.NokiaSros" href="#netmiko.nokia.nokia_sros.NokiaSros">NokiaSros</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.check_config_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.check_enable_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.cleanup" href="#netmiko.nokia.nokia_sros.NokiaSros.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.clear_buffer" href="../base_connection.html#netmiko.base_connection.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.commit" href="#netmiko.nokia.nokia_sros.NokiaSros.commit">commit</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.config_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.disable_paging" href="../base_connection.html#netmiko.base_connection.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.disconnect" href="../base_connection.html#netmiko.base_connection.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.enable" href="#netmiko.nokia.nokia_sros.NokiaSros.enable">enable</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.establish_connection" href="../base_connection.html#netmiko.base_connection.BaseConnection.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.exit_config_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.exit_enable_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.find_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.is_alive" href="../base_connection.html#netmiko.base_connection.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.normalize_cmd" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.normalize_linefeeds" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.paramiko_cleanup" href="../base_connection.html#netmiko.base_connection.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.read_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.read_channel_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel_timing">read_channel_timing</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.read_until_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.read_until_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.read_until_prompt_or_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.run_ttp" href="../base_connection.html#netmiko.base_connection.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.save_config" href="#netmiko.nokia.nokia_sros.NokiaSros.save_config">save_config</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.select_delay_factor" href="../base_connection.html#netmiko.base_connection.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_command_expect" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_command_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_config_from_file" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_config_set" href="#netmiko.nokia.nokia_sros.NokiaSros.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_multiline" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_multiline">send_multiline</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.session_preparation" href="../base_connection.html#netmiko.base_connection.BaseConnection.session_preparation">session_preparation</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.set_base_prompt" href="#netmiko.nokia.nokia_sros.NokiaSros.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.set_terminal_width" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.special_login_handler" href="../base_connection.html#netmiko.base_connection.BaseConnection.special_login_handler">special_login_handler</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.strip_ansi_escape_codes" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.strip_backspaces" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.strip_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.strip_prompt" href="#netmiko.nokia.nokia_sros.NokiaSros.strip_prompt">strip_prompt</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.telnet_login" href="../base_connection.html#netmiko.base_connection.BaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.write_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="netmiko.nokia.nokia_sros.NokiaSrosTelnet"><code class="flex name class">
<span>class <span class="ident">NokiaSrosTelnet</span></span>
<span>(</span><span>ip: str = '', host: str = '', username: str = '', password: Optional[str] = None, secret: str = '', port: Optional[int] = None, device_type: str = '', verbose: bool = False, global_delay_factor: float = 1.0, global_cmd_verify: Optional[bool] = None, use_keys: bool = False, key_file: Optional[str] = None, pkey: Optional[paramiko.pkey.PKey] = None, passphrase: Optional[str] = None, disabled_algorithms: Optional[Dict[str, Any]] = None, allow_agent: bool = False, ssh_strict: bool = False, system_host_keys: bool = False, alt_host_keys: bool = False, alt_key_file: str = '', ssh_config_file: Optional[str] = None, conn_timeout: int = 10, auth_timeout: Optional[int] = None, banner_timeout: int = 15, blocking_timeout: int = 20, timeout: int = 100, session_timeout: int = 60, read_timeout_override: Optional[float] = None, keepalive: int = 0, default_enter: Optional[str] = None, response_return: Optional[str] = None, serial_settings: Optional[Dict[str, Any]] = None, fast_cli: bool = True, session_log: Optional[<a title="netmiko.session_log.SessionLog" href="../session_log.html#netmiko.session_log.SessionLog">SessionLog</a>] = None, session_log_record_writes: bool = False, session_log_file_mode: str = 'write', allow_auto_change: bool = False, encoding: str = 'utf-8', sock: Optional[socket.socket] = None, auto_connect: bool = True, delay_factor_compat: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Nokia SR OS Telnet driver.</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if &lt;code&gt;host&lt;/code&gt; is
        provided.

    :param host: Hostname of target device. Not required if &lt;code&gt;ip&lt;/code&gt; is
            provided.

    :param username: Username to authenticate against target device if
            required.

    :param password: Password to authenticate against target device if
            required.

    :param secret: The enable password if target device requires one.

    :param port: The destination port used to connect to the target
            device.

    :param device_type: Class selection based on device type.

    :param verbose: Enable additional messages to standard output.

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).

    :param use_keys: Connect to target device using SSH keys.

    :param key_file: Filename path of the SSH key file to use.

    :param pkey: SSH key object to use.

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.

    :param disabled_algorithms: Dictionary of SSH algorithms to disable. Refer to the Paramiko
            documentation for a description of the expected format.

    :param allow_agent: Enable use of SSH key-agent.

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).

    :param system_host_keys: Load host keys from the users known_hosts file.

    :param alt_host_keys: If &lt;code&gt;True&lt;/code&gt; host keys will be loaded from the file specified in
            alt_key_file.

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).

    :param ssh_config_file: File name of OpenSSH configuration file.

    :param timeout: Connection timeout.

    :param session_timeout: Set a timeout for parallel requests.

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: True)

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)

    :param sock: An open socket or socket-like object (such as a &lt;code&gt;.Channel&lt;/code&gt;) to use for
            communication to the target host (default: None).

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function &lt;code&gt;cmd\_verify&lt;/code&gt;
            argument. Value of &lt;code&gt;None&lt;/code&gt; indicates to use function &lt;code&gt;cmd\_verify&lt;/code&gt; argument.

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).

    :param delay_factor_compat: Set send_command and send_command_timing back to using Netmiko
            3.x behavior for delay_factor/global_delay_factor/max_loops. This argument will be
            eliminated in Netmiko 5.x (default: False).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NokiaSrosTelnet(NokiaSros):
    &#34;&#34;&#34;Nokia SR OS Telnet driver.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.nokia.nokia_sros.NokiaSros" href="#netmiko.nokia.nokia_sros.NokiaSros">NokiaSros</a></li>
<li><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.nokia.nokia_sros.NokiaSros" href="#netmiko.nokia.nokia_sros.NokiaSros">NokiaSros</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.check_config_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.check_enable_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.cleanup" href="#netmiko.nokia.nokia_sros.NokiaSros.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.clear_buffer" href="../base_connection.html#netmiko.base_connection.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.commit" href="#netmiko.nokia.nokia_sros.NokiaSros.commit">commit</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.config_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.disable_paging" href="../base_connection.html#netmiko.base_connection.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.disconnect" href="../base_connection.html#netmiko.base_connection.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.enable" href="#netmiko.nokia.nokia_sros.NokiaSros.enable">enable</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.establish_connection" href="../base_connection.html#netmiko.base_connection.BaseConnection.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.exit_config_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.exit_enable_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.find_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.is_alive" href="../base_connection.html#netmiko.base_connection.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.normalize_cmd" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.normalize_linefeeds" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.paramiko_cleanup" href="../base_connection.html#netmiko.base_connection.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.read_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.read_channel_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel_timing">read_channel_timing</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.read_until_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.read_until_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.read_until_prompt_or_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.run_ttp" href="../base_connection.html#netmiko.base_connection.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.save_config" href="#netmiko.nokia.nokia_sros.NokiaSros.save_config">save_config</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.select_delay_factor" href="../base_connection.html#netmiko.base_connection.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_command_expect" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_command_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_config_from_file" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_config_set" href="#netmiko.nokia.nokia_sros.NokiaSros.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_multiline" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_multiline">send_multiline</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.session_preparation" href="../base_connection.html#netmiko.base_connection.BaseConnection.session_preparation">session_preparation</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.set_base_prompt" href="#netmiko.nokia.nokia_sros.NokiaSros.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.set_terminal_width" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.special_login_handler" href="../base_connection.html#netmiko.base_connection.BaseConnection.special_login_handler">special_login_handler</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.strip_ansi_escape_codes" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.strip_backspaces" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.strip_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.strip_prompt" href="#netmiko.nokia.nokia_sros.NokiaSros.strip_prompt">strip_prompt</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.telnet_login" href="../base_connection.html#netmiko.base_connection.BaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.write_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="netmiko.nokia" href="index.html">netmiko.nokia</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="netmiko.nokia.nokia_sros.NokiaSros" href="#netmiko.nokia.nokia_sros.NokiaSros">NokiaSros</a></code></h4>
<ul class="two-column">
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.check_config_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.check_enable_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.cleanup" href="#netmiko.nokia.nokia_sros.NokiaSros.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.commit" href="#netmiko.nokia.nokia_sros.NokiaSros.commit">commit</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.config_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.enable" href="#netmiko.nokia.nokia_sros.NokiaSros.enable">enable</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.exit_config_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.exit_enable_mode" href="#netmiko.nokia.nokia_sros.NokiaSros.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.save_config" href="#netmiko.nokia.nokia_sros.NokiaSros.save_config">save_config</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.send_config_set" href="#netmiko.nokia.nokia_sros.NokiaSros.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.set_base_prompt" href="#netmiko.nokia.nokia_sros.NokiaSros.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSros.strip_prompt" href="#netmiko.nokia.nokia_sros.NokiaSros.strip_prompt">strip_prompt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="netmiko.nokia.nokia_sros.NokiaSrosFileTransfer" href="#netmiko.nokia.nokia_sros.NokiaSrosFileTransfer">NokiaSrosFileTransfer</a></code></h4>
<ul class="">
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSrosFileTransfer.check_file_exists" href="#netmiko.nokia.nokia_sros.NokiaSrosFileTransfer.check_file_exists">check_file_exists</a></code></li>
<li><code><a title="netmiko.nokia.nokia_sros.NokiaSrosFileTransfer.verify_file" href="#netmiko.nokia.nokia_sros.NokiaSrosFileTransfer.verify_file">verify_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="netmiko.nokia.nokia_sros.NokiaSrosSSH" href="#netmiko.nokia.nokia_sros.NokiaSrosSSH">NokiaSrosSSH</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.nokia.nokia_sros.NokiaSrosTelnet" href="#netmiko.nokia.nokia_sros.NokiaSrosTelnet">NokiaSrosTelnet</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>