<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.6.3" />
<title>netmiko.cisco.cisco_xr API documentation</title>
<meta name="description" content="" />
<link href='https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css' rel='stylesheet'>
<link href='https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/8.0.0/sanitize.min.css' rel='stylesheet'>
<link href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/github.min.css" rel="stylesheet">
<style>.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{font-weight:bold}#index h4 + ul{margin-bottom:.6em}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase;cursor:pointer}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>netmiko.cisco.cisco_xr</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>Source code</summary>
<pre><code class="python">import re
from netmiko.cisco_base_connection import CiscoBaseConnection, CiscoFileTransfer


class CiscoXrBase(CiscoBaseConnection):
    def __init__(self, *args, **kwargs):
        # Cisco NX-OS defaults to fast_cli=True and legacy_mode=False
        kwargs.setdefault(&#34;fast_cli&#34;, True)
        kwargs.setdefault(&#34;_legacy_mode&#34;, False)
        return super().__init__(*args, **kwargs)

    def establish_connection(self):
        &#34;&#34;&#34;Establish SSH connection to the network device&#34;&#34;&#34;
        super().establish_connection(width=511, height=511)

    def session_preparation(self):
        &#34;&#34;&#34;Prepare the session after the connection has been established.&#34;&#34;&#34;
        # IOS-XR has an issue where it echoes the command even though it hasn&#39;t returned the prompt
        self._test_channel_read(pattern=r&#34;[&gt;#]&#34;)
        cmd = &#34;terminal width 511&#34;
        self.set_terminal_width(command=cmd, pattern=cmd)
        self.disable_paging()
        self._test_channel_read(pattern=r&#34;[&gt;#]&#34;)
        self.set_base_prompt()

    def send_config_set(self, config_commands=None, exit_config_mode=False, **kwargs):
        &#34;&#34;&#34;IOS-XR requires you not exit from configuration mode.&#34;&#34;&#34;
        return super().send_config_set(
            config_commands=config_commands, exit_config_mode=exit_config_mode, **kwargs
        )

    def commit(
        self, confirm=False, confirm_delay=None, comment=&#34;&#34;, label=&#34;&#34;, delay_factor=1
    ):
        &#34;&#34;&#34;
        Commit the candidate configuration.

        default (no options):
            command_string = commit
        confirm and confirm_delay:
            command_string = commit confirmed &lt;confirm_delay&gt;
        label (which is a label name):
            command_string = commit label &lt;label&gt;
        comment:
            command_string = commit comment &lt;comment&gt;

        supported combinations
        label and confirm:
            command_string = commit label &lt;label&gt; confirmed &lt;confirm_delay&gt;
        label and comment:
            command_string = commit label &lt;label&gt; comment &lt;comment&gt;

        All other combinations will result in an exception.

        failed commit message:
        % Failed to commit one or more configuration items during a pseudo-atomic operation. All
        changes made have been reverted. Please issue &#39;show configuration failed [inheritance]&#39;
        from this session to view the errors

        message XR shows if other commits occurred:
        One or more commits have occurred from other configuration sessions since this session
        started or since the last commit was made from this session. You can use the &#39;show
        configuration commit changes&#39; command to browse the changes.

        Exit of configuration mode with pending changes will cause the changes to be discarded and
        an exception to be generated.
        &#34;&#34;&#34;
        delay_factor = self.select_delay_factor(delay_factor)
        if confirm and not confirm_delay:
            raise ValueError(&#34;Invalid arguments supplied to XR commit&#34;)
        if confirm_delay and not confirm:
            raise ValueError(&#34;Invalid arguments supplied to XR commit&#34;)
        if comment and confirm:
            raise ValueError(&#34;Invalid arguments supplied to XR commit&#34;)

        label = str(label)
        error_marker = &#34;Failed to&#34;
        alt_error_marker = &#34;One or more commits have occurred from other&#34;

        # Select proper command string based on arguments provided
        if label:
            if comment:
                command_string = f&#34;commit label {label} comment {comment}&#34;
            elif confirm:
                command_string = &#34;commit label {} confirmed {}&#34;.format(
                    label, str(confirm_delay)
                )
            else:
                command_string = f&#34;commit label {label}&#34;
        elif confirm:
            command_string = f&#34;commit confirmed {str(confirm_delay)}&#34;
        elif comment:
            command_string = f&#34;commit comment {comment}&#34;
        else:
            command_string = &#34;commit&#34;

        # Enter config mode (if necessary)
        output = self.config_mode()
        output += self.send_command_expect(
            command_string,
            strip_prompt=False,
            strip_command=False,
            delay_factor=delay_factor,
        )
        if error_marker in output:
            raise ValueError(f&#34;Commit failed with the following errors:\n\n{output}&#34;)
        if alt_error_marker in output:
            # Other commits occurred, don&#39;t proceed with commit
            output += self.send_command_timing(
                &#34;no&#34;, strip_prompt=False, strip_command=False, delay_factor=delay_factor
            )
            raise ValueError(f&#34;Commit failed with the following errors:\n\n{output}&#34;)

        return output

    def check_config_mode(self, check_string=&#34;)#&#34;, pattern=r&#34;[#\$]&#34;):
        &#34;&#34;&#34;Checks if the device is in configuration mode or not.

        IOS-XR, unfortunately, does this:
        RP/0/RSP0/CPU0:BNG(admin)#
        &#34;&#34;&#34;
        self.write_channel(self.RETURN)
        output = self.read_until_pattern(pattern=pattern)
        # Strip out (admin) so we don&#39;t get a false positive with (admin)#
        # (admin-config)# would still match.
        output = output.replace(&#34;(admin)&#34;, &#34;&#34;)
        return check_string in output

    def exit_config_mode(self, exit_config=&#34;end&#34;, pattern=&#34;&#34;):
        &#34;&#34;&#34;Exit configuration mode.&#34;&#34;&#34;
        output = &#34;&#34;
        if self.check_config_mode():
            self.write_channel(self.normalize_cmd(exit_config))
            # Make sure you read until you detect the command echo (avoid getting out of sync)
            if self.global_cmd_verify is not False:
                output += self.read_until_pattern(
                    pattern=re.escape(exit_config.strip())
                )
            # Read until we detect either an Uncommitted change or the end prompt
            if not re.search(r&#34;(Uncommitted|#$)&#34;, output):
                output += self.read_until_pattern(pattern=r&#34;(Uncommitted|#$)&#34;)
            if &#34;Uncommitted changes found&#34; in output:
                self.write_channel(self.normalize_cmd(&#34;no\n&#34;))
                output += self.read_until_pattern(pattern=r&#34;[&gt;#]&#34;)
            if not re.search(pattern, output, flags=re.M):
                output += self.read_until_pattern(pattern=pattern)
            if self.check_config_mode():
                raise ValueError(&#34;Failed to exit configuration mode&#34;)
        return output

    def save_config(self, *args, **kwargs):
        &#34;&#34;&#34;Not Implemented (use commit() method)&#34;&#34;&#34;
        raise NotImplementedError


class CiscoXrSSH(CiscoXrBase):
    &#34;&#34;&#34;Cisco XR SSH driver.&#34;&#34;&#34;

    pass


class CiscoXrTelnet(CiscoXrBase):
    &#34;&#34;&#34;Cisco XR Telnet driver.&#34;&#34;&#34;

    pass


class CiscoXrFileTransfer(CiscoFileTransfer):
    &#34;&#34;&#34;Cisco IOS-XR SCP File Transfer driver.&#34;&#34;&#34;

    def process_md5(self, md5_output, pattern=r&#34;^([a-fA-F0-9]+)$&#34;):
        &#34;&#34;&#34;
        IOS-XR defaults with timestamps enabled

        # show md5 file /bootflash:/boot/grub/grub.cfg
        Sat Mar  3 17:49:03.596 UTC
        c84843f0030efd44b01343fdb8c2e801
        &#34;&#34;&#34;
        match = re.search(pattern, md5_output, flags=re.M)
        if match:
            return match.group(1)
        else:
            raise ValueError(f&#34;Invalid output from MD5 command: {md5_output}&#34;)

    def remote_md5(self, base_cmd=&#34;show md5 file&#34;, remote_file=None):
        &#34;&#34;&#34;
        IOS-XR for MD5 requires this extra leading /

        show md5 file /bootflash:/boot/grub/grub.cfg
        &#34;&#34;&#34;
        if remote_file is None:
            if self.direction == &#34;put&#34;:
                remote_file = self.dest_file
            elif self.direction == &#34;get&#34;:
                remote_file = self.source_file
        # IOS-XR requires both the leading slash and the slash between file-system and file here
        remote_md5_cmd = f&#34;{base_cmd} /{self.file_system}/{remote_file}&#34;
        dest_md5 = self.ssh_ctl_chan.send_command(remote_md5_cmd, max_loops=1500)
        dest_md5 = self.process_md5(dest_md5)
        return dest_md5

    def enable_scp(self, cmd=None):
        raise NotImplementedError

    def disable_scp(self, cmd=None):
        raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="netmiko.cisco.cisco_xr.CiscoXrBase"><code class="flex name class">
<span>class <span class="ident">CiscoXrBase</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Base Class for cisco-like behavior.</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if `host` is
        provided.
    :type ip: str

    :param host: Hostname of target device. Not required if `ip` is
            provided.
    :type host: str

    :param username: Username to authenticate against target device if
            required.
    :type username: str

    :param password: Password to authenticate against target device if
            required.
    :type password: str

    :param secret: The enable password if target device requires one.
    :type secret: str

    :param port: The destination port used to connect to the target
            device.
    :type port: int or None

    :param device_type: Class selection based on device type.
    :type device_type: str

    :param verbose: Enable additional messages to standard output.
    :type verbose: bool

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).
    :type global_delay_factor: int

    :param use_keys: Connect to target device using SSH keys.
    :type use_keys: bool

    :param key_file: Filename path of the SSH key file to use.
    :type key_file: str

    :param pkey: SSH key object to use.
    :type pkey: paramiko.PKey

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.
    :type passphrase: str

    :param allow_agent: Enable use of SSH key-agent.
    :type allow_agent: bool

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).
    :type ssh_strict: bool

    :param system_host_keys: Load host keys from the users known_hosts file.
    :type system_host_keys: bool
    :param alt_host_keys: If `True` host keys will be loaded from the file specified in
            alt_key_file.
    :type alt_host_keys: bool

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).
    :type alt_key_file: str

    :param ssh_config_file: File name of OpenSSH configuration file.
    :type ssh_config_file: str

    :param timeout: Connection timeout.
    :type timeout: float

    :param session_timeout: Set a timeout for parallel requests.
    :type session_timeout: float

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.
    :type auth_timeout: float

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).
    :type banner_timeout: float

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).
    :type keepalive: int

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).
:type default_enter: str</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)
:type response_return: str</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: False)
    :type fast_cli: boolean

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.
    :type session_log: str

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).
    :type session_log_record_writes: boolean

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")
    :type session_log_file_mode: str

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)
    :type allow_auto_change: bool

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)
    :type encoding: str

    :param sock: An open socket or socket-like object (such as a `.Channel`) to use for
            communication to the target host (default: None).
    :type sock: socket

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function `cmd_verify`
            argument. Value of `None` indicates to use function `cmd_verify` argument.
    :type global_cmd_verify: bool|None

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).
    :type auto_connect: bool
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CiscoXrBase(CiscoBaseConnection):
    def __init__(self, *args, **kwargs):
        # Cisco NX-OS defaults to fast_cli=True and legacy_mode=False
        kwargs.setdefault(&#34;fast_cli&#34;, True)
        kwargs.setdefault(&#34;_legacy_mode&#34;, False)
        return super().__init__(*args, **kwargs)

    def establish_connection(self):
        &#34;&#34;&#34;Establish SSH connection to the network device&#34;&#34;&#34;
        super().establish_connection(width=511, height=511)

    def session_preparation(self):
        &#34;&#34;&#34;Prepare the session after the connection has been established.&#34;&#34;&#34;
        # IOS-XR has an issue where it echoes the command even though it hasn&#39;t returned the prompt
        self._test_channel_read(pattern=r&#34;[&gt;#]&#34;)
        cmd = &#34;terminal width 511&#34;
        self.set_terminal_width(command=cmd, pattern=cmd)
        self.disable_paging()
        self._test_channel_read(pattern=r&#34;[&gt;#]&#34;)
        self.set_base_prompt()

    def send_config_set(self, config_commands=None, exit_config_mode=False, **kwargs):
        &#34;&#34;&#34;IOS-XR requires you not exit from configuration mode.&#34;&#34;&#34;
        return super().send_config_set(
            config_commands=config_commands, exit_config_mode=exit_config_mode, **kwargs
        )

    def commit(
        self, confirm=False, confirm_delay=None, comment=&#34;&#34;, label=&#34;&#34;, delay_factor=1
    ):
        &#34;&#34;&#34;
        Commit the candidate configuration.

        default (no options):
            command_string = commit
        confirm and confirm_delay:
            command_string = commit confirmed &lt;confirm_delay&gt;
        label (which is a label name):
            command_string = commit label &lt;label&gt;
        comment:
            command_string = commit comment &lt;comment&gt;

        supported combinations
        label and confirm:
            command_string = commit label &lt;label&gt; confirmed &lt;confirm_delay&gt;
        label and comment:
            command_string = commit label &lt;label&gt; comment &lt;comment&gt;

        All other combinations will result in an exception.

        failed commit message:
        % Failed to commit one or more configuration items during a pseudo-atomic operation. All
        changes made have been reverted. Please issue &#39;show configuration failed [inheritance]&#39;
        from this session to view the errors

        message XR shows if other commits occurred:
        One or more commits have occurred from other configuration sessions since this session
        started or since the last commit was made from this session. You can use the &#39;show
        configuration commit changes&#39; command to browse the changes.

        Exit of configuration mode with pending changes will cause the changes to be discarded and
        an exception to be generated.
        &#34;&#34;&#34;
        delay_factor = self.select_delay_factor(delay_factor)
        if confirm and not confirm_delay:
            raise ValueError(&#34;Invalid arguments supplied to XR commit&#34;)
        if confirm_delay and not confirm:
            raise ValueError(&#34;Invalid arguments supplied to XR commit&#34;)
        if comment and confirm:
            raise ValueError(&#34;Invalid arguments supplied to XR commit&#34;)

        label = str(label)
        error_marker = &#34;Failed to&#34;
        alt_error_marker = &#34;One or more commits have occurred from other&#34;

        # Select proper command string based on arguments provided
        if label:
            if comment:
                command_string = f&#34;commit label {label} comment {comment}&#34;
            elif confirm:
                command_string = &#34;commit label {} confirmed {}&#34;.format(
                    label, str(confirm_delay)
                )
            else:
                command_string = f&#34;commit label {label}&#34;
        elif confirm:
            command_string = f&#34;commit confirmed {str(confirm_delay)}&#34;
        elif comment:
            command_string = f&#34;commit comment {comment}&#34;
        else:
            command_string = &#34;commit&#34;

        # Enter config mode (if necessary)
        output = self.config_mode()
        output += self.send_command_expect(
            command_string,
            strip_prompt=False,
            strip_command=False,
            delay_factor=delay_factor,
        )
        if error_marker in output:
            raise ValueError(f&#34;Commit failed with the following errors:\n\n{output}&#34;)
        if alt_error_marker in output:
            # Other commits occurred, don&#39;t proceed with commit
            output += self.send_command_timing(
                &#34;no&#34;, strip_prompt=False, strip_command=False, delay_factor=delay_factor
            )
            raise ValueError(f&#34;Commit failed with the following errors:\n\n{output}&#34;)

        return output

    def check_config_mode(self, check_string=&#34;)#&#34;, pattern=r&#34;[#\$]&#34;):
        &#34;&#34;&#34;Checks if the device is in configuration mode or not.

        IOS-XR, unfortunately, does this:
        RP/0/RSP0/CPU0:BNG(admin)#
        &#34;&#34;&#34;
        self.write_channel(self.RETURN)
        output = self.read_until_pattern(pattern=pattern)
        # Strip out (admin) so we don&#39;t get a false positive with (admin)#
        # (admin-config)# would still match.
        output = output.replace(&#34;(admin)&#34;, &#34;&#34;)
        return check_string in output

    def exit_config_mode(self, exit_config=&#34;end&#34;, pattern=&#34;&#34;):
        &#34;&#34;&#34;Exit configuration mode.&#34;&#34;&#34;
        output = &#34;&#34;
        if self.check_config_mode():
            self.write_channel(self.normalize_cmd(exit_config))
            # Make sure you read until you detect the command echo (avoid getting out of sync)
            if self.global_cmd_verify is not False:
                output += self.read_until_pattern(
                    pattern=re.escape(exit_config.strip())
                )
            # Read until we detect either an Uncommitted change or the end prompt
            if not re.search(r&#34;(Uncommitted|#$)&#34;, output):
                output += self.read_until_pattern(pattern=r&#34;(Uncommitted|#$)&#34;)
            if &#34;Uncommitted changes found&#34; in output:
                self.write_channel(self.normalize_cmd(&#34;no\n&#34;))
                output += self.read_until_pattern(pattern=r&#34;[&gt;#]&#34;)
            if not re.search(pattern, output, flags=re.M):
                output += self.read_until_pattern(pattern=pattern)
            if self.check_config_mode():
                raise ValueError(&#34;Failed to exit configuration mode&#34;)
        return output

    def save_config(self, *args, **kwargs):
        &#34;&#34;&#34;Not Implemented (use commit() method)&#34;&#34;&#34;
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.cisco_base_connection.CiscoBaseConnection" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection">CiscoBaseConnection</a></li>
<li><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="netmiko.cisco.cisco_xr.CiscoXrSSH" href="#netmiko.cisco.cisco_xr.CiscoXrSSH">CiscoXrSSH</a></li>
<li><a title="netmiko.cisco.cisco_xr.CiscoXrTelnet" href="#netmiko.cisco.cisco_xr.CiscoXrTelnet">CiscoXrTelnet</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="netmiko.cisco.cisco_xr.CiscoXrBase.check_config_mode"><code class="name flex">
<span>def <span class="ident">check_config_mode</span></span>(<span>self, check_string=')#', pattern='[#\\$]')</span>
</code></dt>
<dd>
<section class="desc"><p>Checks if the device is in configuration mode or not.</p>
<p>IOS-XR, unfortunately, does this:
RP/0/RSP0/CPU0:BNG(admin)#</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def check_config_mode(self, check_string=&#34;)#&#34;, pattern=r&#34;[#\$]&#34;):
    &#34;&#34;&#34;Checks if the device is in configuration mode or not.

    IOS-XR, unfortunately, does this:
    RP/0/RSP0/CPU0:BNG(admin)#
    &#34;&#34;&#34;
    self.write_channel(self.RETURN)
    output = self.read_until_pattern(pattern=pattern)
    # Strip out (admin) so we don&#39;t get a false positive with (admin)#
    # (admin-config)# would still match.
    output = output.replace(&#34;(admin)&#34;, &#34;&#34;)
    return check_string in output</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_xr.CiscoXrBase.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self, confirm=False, confirm_delay=None, comment='', label='', delay_factor=1)</span>
</code></dt>
<dd>
<section class="desc"><p>Commit the candidate configuration.</p>
<p>default (no options):
command_string = commit
confirm and confirm_delay:
command_string = commit confirmed <confirm_delay>
label (which is a label name):
command_string = commit label <label>
comment:
command_string = commit comment <comment></p>
<p>supported combinations
label and confirm:
command_string = commit label <label> confirmed <confirm_delay>
label and comment:
command_string = commit label <label> comment <comment></p>
<p>All other combinations will result in an exception.</p>
<p>failed commit message:
% Failed to commit one or more configuration items during a pseudo-atomic operation. All
changes made have been reverted. Please issue 'show configuration failed [inheritance]'
from this session to view the errors</p>
<p>message XR shows if other commits occurred:
One or more commits have occurred from other configuration sessions since this session
started or since the last commit was made from this session. You can use the 'show
configuration commit changes' command to browse the changes.</p>
<p>Exit of configuration mode with pending changes will cause the changes to be discarded and
an exception to be generated.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def commit(
    self, confirm=False, confirm_delay=None, comment=&#34;&#34;, label=&#34;&#34;, delay_factor=1
):
    &#34;&#34;&#34;
    Commit the candidate configuration.

    default (no options):
        command_string = commit
    confirm and confirm_delay:
        command_string = commit confirmed &lt;confirm_delay&gt;
    label (which is a label name):
        command_string = commit label &lt;label&gt;
    comment:
        command_string = commit comment &lt;comment&gt;

    supported combinations
    label and confirm:
        command_string = commit label &lt;label&gt; confirmed &lt;confirm_delay&gt;
    label and comment:
        command_string = commit label &lt;label&gt; comment &lt;comment&gt;

    All other combinations will result in an exception.

    failed commit message:
    % Failed to commit one or more configuration items during a pseudo-atomic operation. All
    changes made have been reverted. Please issue &#39;show configuration failed [inheritance]&#39;
    from this session to view the errors

    message XR shows if other commits occurred:
    One or more commits have occurred from other configuration sessions since this session
    started or since the last commit was made from this session. You can use the &#39;show
    configuration commit changes&#39; command to browse the changes.

    Exit of configuration mode with pending changes will cause the changes to be discarded and
    an exception to be generated.
    &#34;&#34;&#34;
    delay_factor = self.select_delay_factor(delay_factor)
    if confirm and not confirm_delay:
        raise ValueError(&#34;Invalid arguments supplied to XR commit&#34;)
    if confirm_delay and not confirm:
        raise ValueError(&#34;Invalid arguments supplied to XR commit&#34;)
    if comment and confirm:
        raise ValueError(&#34;Invalid arguments supplied to XR commit&#34;)

    label = str(label)
    error_marker = &#34;Failed to&#34;
    alt_error_marker = &#34;One or more commits have occurred from other&#34;

    # Select proper command string based on arguments provided
    if label:
        if comment:
            command_string = f&#34;commit label {label} comment {comment}&#34;
        elif confirm:
            command_string = &#34;commit label {} confirmed {}&#34;.format(
                label, str(confirm_delay)
            )
        else:
            command_string = f&#34;commit label {label}&#34;
    elif confirm:
        command_string = f&#34;commit confirmed {str(confirm_delay)}&#34;
    elif comment:
        command_string = f&#34;commit comment {comment}&#34;
    else:
        command_string = &#34;commit&#34;

    # Enter config mode (if necessary)
    output = self.config_mode()
    output += self.send_command_expect(
        command_string,
        strip_prompt=False,
        strip_command=False,
        delay_factor=delay_factor,
    )
    if error_marker in output:
        raise ValueError(f&#34;Commit failed with the following errors:\n\n{output}&#34;)
    if alt_error_marker in output:
        # Other commits occurred, don&#39;t proceed with commit
        output += self.send_command_timing(
            &#34;no&#34;, strip_prompt=False, strip_command=False, delay_factor=delay_factor
        )
        raise ValueError(f&#34;Commit failed with the following errors:\n\n{output}&#34;)

    return output</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_xr.CiscoXrBase.establish_connection"><code class="name flex">
<span>def <span class="ident">establish_connection</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Establish SSH connection to the network device</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def establish_connection(self):
    &#34;&#34;&#34;Establish SSH connection to the network device&#34;&#34;&#34;
    super().establish_connection(width=511, height=511)</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_xr.CiscoXrBase.exit_config_mode"><code class="name flex">
<span>def <span class="ident">exit_config_mode</span></span>(<span>self, exit_config='end', pattern='')</span>
</code></dt>
<dd>
<section class="desc"><p>Exit configuration mode.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def exit_config_mode(self, exit_config=&#34;end&#34;, pattern=&#34;&#34;):
    &#34;&#34;&#34;Exit configuration mode.&#34;&#34;&#34;
    output = &#34;&#34;
    if self.check_config_mode():
        self.write_channel(self.normalize_cmd(exit_config))
        # Make sure you read until you detect the command echo (avoid getting out of sync)
        if self.global_cmd_verify is not False:
            output += self.read_until_pattern(
                pattern=re.escape(exit_config.strip())
            )
        # Read until we detect either an Uncommitted change or the end prompt
        if not re.search(r&#34;(Uncommitted|#$)&#34;, output):
            output += self.read_until_pattern(pattern=r&#34;(Uncommitted|#$)&#34;)
        if &#34;Uncommitted changes found&#34; in output:
            self.write_channel(self.normalize_cmd(&#34;no\n&#34;))
            output += self.read_until_pattern(pattern=r&#34;[&gt;#]&#34;)
        if not re.search(pattern, output, flags=re.M):
            output += self.read_until_pattern(pattern=pattern)
        if self.check_config_mode():
            raise ValueError(&#34;Failed to exit configuration mode&#34;)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_xr.CiscoXrBase.save_config"><code class="name flex">
<span>def <span class="ident">save_config</span></span>(<span>self, *args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Not Implemented (use commit() method)</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def save_config(self, *args, **kwargs):
    &#34;&#34;&#34;Not Implemented (use commit() method)&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_xr.CiscoXrBase.send_config_set"><code class="name flex">
<span>def <span class="ident">send_config_set</span></span>(<span>self, config_commands=None, exit_config_mode=False, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>IOS-XR requires you not exit from configuration mode.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def send_config_set(self, config_commands=None, exit_config_mode=False, **kwargs):
    &#34;&#34;&#34;IOS-XR requires you not exit from configuration mode.&#34;&#34;&#34;
    return super().send_config_set(
        config_commands=config_commands, exit_config_mode=exit_config_mode, **kwargs
    )</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_xr.CiscoXrBase.session_preparation"><code class="name flex">
<span>def <span class="ident">session_preparation</span></span>(<span>self)</span>
</code></dt>
<dd>
<section class="desc"><p>Prepare the session after the connection has been established.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def session_preparation(self):
    &#34;&#34;&#34;Prepare the session after the connection has been established.&#34;&#34;&#34;
    # IOS-XR has an issue where it echoes the command even though it hasn&#39;t returned the prompt
    self._test_channel_read(pattern=r&#34;[&gt;#]&#34;)
    cmd = &#34;terminal width 511&#34;
    self.set_terminal_width(command=cmd, pattern=cmd)
    self.disable_paging()
    self._test_channel_read(pattern=r&#34;[&gt;#]&#34;)
    self.set_base_prompt()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.cisco_base_connection.CiscoBaseConnection" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection">CiscoBaseConnection</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.check_enable_mode" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.cleanup" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.clear_buffer" href="../base_connection.html#netmiko.base_connection.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.close_session_log" href="../base_connection.html#netmiko.base_connection.BaseConnection.close_session_log">close_session_log</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.config_mode" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.disable_paging" href="../base_connection.html#netmiko.base_connection.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.disconnect" href="../base_connection.html#netmiko.base_connection.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.enable" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.enable">enable</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.exit_enable_mode" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.find_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.is_alive" href="../base_connection.html#netmiko.base_connection.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.normalize_cmd" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.normalize_linefeeds" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.open_session_log" href="../base_connection.html#netmiko.base_connection.BaseConnection.open_session_log">open_session_log</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.paramiko_cleanup" href="../base_connection.html#netmiko.base_connection.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.read_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.read_until_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.read_until_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.read_until_prompt_or_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.run_ttp" href="../base_connection.html#netmiko.base_connection.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.select_delay_factor" href="../base_connection.html#netmiko.base_connection.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.send_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.send_command_expect" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.send_command_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.send_config_from_file" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.set_base_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.set_terminal_width" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.special_login_handler" href="../base_connection.html#netmiko.base_connection.BaseConnection.special_login_handler">special_login_handler</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.strip_ansi_escape_codes" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.strip_backspaces" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.strip_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.strip_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_prompt">strip_prompt</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.telnet_login" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoBaseConnection.write_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="netmiko.cisco.cisco_xr.CiscoXrFileTransfer"><code class="flex name class">
<span>class <span class="ident">CiscoXrFileTransfer</span></span>
<span>(</span><span>ssh_conn, source_file, dest_file, file_system=None, direction='put', socket_timeout=10.0, progress=None, progress4=None, hash_supported=True)</span>
</code></dt>
<dd>
<section class="desc"><p>Cisco IOS-XR SCP File Transfer driver.</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CiscoXrFileTransfer(CiscoFileTransfer):
    &#34;&#34;&#34;Cisco IOS-XR SCP File Transfer driver.&#34;&#34;&#34;

    def process_md5(self, md5_output, pattern=r&#34;^([a-fA-F0-9]+)$&#34;):
        &#34;&#34;&#34;
        IOS-XR defaults with timestamps enabled

        # show md5 file /bootflash:/boot/grub/grub.cfg
        Sat Mar  3 17:49:03.596 UTC
        c84843f0030efd44b01343fdb8c2e801
        &#34;&#34;&#34;
        match = re.search(pattern, md5_output, flags=re.M)
        if match:
            return match.group(1)
        else:
            raise ValueError(f&#34;Invalid output from MD5 command: {md5_output}&#34;)

    def remote_md5(self, base_cmd=&#34;show md5 file&#34;, remote_file=None):
        &#34;&#34;&#34;
        IOS-XR for MD5 requires this extra leading /

        show md5 file /bootflash:/boot/grub/grub.cfg
        &#34;&#34;&#34;
        if remote_file is None:
            if self.direction == &#34;put&#34;:
                remote_file = self.dest_file
            elif self.direction == &#34;get&#34;:
                remote_file = self.source_file
        # IOS-XR requires both the leading slash and the slash between file-system and file here
        remote_md5_cmd = f&#34;{base_cmd} /{self.file_system}/{remote_file}&#34;
        dest_md5 = self.ssh_ctl_chan.send_command(remote_md5_cmd, max_loops=1500)
        dest_md5 = self.process_md5(dest_md5)
        return dest_md5

    def enable_scp(self, cmd=None):
        raise NotImplementedError

    def disable_scp(self, cmd=None):
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.cisco_base_connection.CiscoFileTransfer" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoFileTransfer">CiscoFileTransfer</a></li>
<li><a title="netmiko.scp_handler.BaseFileTransfer" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer">BaseFileTransfer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="netmiko.cisco.cisco_xr.CiscoXrFileTransfer.process_md5"><code class="name flex">
<span>def <span class="ident">process_md5</span></span>(<span>self, md5_output, pattern='^([a-fA-F0-9]+)$')</span>
</code></dt>
<dd>
<section class="desc"><p>IOS-XR defaults with timestamps enabled</p>
<h1 id="show-md5-file-bootflashbootgrubgrubcfg">show md5 file /bootflash:/boot/grub/grub.cfg</h1>
<p>Sat Mar
3 17:49:03.596 UTC
c84843f0030efd44b01343fdb8c2e801</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def process_md5(self, md5_output, pattern=r&#34;^([a-fA-F0-9]+)$&#34;):
    &#34;&#34;&#34;
    IOS-XR defaults with timestamps enabled

    # show md5 file /bootflash:/boot/grub/grub.cfg
    Sat Mar  3 17:49:03.596 UTC
    c84843f0030efd44b01343fdb8c2e801
    &#34;&#34;&#34;
    match = re.search(pattern, md5_output, flags=re.M)
    if match:
        return match.group(1)
    else:
        raise ValueError(f&#34;Invalid output from MD5 command: {md5_output}&#34;)</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_xr.CiscoXrFileTransfer.remote_md5"><code class="name flex">
<span>def <span class="ident">remote_md5</span></span>(<span>self, base_cmd='show md5 file', remote_file=None)</span>
</code></dt>
<dd>
<section class="desc"><p>IOS-XR for MD5 requires this extra leading /</p>
<p>show md5 file /bootflash:/boot/grub/grub.cfg</p></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">def remote_md5(self, base_cmd=&#34;show md5 file&#34;, remote_file=None):
    &#34;&#34;&#34;
    IOS-XR for MD5 requires this extra leading /

    show md5 file /bootflash:/boot/grub/grub.cfg
    &#34;&#34;&#34;
    if remote_file is None:
        if self.direction == &#34;put&#34;:
            remote_file = self.dest_file
        elif self.direction == &#34;get&#34;:
            remote_file = self.source_file
    # IOS-XR requires both the leading slash and the slash between file-system and file here
    remote_md5_cmd = f&#34;{base_cmd} /{self.file_system}/{remote_file}&#34;
    dest_md5 = self.ssh_ctl_chan.send_command(remote_md5_cmd, max_loops=1500)
    dest_md5 = self.process_md5(dest_md5)
    return dest_md5</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.cisco_base_connection.CiscoFileTransfer" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoFileTransfer">CiscoFileTransfer</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.check_file_exists" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.check_file_exists">check_file_exists</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.close_scp_chan" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.close_scp_chan">close_scp_chan</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.compare_md5" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.compare_md5">compare_md5</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.disable_scp" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.disable_scp">disable_scp</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.enable_scp" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.enable_scp">enable_scp</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.establish_scp_conn" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.establish_scp_conn">establish_scp_conn</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.file_md5" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.file_md5">file_md5</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.get_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.get_file">get_file</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.local_space_available" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.local_space_available">local_space_available</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.put_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.put_file">put_file</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.remote_file_size" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_file_size">remote_file_size</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.remote_space_available" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_space_available">remote_space_available</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.transfer_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.transfer_file">transfer_file</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.verify_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.verify_file">verify_file</a></code></li>
<li><code><a title="netmiko.cisco_base_connection.CiscoFileTransfer.verify_space_available" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.verify_space_available">verify_space_available</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="netmiko.cisco.cisco_xr.CiscoXrSSH"><code class="flex name class">
<span>class <span class="ident">CiscoXrSSH</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Cisco XR SSH driver.</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if `host` is
        provided.
    :type ip: str

    :param host: Hostname of target device. Not required if `ip` is
            provided.
    :type host: str

    :param username: Username to authenticate against target device if
            required.
    :type username: str

    :param password: Password to authenticate against target device if
            required.
    :type password: str

    :param secret: The enable password if target device requires one.
    :type secret: str

    :param port: The destination port used to connect to the target
            device.
    :type port: int or None

    :param device_type: Class selection based on device type.
    :type device_type: str

    :param verbose: Enable additional messages to standard output.
    :type verbose: bool

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).
    :type global_delay_factor: int

    :param use_keys: Connect to target device using SSH keys.
    :type use_keys: bool

    :param key_file: Filename path of the SSH key file to use.
    :type key_file: str

    :param pkey: SSH key object to use.
    :type pkey: paramiko.PKey

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.
    :type passphrase: str

    :param allow_agent: Enable use of SSH key-agent.
    :type allow_agent: bool

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).
    :type ssh_strict: bool

    :param system_host_keys: Load host keys from the users known_hosts file.
    :type system_host_keys: bool
    :param alt_host_keys: If `True` host keys will be loaded from the file specified in
            alt_key_file.
    :type alt_host_keys: bool

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).
    :type alt_key_file: str

    :param ssh_config_file: File name of OpenSSH configuration file.
    :type ssh_config_file: str

    :param timeout: Connection timeout.
    :type timeout: float

    :param session_timeout: Set a timeout for parallel requests.
    :type session_timeout: float

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.
    :type auth_timeout: float

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).
    :type banner_timeout: float

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).
    :type keepalive: int

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).
:type default_enter: str</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)
:type response_return: str</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: False)
    :type fast_cli: boolean

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.
    :type session_log: str

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).
    :type session_log_record_writes: boolean

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")
    :type session_log_file_mode: str

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)
    :type allow_auto_change: bool

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)
    :type encoding: str

    :param sock: An open socket or socket-like object (such as a `.Channel`) to use for
            communication to the target host (default: None).
    :type sock: socket

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function `cmd_verify`
            argument. Value of `None` indicates to use function `cmd_verify` argument.
    :type global_cmd_verify: bool|None

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).
    :type auto_connect: bool
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CiscoXrSSH(CiscoXrBase):
    &#34;&#34;&#34;Cisco XR SSH driver.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.cisco.cisco_xr.CiscoXrBase" href="#netmiko.cisco.cisco_xr.CiscoXrBase">CiscoXrBase</a></li>
<li><a title="netmiko.cisco_base_connection.CiscoBaseConnection" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection">CiscoBaseConnection</a></li>
<li><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.cisco.cisco_xr.CiscoXrBase" href="#netmiko.cisco.cisco_xr.CiscoXrBase">CiscoXrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.check_config_mode" href="#netmiko.cisco.cisco_xr.CiscoXrBase.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.check_enable_mode" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.cleanup" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.clear_buffer" href="../base_connection.html#netmiko.base_connection.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.close_session_log" href="../base_connection.html#netmiko.base_connection.BaseConnection.close_session_log">close_session_log</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.commit" href="#netmiko.cisco.cisco_xr.CiscoXrBase.commit">commit</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.config_mode" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.disable_paging" href="../base_connection.html#netmiko.base_connection.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.disconnect" href="../base_connection.html#netmiko.base_connection.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.enable" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.enable">enable</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.establish_connection" href="#netmiko.cisco.cisco_xr.CiscoXrBase.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.exit_config_mode" href="#netmiko.cisco.cisco_xr.CiscoXrBase.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.exit_enable_mode" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.find_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.is_alive" href="../base_connection.html#netmiko.base_connection.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.normalize_cmd" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.normalize_linefeeds" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.open_session_log" href="../base_connection.html#netmiko.base_connection.BaseConnection.open_session_log">open_session_log</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.paramiko_cleanup" href="../base_connection.html#netmiko.base_connection.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.read_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.read_until_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.read_until_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.read_until_prompt_or_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.run_ttp" href="../base_connection.html#netmiko.base_connection.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.save_config" href="#netmiko.cisco.cisco_xr.CiscoXrBase.save_config">save_config</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.select_delay_factor" href="../base_connection.html#netmiko.base_connection.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_command_expect" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_command_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_config_from_file" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_config_set" href="#netmiko.cisco.cisco_xr.CiscoXrBase.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.session_preparation" href="#netmiko.cisco.cisco_xr.CiscoXrBase.session_preparation">session_preparation</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.set_base_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.set_terminal_width" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.special_login_handler" href="../base_connection.html#netmiko.base_connection.BaseConnection.special_login_handler">special_login_handler</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.strip_ansi_escape_codes" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.strip_backspaces" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.strip_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.strip_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_prompt">strip_prompt</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.telnet_login" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.write_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="netmiko.cisco.cisco_xr.CiscoXrTelnet"><code class="flex name class">
<span>class <span class="ident">CiscoXrTelnet</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<section class="desc"><p>Cisco XR Telnet driver.</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if `host` is
        provided.
    :type ip: str

    :param host: Hostname of target device. Not required if `ip` is
            provided.
    :type host: str

    :param username: Username to authenticate against target device if
            required.
    :type username: str

    :param password: Password to authenticate against target device if
            required.
    :type password: str

    :param secret: The enable password if target device requires one.
    :type secret: str

    :param port: The destination port used to connect to the target
            device.
    :type port: int or None

    :param device_type: Class selection based on device type.
    :type device_type: str

    :param verbose: Enable additional messages to standard output.
    :type verbose: bool

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).
    :type global_delay_factor: int

    :param use_keys: Connect to target device using SSH keys.
    :type use_keys: bool

    :param key_file: Filename path of the SSH key file to use.
    :type key_file: str

    :param pkey: SSH key object to use.
    :type pkey: paramiko.PKey

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.
    :type passphrase: str

    :param allow_agent: Enable use of SSH key-agent.
    :type allow_agent: bool

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).
    :type ssh_strict: bool

    :param system_host_keys: Load host keys from the users known_hosts file.
    :type system_host_keys: bool
    :param alt_host_keys: If `True` host keys will be loaded from the file specified in
            alt_key_file.
    :type alt_host_keys: bool

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).
    :type alt_key_file: str

    :param ssh_config_file: File name of OpenSSH configuration file.
    :type ssh_config_file: str

    :param timeout: Connection timeout.
    :type timeout: float

    :param session_timeout: Set a timeout for parallel requests.
    :type session_timeout: float

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.
    :type auth_timeout: float

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).
    :type banner_timeout: float

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).
    :type keepalive: int

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).
:type default_enter: str</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)
:type response_return: str</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: False)
    :type fast_cli: boolean

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.
    :type session_log: str

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).
    :type session_log_record_writes: boolean

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")
    :type session_log_file_mode: str

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)
    :type allow_auto_change: bool

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)
    :type encoding: str

    :param sock: An open socket or socket-like object (such as a `.Channel`) to use for
            communication to the target host (default: None).
    :type sock: socket

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function `cmd_verify`
            argument. Value of `None` indicates to use function `cmd_verify` argument.
    :type global_cmd_verify: bool|None

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).
    :type auto_connect: bool
</code></pre></section>
<details class="source">
<summary>Source code</summary>
<pre><code class="python">class CiscoXrTelnet(CiscoXrBase):
    &#34;&#34;&#34;Cisco XR Telnet driver.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.cisco.cisco_xr.CiscoXrBase" href="#netmiko.cisco.cisco_xr.CiscoXrBase">CiscoXrBase</a></li>
<li><a title="netmiko.cisco_base_connection.CiscoBaseConnection" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection">CiscoBaseConnection</a></li>
<li><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.cisco.cisco_xr.CiscoXrBase" href="#netmiko.cisco.cisco_xr.CiscoXrBase">CiscoXrBase</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.check_config_mode" href="#netmiko.cisco.cisco_xr.CiscoXrBase.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.check_enable_mode" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.cleanup" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.clear_buffer" href="../base_connection.html#netmiko.base_connection.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.close_session_log" href="../base_connection.html#netmiko.base_connection.BaseConnection.close_session_log">close_session_log</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.commit" href="#netmiko.cisco.cisco_xr.CiscoXrBase.commit">commit</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.config_mode" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.disable_paging" href="../base_connection.html#netmiko.base_connection.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.disconnect" href="../base_connection.html#netmiko.base_connection.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.enable" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.enable">enable</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.establish_connection" href="#netmiko.cisco.cisco_xr.CiscoXrBase.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.exit_config_mode" href="#netmiko.cisco.cisco_xr.CiscoXrBase.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.exit_enable_mode" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.find_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.is_alive" href="../base_connection.html#netmiko.base_connection.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.normalize_cmd" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.normalize_linefeeds" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.open_session_log" href="../base_connection.html#netmiko.base_connection.BaseConnection.open_session_log">open_session_log</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.paramiko_cleanup" href="../base_connection.html#netmiko.base_connection.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.read_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.read_until_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.read_until_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.read_until_prompt_or_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.run_ttp" href="../base_connection.html#netmiko.base_connection.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.save_config" href="#netmiko.cisco.cisco_xr.CiscoXrBase.save_config">save_config</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.select_delay_factor" href="../base_connection.html#netmiko.base_connection.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_command_expect" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_command_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_config_from_file" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_config_set" href="#netmiko.cisco.cisco_xr.CiscoXrBase.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.session_preparation" href="#netmiko.cisco.cisco_xr.CiscoXrBase.session_preparation">session_preparation</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.set_base_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.set_terminal_width" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.special_login_handler" href="../base_connection.html#netmiko.base_connection.BaseConnection.special_login_handler">special_login_handler</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.strip_ansi_escape_codes" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.strip_backspaces" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.strip_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.strip_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_prompt">strip_prompt</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.telnet_login" href="../cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.write_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="netmiko.cisco" href="index.html">netmiko.cisco</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase" href="#netmiko.cisco.cisco_xr.CiscoXrBase">CiscoXrBase</a></code></h4>
<ul class="">
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.check_config_mode" href="#netmiko.cisco.cisco_xr.CiscoXrBase.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.commit" href="#netmiko.cisco.cisco_xr.CiscoXrBase.commit">commit</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.establish_connection" href="#netmiko.cisco.cisco_xr.CiscoXrBase.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.exit_config_mode" href="#netmiko.cisco.cisco_xr.CiscoXrBase.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.save_config" href="#netmiko.cisco.cisco_xr.CiscoXrBase.save_config">save_config</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.send_config_set" href="#netmiko.cisco.cisco_xr.CiscoXrBase.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrBase.session_preparation" href="#netmiko.cisco.cisco_xr.CiscoXrBase.session_preparation">session_preparation</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="netmiko.cisco.cisco_xr.CiscoXrFileTransfer" href="#netmiko.cisco.cisco_xr.CiscoXrFileTransfer">CiscoXrFileTransfer</a></code></h4>
<ul class="">
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrFileTransfer.process_md5" href="#netmiko.cisco.cisco_xr.CiscoXrFileTransfer.process_md5">process_md5</a></code></li>
<li><code><a title="netmiko.cisco.cisco_xr.CiscoXrFileTransfer.remote_md5" href="#netmiko.cisco.cisco_xr.CiscoXrFileTransfer.remote_md5">remote_md5</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="netmiko.cisco.cisco_xr.CiscoXrSSH" href="#netmiko.cisco.cisco_xr.CiscoXrSSH">CiscoXrSSH</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.cisco.cisco_xr.CiscoXrTelnet" href="#netmiko.cisco.cisco_xr.CiscoXrTelnet">CiscoXrTelnet</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.6.3</a>.</p>
</footer>
<script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/highlight.min.js"></script>
<script>hljs.initHighlightingOnLoad()</script>
</body>
</html>