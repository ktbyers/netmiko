<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>netmiko.cisco.cisco_wlc_ssh API documentation</title>
<meta name="description" content="Netmiko Cisco WLC support." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>netmiko.cisco.cisco_wlc_ssh</code></h1>
</header>
<section id="section-intro">
<p>Netmiko Cisco WLC support.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Netmiko Cisco WLC support.&#34;&#34;&#34;
from typing import Any, Union, Sequence, Iterator, TextIO
import time
import re
import socket

from netmiko.exceptions import NetmikoAuthenticationException
from netmiko.base_connection import BaseConnection


class CiscoWlcSSH(BaseConnection):
    &#34;&#34;&#34;Netmiko Cisco WLC support.&#34;&#34;&#34;

    prompt_pattern = r&#34;(?m:[&gt;#]\s*$)&#34;  # force re.Multiline

    def special_login_handler(self, delay_factor: float = 1.0) -&gt; None:
        &#34;&#34;&#34;WLC presents with the following on login (in certain OS versions)

        login as: user

        (Cisco Controller)

        User: user

        Password:****
        &#34;&#34;&#34;
        output = &#34;&#34;
        uname = &#34;User:&#34;
        login = &#34;login as&#34;
        password = &#34;ssword&#34;
        pattern = rf&#34;(?:{uname}|{login}|{password}|{self.prompt_pattern})&#34;

        while True:
            new_data = self.read_until_pattern(pattern=pattern, read_timeout=25.0)
            output += new_data
            if re.search(self.prompt_pattern, new_data):
                return

            if uname in new_data or login in new_data:
                assert isinstance(self.username, str)
                self.write_channel(self.username + self.RETURN)
            elif password in new_data:
                assert isinstance(self.password, str)
                self.write_channel(self.password + self.RETURN)
            else:
                msg = f&#34;&#34;&#34;
Failed to login to Cisco WLC Device.

Pattern not detected: {pattern}
output:

{output}

&#34;&#34;&#34;
                raise NetmikoAuthenticationException(msg)

    def session_preparation(self) -&gt; None:
        &#34;&#34;&#34;
        Prepare the session after the connection has been established

        Cisco WLC uses &#34;config paging disable&#34; to disable paging
        &#34;&#34;&#34;

        # _test_channel_read() will happen in the special_login_handler()
        try:
            self.set_base_prompt()
        except ValueError:
            msg = f&#34;Authentication failed: {self.host}&#34;
            raise NetmikoAuthenticationException(msg)

        self.disable_paging(command=&#34;config paging disable&#34;)

    def send_command_w_enter(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;
        For &#39;show run-config&#39; Cisco WLC adds a &#39;Press Enter to continue...&#39; message
        Even though pagination is disabled.

        show run-config also has excessive delays in the output which requires special
        handling.

        Arguments are the same as send_command_timing() method.
        &#34;&#34;&#34;
        if len(args) &gt; 1:
            raise ValueError(&#34;Must pass in delay_factor as keyword argument&#34;)

        # If no delay_factor use 1 for default value
        delay_factor = kwargs.get(&#34;delay_factor&#34;, 1)
        kwargs[&#34;delay_factor&#34;] = self.select_delay_factor(delay_factor)
        output = self._send_command_timing_str(*args, **kwargs)

        second_args = list(args)
        if len(args) == 1:
            second_args[0] = self.RETURN
        else:
            kwargs[&#34;command_string&#34;] = self.RETURN
        if not kwargs.get(&#34;max_loops&#34;):
            kwargs[&#34;max_loops&#34;] = 150

        if &#34;Press any key&#34; in output or &#34;Press Enter to&#34; in output:

            # Send an &#39;enter&#39;
            output += self._send_command_timing_str(*second_args, **kwargs)

            # WLC has excessive delay after this appears on screen
            if &#34;802.11b Advanced Configuration&#34; in output:

                # Defaults to 30 seconds
                time.sleep(kwargs[&#34;delay_factor&#34;] * 30)
                not_done = True
                i = 1
                while not_done and i &lt;= 150:
                    time.sleep(kwargs[&#34;delay_factor&#34;] * 3)
                    i += 1
                    new_data = &#34;&#34;
                    new_data = self.read_channel()
                    if new_data:
                        output += new_data
                    else:
                        not_done = False

        strip_prompt = kwargs.get(&#34;strip_prompt&#34;, True)
        if strip_prompt:
            # Had to strip trailing prompt twice.
            output = self.strip_prompt(output)
            output = self.strip_prompt(output)
        return output

    def _send_command_w_yes(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;
        For &#39;show interface summary&#39; Cisco WLC adds a
        &#39;Would you like to display the next 15 entries?&#39; message.

        Even though pagination is disabled
        Arguments are the same as send_command_timing() method.
        &#34;&#34;&#34;
        if len(args) &gt; 1:
            raise ValueError(&#34;Must pass in delay_factor as keyword argument&#34;)

        # If no delay_factor use 1 for default value
        delay_factor = kwargs.get(&#34;delay_factor&#34;, 1)
        kwargs[&#34;delay_factor&#34;] = self.select_delay_factor(delay_factor)

        output = &#34;&#34;
        new_output = self._send_command_timing_str(*args, **kwargs)

        second_args = list(args)
        if len(args) == 1:
            second_args[0] = &#34;y&#34;
        else:
            kwargs[&#34;command_string&#34;] = &#34;y&#34;
        strip_prompt = kwargs.get(&#34;strip_prompt&#34;, True)

        while True:
            output += new_output
            if &#34;display the next&#34; in new_output.lower():
                new_output = self._send_command_timing_str(*second_args, **kwargs)
            else:
                break

        # Remove from output &#39;Would you like to display the next 15 entries? (y/n)&#39;
        pattern = r&#34;^.*display the next.*\n$&#34;
        output = re.sub(pattern, &#34;&#34;, output, flags=re.M)

        if strip_prompt:
            # Had to strip trailing prompt twice.
            output = self.strip_prompt(output)
            output = self.strip_prompt(output)
        return output

    def cleanup(self, command: str = &#34;logout&#34;) -&gt; None:
        &#34;&#34;&#34;Reset WLC back to normal paging and gracefully close session.&#34;&#34;&#34;
        self.send_command_timing(&#34;config paging enable&#34;)

        # Exit configuration mode
        try:
            # The pattern=&#34;&#34; forces use of send_command_timing
            if self.check_config_mode(pattern=&#34;&#34;):
                self.exit_config_mode()
        except Exception:
            pass

        # End SSH/telnet session
        self.write_channel(command + self.RETURN)
        count = 0
        output = &#34;&#34;
        while count &lt;= 5:
            time.sleep(0.5)

            # The connection might be dead at this point.
            try:
                output += self.read_channel()
            except socket.error:
                break

            # Don&#39;t automatically save the config (user&#39;s responsibility)
            if &#34;Would you like to save them now&#34; in output:
                self._session_log_fin = True
                self.write_channel(&#34;n&#34; + self.RETURN)

            try:
                self.write_channel(self.RETURN)
            except socket.error:
                break
            count += 1

    def check_config_mode(
        self, check_string: str = &#34;config&#34;, pattern: str = &#34;&#34;, force_regex: bool = False
    ) -&gt; bool:
        &#34;&#34;&#34;Checks if the device is in configuration mode or not.&#34;&#34;&#34;
        if not pattern:
            pattern = re.escape(self.base_prompt)
        return super().check_config_mode(check_string, pattern)

    def config_mode(
        self, config_command: str = &#34;config&#34;, pattern: str = &#34;&#34;, re_flags: int = 0
    ) -&gt; str:
        &#34;&#34;&#34;Enter into config_mode.&#34;&#34;&#34;
        return super().config_mode(
            config_command=config_command, pattern=pattern, re_flags=re_flags
        )

    def exit_config_mode(self, exit_config: str = &#34;exit&#34;, pattern: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Exit config_mode.&#34;&#34;&#34;
        return super().exit_config_mode(exit_config, pattern)

    def send_config_set(
        self,
        config_commands: Union[str, Sequence[str], Iterator[str], TextIO, None] = None,
        exit_config_mode: bool = False,
        enter_config_mode: bool = False,
        **kwargs: Any,
    ) -&gt; str:
        return super().send_config_set(
            config_commands=config_commands,
            exit_config_mode=exit_config_mode,
            enter_config_mode=enter_config_mode,
            **kwargs,
        )

    def save_config(
        self,
        cmd: str = &#34;save config&#34;,
        confirm: bool = True,
        confirm_response: str = &#34;y&#34;,
    ) -&gt; str:
        &#34;&#34;&#34;Saves Config.&#34;&#34;&#34;
        self.enable()
        if confirm:
            output = self._send_command_timing_str(command_string=cmd)
            if confirm_response:
                output += self._send_command_timing_str(confirm_response)
            else:
                # Send enter by default
                output += self._send_command_timing_str(self.RETURN)
        else:
            # Some devices are slow so match on trailing-prompt if you can
            output = self._send_command_str(command_string=cmd)
        return output</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH"><code class="flex name class">
<span>class <span class="ident">CiscoWlcSSH</span></span>
<span>(</span><span>ip: str = '', host: str = '', username: str = '', password: Optional[str] = None, secret: str = '', port: Optional[int] = None, device_type: str = '', verbose: bool = False, global_delay_factor: float = 1.0, global_cmd_verify: Optional[bool] = None, use_keys: bool = False, key_file: Optional[str] = None, pkey: Optional[paramiko.pkey.PKey] = None, passphrase: Optional[str] = None, disabled_algorithms: Optional[Dict[str, Any]] = None, allow_agent: bool = False, ssh_strict: bool = False, system_host_keys: bool = False, alt_host_keys: bool = False, alt_key_file: str = '', ssh_config_file: Optional[str] = None, conn_timeout: int = 10, auth_timeout: Optional[int] = None, banner_timeout: int = 15, blocking_timeout: int = 20, timeout: int = 100, session_timeout: int = 60, read_timeout_override: Optional[float] = None, keepalive: int = 0, default_enter: Optional[str] = None, response_return: Optional[str] = None, serial_settings: Optional[Dict[str, Any]] = None, fast_cli: bool = True, session_log: Optional[<a title="netmiko.session_log.SessionLog" href="../session_log.html#netmiko.session_log.SessionLog">SessionLog</a>] = None, session_log_record_writes: bool = False, session_log_file_mode: str = 'write', allow_auto_change: bool = False, encoding: str = 'utf-8', sock: Optional[socket.socket] = None, auto_connect: bool = True, delay_factor_compat: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Netmiko Cisco WLC support.</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if &lt;code&gt;host&lt;/code&gt; is
        provided.

    :param host: Hostname of target device. Not required if &lt;code&gt;ip&lt;/code&gt; is
            provided.

    :param username: Username to authenticate against target device if
            required.

    :param password: Password to authenticate against target device if
            required.

    :param secret: The enable password if target device requires one.

    :param port: The destination port used to connect to the target
            device.

    :param device_type: Class selection based on device type.

    :param verbose: Enable additional messages to standard output.

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).

    :param use_keys: Connect to target device using SSH keys.

    :param key_file: Filename path of the SSH key file to use.

    :param pkey: SSH key object to use.

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.

    :param disabled_algorithms: Dictionary of SSH algorithms to disable. Refer to the Paramiko
            documentation for a description of the expected format.

    :param allow_agent: Enable use of SSH key-agent.

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).

    :param system_host_keys: Load host keys from the users known_hosts file.

    :param alt_host_keys: If &lt;code&gt;True&lt;/code&gt; host keys will be loaded from the file specified in
            alt_key_file.

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).

    :param ssh_config_file: File name of OpenSSH configuration file.

    :param timeout: Connection timeout.

    :param session_timeout: Set a timeout for parallel requests.

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: True)

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)

    :param sock: An open socket or socket-like object (such as a &lt;code&gt;.Channel&lt;/code&gt;) to use for
            communication to the target host (default: None).

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function &lt;code&gt;cmd\_verify&lt;/code&gt;
            argument. Value of &lt;code&gt;None&lt;/code&gt; indicates to use function &lt;code&gt;cmd\_verify&lt;/code&gt; argument.

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).

    :param delay_factor_compat: Set send_command and send_command_timing back to using Netmiko
            3.x behavior for delay_factor/global_delay_factor/max_loops. This argument will be
            eliminated in Netmiko 5.x (default: False).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class CiscoWlcSSH(BaseConnection):
    &#34;&#34;&#34;Netmiko Cisco WLC support.&#34;&#34;&#34;

    prompt_pattern = r&#34;(?m:[&gt;#]\s*$)&#34;  # force re.Multiline

    def special_login_handler(self, delay_factor: float = 1.0) -&gt; None:
        &#34;&#34;&#34;WLC presents with the following on login (in certain OS versions)

        login as: user

        (Cisco Controller)

        User: user

        Password:****
        &#34;&#34;&#34;
        output = &#34;&#34;
        uname = &#34;User:&#34;
        login = &#34;login as&#34;
        password = &#34;ssword&#34;
        pattern = rf&#34;(?:{uname}|{login}|{password}|{self.prompt_pattern})&#34;

        while True:
            new_data = self.read_until_pattern(pattern=pattern, read_timeout=25.0)
            output += new_data
            if re.search(self.prompt_pattern, new_data):
                return

            if uname in new_data or login in new_data:
                assert isinstance(self.username, str)
                self.write_channel(self.username + self.RETURN)
            elif password in new_data:
                assert isinstance(self.password, str)
                self.write_channel(self.password + self.RETURN)
            else:
                msg = f&#34;&#34;&#34;
Failed to login to Cisco WLC Device.

Pattern not detected: {pattern}
output:

{output}

&#34;&#34;&#34;
                raise NetmikoAuthenticationException(msg)

    def session_preparation(self) -&gt; None:
        &#34;&#34;&#34;
        Prepare the session after the connection has been established

        Cisco WLC uses &#34;config paging disable&#34; to disable paging
        &#34;&#34;&#34;

        # _test_channel_read() will happen in the special_login_handler()
        try:
            self.set_base_prompt()
        except ValueError:
            msg = f&#34;Authentication failed: {self.host}&#34;
            raise NetmikoAuthenticationException(msg)

        self.disable_paging(command=&#34;config paging disable&#34;)

    def send_command_w_enter(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;
        For &#39;show run-config&#39; Cisco WLC adds a &#39;Press Enter to continue...&#39; message
        Even though pagination is disabled.

        show run-config also has excessive delays in the output which requires special
        handling.

        Arguments are the same as send_command_timing() method.
        &#34;&#34;&#34;
        if len(args) &gt; 1:
            raise ValueError(&#34;Must pass in delay_factor as keyword argument&#34;)

        # If no delay_factor use 1 for default value
        delay_factor = kwargs.get(&#34;delay_factor&#34;, 1)
        kwargs[&#34;delay_factor&#34;] = self.select_delay_factor(delay_factor)
        output = self._send_command_timing_str(*args, **kwargs)

        second_args = list(args)
        if len(args) == 1:
            second_args[0] = self.RETURN
        else:
            kwargs[&#34;command_string&#34;] = self.RETURN
        if not kwargs.get(&#34;max_loops&#34;):
            kwargs[&#34;max_loops&#34;] = 150

        if &#34;Press any key&#34; in output or &#34;Press Enter to&#34; in output:

            # Send an &#39;enter&#39;
            output += self._send_command_timing_str(*second_args, **kwargs)

            # WLC has excessive delay after this appears on screen
            if &#34;802.11b Advanced Configuration&#34; in output:

                # Defaults to 30 seconds
                time.sleep(kwargs[&#34;delay_factor&#34;] * 30)
                not_done = True
                i = 1
                while not_done and i &lt;= 150:
                    time.sleep(kwargs[&#34;delay_factor&#34;] * 3)
                    i += 1
                    new_data = &#34;&#34;
                    new_data = self.read_channel()
                    if new_data:
                        output += new_data
                    else:
                        not_done = False

        strip_prompt = kwargs.get(&#34;strip_prompt&#34;, True)
        if strip_prompt:
            # Had to strip trailing prompt twice.
            output = self.strip_prompt(output)
            output = self.strip_prompt(output)
        return output

    def _send_command_w_yes(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;
        For &#39;show interface summary&#39; Cisco WLC adds a
        &#39;Would you like to display the next 15 entries?&#39; message.

        Even though pagination is disabled
        Arguments are the same as send_command_timing() method.
        &#34;&#34;&#34;
        if len(args) &gt; 1:
            raise ValueError(&#34;Must pass in delay_factor as keyword argument&#34;)

        # If no delay_factor use 1 for default value
        delay_factor = kwargs.get(&#34;delay_factor&#34;, 1)
        kwargs[&#34;delay_factor&#34;] = self.select_delay_factor(delay_factor)

        output = &#34;&#34;
        new_output = self._send_command_timing_str(*args, **kwargs)

        second_args = list(args)
        if len(args) == 1:
            second_args[0] = &#34;y&#34;
        else:
            kwargs[&#34;command_string&#34;] = &#34;y&#34;
        strip_prompt = kwargs.get(&#34;strip_prompt&#34;, True)

        while True:
            output += new_output
            if &#34;display the next&#34; in new_output.lower():
                new_output = self._send_command_timing_str(*second_args, **kwargs)
            else:
                break

        # Remove from output &#39;Would you like to display the next 15 entries? (y/n)&#39;
        pattern = r&#34;^.*display the next.*\n$&#34;
        output = re.sub(pattern, &#34;&#34;, output, flags=re.M)

        if strip_prompt:
            # Had to strip trailing prompt twice.
            output = self.strip_prompt(output)
            output = self.strip_prompt(output)
        return output

    def cleanup(self, command: str = &#34;logout&#34;) -&gt; None:
        &#34;&#34;&#34;Reset WLC back to normal paging and gracefully close session.&#34;&#34;&#34;
        self.send_command_timing(&#34;config paging enable&#34;)

        # Exit configuration mode
        try:
            # The pattern=&#34;&#34; forces use of send_command_timing
            if self.check_config_mode(pattern=&#34;&#34;):
                self.exit_config_mode()
        except Exception:
            pass

        # End SSH/telnet session
        self.write_channel(command + self.RETURN)
        count = 0
        output = &#34;&#34;
        while count &lt;= 5:
            time.sleep(0.5)

            # The connection might be dead at this point.
            try:
                output += self.read_channel()
            except socket.error:
                break

            # Don&#39;t automatically save the config (user&#39;s responsibility)
            if &#34;Would you like to save them now&#34; in output:
                self._session_log_fin = True
                self.write_channel(&#34;n&#34; + self.RETURN)

            try:
                self.write_channel(self.RETURN)
            except socket.error:
                break
            count += 1

    def check_config_mode(
        self, check_string: str = &#34;config&#34;, pattern: str = &#34;&#34;, force_regex: bool = False
    ) -&gt; bool:
        &#34;&#34;&#34;Checks if the device is in configuration mode or not.&#34;&#34;&#34;
        if not pattern:
            pattern = re.escape(self.base_prompt)
        return super().check_config_mode(check_string, pattern)

    def config_mode(
        self, config_command: str = &#34;config&#34;, pattern: str = &#34;&#34;, re_flags: int = 0
    ) -&gt; str:
        &#34;&#34;&#34;Enter into config_mode.&#34;&#34;&#34;
        return super().config_mode(
            config_command=config_command, pattern=pattern, re_flags=re_flags
        )

    def exit_config_mode(self, exit_config: str = &#34;exit&#34;, pattern: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Exit config_mode.&#34;&#34;&#34;
        return super().exit_config_mode(exit_config, pattern)

    def send_config_set(
        self,
        config_commands: Union[str, Sequence[str], Iterator[str], TextIO, None] = None,
        exit_config_mode: bool = False,
        enter_config_mode: bool = False,
        **kwargs: Any,
    ) -&gt; str:
        return super().send_config_set(
            config_commands=config_commands,
            exit_config_mode=exit_config_mode,
            enter_config_mode=enter_config_mode,
            **kwargs,
        )

    def save_config(
        self,
        cmd: str = &#34;save config&#34;,
        confirm: bool = True,
        confirm_response: str = &#34;y&#34;,
    ) -&gt; str:
        &#34;&#34;&#34;Saves Config.&#34;&#34;&#34;
        self.enable()
        if confirm:
            output = self._send_command_timing_str(command_string=cmd)
            if confirm_response:
                output += self._send_command_timing_str(confirm_response)
            else:
                # Send enter by default
                output += self._send_command_timing_str(self.RETURN)
        else:
            # Some devices are slow so match on trailing-prompt if you can
            output = self._send_command_str(command_string=cmd)
        return output</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></li>
</ul>
<h3>Class variables</h3>
<dl>
<dt id="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.prompt_pattern"><code class="name">var <span class="ident">prompt_pattern</span></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.check_config_mode"><code class="name flex">
<span>def <span class="ident">check_config_mode</span></span>(<span>self, check_string: str = 'config', pattern: str = '', force_regex: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the device is in configuration mode or not.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_config_mode(
    self, check_string: str = &#34;config&#34;, pattern: str = &#34;&#34;, force_regex: bool = False
) -&gt; bool:
    &#34;&#34;&#34;Checks if the device is in configuration mode or not.&#34;&#34;&#34;
    if not pattern:
        pattern = re.escape(self.base_prompt)
    return super().check_config_mode(check_string, pattern)</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self, command: str = 'logout') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Reset WLC back to normal paging and gracefully close session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self, command: str = &#34;logout&#34;) -&gt; None:
    &#34;&#34;&#34;Reset WLC back to normal paging and gracefully close session.&#34;&#34;&#34;
    self.send_command_timing(&#34;config paging enable&#34;)

    # Exit configuration mode
    try:
        # The pattern=&#34;&#34; forces use of send_command_timing
        if self.check_config_mode(pattern=&#34;&#34;):
            self.exit_config_mode()
    except Exception:
        pass

    # End SSH/telnet session
    self.write_channel(command + self.RETURN)
    count = 0
    output = &#34;&#34;
    while count &lt;= 5:
        time.sleep(0.5)

        # The connection might be dead at this point.
        try:
            output += self.read_channel()
        except socket.error:
            break

        # Don&#39;t automatically save the config (user&#39;s responsibility)
        if &#34;Would you like to save them now&#34; in output:
            self._session_log_fin = True
            self.write_channel(&#34;n&#34; + self.RETURN)

        try:
            self.write_channel(self.RETURN)
        except socket.error:
            break
        count += 1</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.config_mode"><code class="name flex">
<span>def <span class="ident">config_mode</span></span>(<span>self, config_command: str = 'config', pattern: str = '', re_flags: int = 0) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Enter into config_mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_mode(
    self, config_command: str = &#34;config&#34;, pattern: str = &#34;&#34;, re_flags: int = 0
) -&gt; str:
    &#34;&#34;&#34;Enter into config_mode.&#34;&#34;&#34;
    return super().config_mode(
        config_command=config_command, pattern=pattern, re_flags=re_flags
    )</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.exit_config_mode"><code class="name flex">
<span>def <span class="ident">exit_config_mode</span></span>(<span>self, exit_config: str = 'exit', pattern: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Exit config_mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_config_mode(self, exit_config: str = &#34;exit&#34;, pattern: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Exit config_mode.&#34;&#34;&#34;
    return super().exit_config_mode(exit_config, pattern)</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.save_config"><code class="name flex">
<span>def <span class="ident">save_config</span></span>(<span>self, cmd: str = 'save config', confirm: bool = True, confirm_response: str = 'y') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Saves Config.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_config(
    self,
    cmd: str = &#34;save config&#34;,
    confirm: bool = True,
    confirm_response: str = &#34;y&#34;,
) -&gt; str:
    &#34;&#34;&#34;Saves Config.&#34;&#34;&#34;
    self.enable()
    if confirm:
        output = self._send_command_timing_str(command_string=cmd)
        if confirm_response:
            output += self._send_command_timing_str(confirm_response)
        else:
            # Send enter by default
            output += self._send_command_timing_str(self.RETURN)
    else:
        # Some devices are slow so match on trailing-prompt if you can
        output = self._send_command_str(command_string=cmd)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.send_command_w_enter"><code class="name flex">
<span>def <span class="ident">send_command_w_enter</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>For 'show run-config' Cisco WLC adds a 'Press Enter to continue&hellip;' message
Even though pagination is disabled.</p>
<p>show run-config also has excessive delays in the output which requires special
handling.</p>
<p>Arguments are the same as send_command_timing() method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command_w_enter(self, *args: Any, **kwargs: Any) -&gt; str:
    &#34;&#34;&#34;
    For &#39;show run-config&#39; Cisco WLC adds a &#39;Press Enter to continue...&#39; message
    Even though pagination is disabled.

    show run-config also has excessive delays in the output which requires special
    handling.

    Arguments are the same as send_command_timing() method.
    &#34;&#34;&#34;
    if len(args) &gt; 1:
        raise ValueError(&#34;Must pass in delay_factor as keyword argument&#34;)

    # If no delay_factor use 1 for default value
    delay_factor = kwargs.get(&#34;delay_factor&#34;, 1)
    kwargs[&#34;delay_factor&#34;] = self.select_delay_factor(delay_factor)
    output = self._send_command_timing_str(*args, **kwargs)

    second_args = list(args)
    if len(args) == 1:
        second_args[0] = self.RETURN
    else:
        kwargs[&#34;command_string&#34;] = self.RETURN
    if not kwargs.get(&#34;max_loops&#34;):
        kwargs[&#34;max_loops&#34;] = 150

    if &#34;Press any key&#34; in output or &#34;Press Enter to&#34; in output:

        # Send an &#39;enter&#39;
        output += self._send_command_timing_str(*second_args, **kwargs)

        # WLC has excessive delay after this appears on screen
        if &#34;802.11b Advanced Configuration&#34; in output:

            # Defaults to 30 seconds
            time.sleep(kwargs[&#34;delay_factor&#34;] * 30)
            not_done = True
            i = 1
            while not_done and i &lt;= 150:
                time.sleep(kwargs[&#34;delay_factor&#34;] * 3)
                i += 1
                new_data = &#34;&#34;
                new_data = self.read_channel()
                if new_data:
                    output += new_data
                else:
                    not_done = False

    strip_prompt = kwargs.get(&#34;strip_prompt&#34;, True)
    if strip_prompt:
        # Had to strip trailing prompt twice.
        output = self.strip_prompt(output)
        output = self.strip_prompt(output)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.session_preparation"><code class="name flex">
<span>def <span class="ident">session_preparation</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the session after the connection has been established</p>
<p>Cisco WLC uses "config paging disable" to disable paging</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def session_preparation(self) -&gt; None:
    &#34;&#34;&#34;
    Prepare the session after the connection has been established

    Cisco WLC uses &#34;config paging disable&#34; to disable paging
    &#34;&#34;&#34;

    # _test_channel_read() will happen in the special_login_handler()
    try:
        self.set_base_prompt()
    except ValueError:
        msg = f&#34;Authentication failed: {self.host}&#34;
        raise NetmikoAuthenticationException(msg)

    self.disable_paging(command=&#34;config paging disable&#34;)</code></pre>
</details>
</dd>
<dt id="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.special_login_handler"><code class="name flex">
<span>def <span class="ident">special_login_handler</span></span>(<span>self, delay_factor: float = 1.0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>WLC presents with the following on login (in certain OS versions)</p>
<p>login as: user</p>
<p>(Cisco Controller)</p>
<p>User: user</p>
<p>Password:****</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def special_login_handler(self, delay_factor: float = 1.0) -&gt; None:
        &#34;&#34;&#34;WLC presents with the following on login (in certain OS versions)

        login as: user

        (Cisco Controller)

        User: user

        Password:****
        &#34;&#34;&#34;
        output = &#34;&#34;
        uname = &#34;User:&#34;
        login = &#34;login as&#34;
        password = &#34;ssword&#34;
        pattern = rf&#34;(?:{uname}|{login}|{password}|{self.prompt_pattern})&#34;

        while True:
            new_data = self.read_until_pattern(pattern=pattern, read_timeout=25.0)
            output += new_data
            if re.search(self.prompt_pattern, new_data):
                return

            if uname in new_data or login in new_data:
                assert isinstance(self.username, str)
                self.write_channel(self.username + self.RETURN)
            elif password in new_data:
                assert isinstance(self.password, str)
                self.write_channel(self.password + self.RETURN)
            else:
                msg = f&#34;&#34;&#34;
Failed to login to Cisco WLC Device.

Pattern not detected: {pattern}
output:

{output}

&#34;&#34;&#34;
                raise NetmikoAuthenticationException(msg)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.base_connection.BaseConnection.check_enable_mode" href="../base_connection.html#netmiko.base_connection.BaseConnection.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.clear_buffer" href="../base_connection.html#netmiko.base_connection.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.commit" href="../base_connection.html#netmiko.base_connection.BaseConnection.commit">commit</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.disable_paging" href="../base_connection.html#netmiko.base_connection.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.disconnect" href="../base_connection.html#netmiko.base_connection.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.enable" href="../base_connection.html#netmiko.base_connection.BaseConnection.enable">enable</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.establish_connection" href="../base_connection.html#netmiko.base_connection.BaseConnection.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.exit_enable_mode" href="../base_connection.html#netmiko.base_connection.BaseConnection.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.find_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.is_alive" href="../base_connection.html#netmiko.base_connection.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.normalize_cmd" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.normalize_linefeeds" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.paramiko_cleanup" href="../base_connection.html#netmiko.base_connection.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_channel_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel_timing">read_channel_timing</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_until_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_until_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.run_ttp" href="../base_connection.html#netmiko.base_connection.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.select_delay_factor" href="../base_connection.html#netmiko.base_connection.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_command_expect" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_command_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_config_from_file" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_config_set" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_multiline" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_multiline">send_multiline</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.set_base_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.set_terminal_width" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.strip_ansi_escape_codes" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.strip_backspaces" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.strip_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.strip_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_prompt">strip_prompt</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.telnet_login" href="../base_connection.html#netmiko.base_connection.BaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.write_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="netmiko.cisco" href="index.html">netmiko.cisco</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH" href="#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH">CiscoWlcSSH</a></code></h4>
<ul class="">
<li><code><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.check_config_mode" href="#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.cleanup" href="#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.config_mode" href="#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.exit_config_mode" href="#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.prompt_pattern" href="#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.prompt_pattern">prompt_pattern</a></code></li>
<li><code><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.save_config" href="#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.save_config">save_config</a></code></li>
<li><code><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.send_command_w_enter" href="#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.send_command_w_enter">send_command_w_enter</a></code></li>
<li><code><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.session_preparation" href="#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.session_preparation">session_preparation</a></code></li>
<li><code><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.special_login_handler" href="#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH.special_login_handler">special_login_handler</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>