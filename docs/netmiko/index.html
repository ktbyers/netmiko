<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>netmiko API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Package <code>netmiko</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import sys

__version__ = &#34;4.1.2&#34;
PY_MAJ_VER = 3
PY_MIN_VER = 7
MIN_PYTHON_VER = &#34;3.7&#34;


# Make sure user is using a valid Python version (for Netmiko)
def check_python_version():  # type: ignore
    python_snake = &#34;\U0001F40D&#34;

    # Use old-school .format() method in case someone tries to use Netmiko with very old Python
    msg = &#34;&#34;&#34;

Netmiko Version {net_ver} requires Python Version {py_ver} or higher.

&#34;&#34;&#34;.format(
        net_ver=__version__, py_ver=MIN_PYTHON_VER
    )
    if sys.version_info.major != PY_MAJ_VER:
        raise ValueError(msg)
    elif sys.version_info.minor &lt; PY_MIN_VER:
        # Why not :-)
        msg = msg.rstrip() + &#34; {snake}\n\n&#34;.format(snake=python_snake)
        raise ValueError(msg)


check_python_version()  # type: ignore


import logging  # noqa


# Logging configuration
log = logging.getLogger(__name__)
log.addHandler(logging.NullHandler())


from netmiko.ssh_dispatcher import ConnectHandler  # noqa
from netmiko.ssh_dispatcher import ConnLogOnly  # noqa
from netmiko.ssh_dispatcher import ConnUnify  # noqa
from netmiko.ssh_dispatcher import ssh_dispatcher  # noqa
from netmiko.ssh_dispatcher import redispatch  # noqa
from netmiko.ssh_dispatcher import platforms  # noqa
from netmiko.ssh_dispatcher import FileTransfer  # noqa
from netmiko.scp_handler import SCPConn  # noqa
from netmiko.cisco.cisco_ios import InLineTransfer  # noqa
from netmiko.exceptions import (  # noqa
    NetmikoTimeoutException,
    NetMikoTimeoutException,
)
from netmiko.exceptions import (  # noqa
    NetmikoAuthenticationException,
    NetMikoAuthenticationException,
)
from netmiko.exceptions import ConfigInvalidException  # noqa
from netmiko.exceptions import ReadException, ReadTimeout  # noqa
from netmiko.exceptions import NetmikoBaseException, ConnectionException  # noqa
from netmiko.ssh_autodetect import SSHDetect  # noqa
from netmiko.base_connection import BaseConnection  # noqa
from netmiko.scp_functions import file_transfer, progress_bar  # noqa

# Alternate naming
Netmiko = ConnectHandler

__all__ = (
    &#34;ConnectHandler&#34;,
    &#34;ConnLogOnly&#34;,
    &#34;ConnUnify&#34;,
    &#34;ssh_dispatcher&#34;,
    &#34;platforms&#34;,
    &#34;SCPConn&#34;,
    &#34;FileTransfer&#34;,
    &#34;NetmikoBaseException&#34;,
    &#34;ConnectionException&#34;,
    &#34;NetmikoTimeoutException&#34;,
    &#34;NetMikoTimeoutException&#34;,
    &#34;ConfigInvalidException&#34;,
    &#34;ReadException&#34;,
    &#34;ReadTimeout&#34;,
    &#34;NetmikoAuthenticationException&#34;,
    &#34;NetMikoAuthenticationException&#34;,
    &#34;InLineTransfer&#34;,
    &#34;redispatch&#34;,
    &#34;SSHDetect&#34;,
    &#34;BaseConnection&#34;,
    &#34;Netmiko&#34;,
    &#34;file_transfer&#34;,
    &#34;progress_bar&#34;,
)

# Cisco cntl-shift-six sequence
CNTL_SHIFT_6 = chr(30)</code></pre>
</details>
</section>
<section>
<h2 class="section-title" id="header-submodules">Sub-modules</h2>
<dl>
<dt><code class="name"><a title="netmiko.a10" href="a10/index.html">netmiko.a10</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.accedian" href="accedian/index.html">netmiko.accedian</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.adtran" href="adtran/index.html">netmiko.adtran</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.alcatel" href="alcatel/index.html">netmiko.alcatel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.allied_telesis" href="allied_telesis/index.html">netmiko.allied_telesis</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.apresia" href="apresia/index.html">netmiko.apresia</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.arista" href="arista/index.html">netmiko.arista</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.aruba" href="aruba/index.html">netmiko.aruba</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.audiocode" href="audiocode/index.html">netmiko.audiocode</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.base_connection" href="base_connection.html">netmiko.base_connection</a></code></dt>
<dd>
<div class="desc"><p>Base connection class for netmiko …</p></div>
</dd>
<dt><code class="name"><a title="netmiko.broadcom" href="broadcom/index.html">netmiko.broadcom</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.brocade" href="brocade/index.html">netmiko.brocade</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.calix" href="calix/index.html">netmiko.calix</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.cdot" href="cdot/index.html">netmiko.cdot</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.centec" href="centec/index.html">netmiko.centec</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.channel" href="channel.html">netmiko.channel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.checkpoint" href="checkpoint/index.html">netmiko.checkpoint</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.ciena" href="ciena/index.html">netmiko.ciena</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.cisco" href="cisco/index.html">netmiko.cisco</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.cisco_base_connection" href="cisco_base_connection.html">netmiko.cisco_base_connection</a></code></dt>
<dd>
<div class="desc"><p>CiscoBaseConnection is netmiko SSH class for Cisco and Cisco-like platforms.</p></div>
</dd>
<dt><code class="name"><a title="netmiko.citrix" href="citrix/index.html">netmiko.citrix</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.cli_tools" href="cli_tools/index.html">netmiko.cli_tools</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.cloudgenix" href="cloudgenix/index.html">netmiko.cloudgenix</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.coriant" href="coriant/index.html">netmiko.coriant</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.dell" href="dell/index.html">netmiko.dell</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.dlink" href="dlink/index.html">netmiko.dlink</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.eltex" href="eltex/index.html">netmiko.eltex</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.endace" href="endace/index.html">netmiko.endace</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.enterasys" href="enterasys/index.html">netmiko.enterasys</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.ericsson" href="ericsson/index.html">netmiko.ericsson</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.exceptions" href="exceptions.html">netmiko.exceptions</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.extreme" href="extreme/index.html">netmiko.extreme</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.f5" href="f5/index.html">netmiko.f5</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.flexvnf" href="flexvnf/index.html">netmiko.flexvnf</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.fortinet" href="fortinet/index.html">netmiko.fortinet</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.hp" href="hp/index.html">netmiko.hp</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.huawei" href="huawei/index.html">netmiko.huawei</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.ipinfusion" href="ipinfusion/index.html">netmiko.ipinfusion</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.juniper" href="juniper/index.html">netmiko.juniper</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.keymile" href="keymile/index.html">netmiko.keymile</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.linux" href="linux/index.html">netmiko.linux</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.mellanox" href="mellanox/index.html">netmiko.mellanox</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.mikrotik" href="mikrotik/index.html">netmiko.mikrotik</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.mrv" href="mrv/index.html">netmiko.mrv</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.netapp" href="netapp/index.html">netmiko.netapp</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.netgear" href="netgear/index.html">netmiko.netgear</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.netmiko_globals" href="netmiko_globals.html">netmiko.netmiko_globals</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.no_config" href="no_config.html">netmiko.no_config</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.no_enable" href="no_enable.html">netmiko.no_enable</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.nokia" href="nokia/index.html">netmiko.nokia</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.oneaccess" href="oneaccess/index.html">netmiko.oneaccess</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.ovs" href="ovs/index.html">netmiko.ovs</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.paloalto" href="paloalto/index.html">netmiko.paloalto</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.pluribus" href="pluribus/index.html">netmiko.pluribus</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.quanta" href="quanta/index.html">netmiko.quanta</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.rad" href="rad/index.html">netmiko.rad</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.raisecom" href="raisecom/index.html">netmiko.raisecom</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.ruckus" href="ruckus/index.html">netmiko.ruckus</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.ruijie" href="ruijie/index.html">netmiko.ruijie</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.scp_functions" href="scp_functions.html">netmiko.scp_functions</a></code></dt>
<dd>
<div class="desc"><p>Netmiko SCP operations …</p></div>
</dd>
<dt><code class="name"><a title="netmiko.scp_handler" href="scp_handler.html">netmiko.scp_handler</a></code></dt>
<dd>
<div class="desc"><p>Netmiko SCP operations …</p></div>
</dd>
<dt><code class="name"><a title="netmiko.session_log" href="session_log.html">netmiko.session_log</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.sixwind" href="sixwind/index.html">netmiko.sixwind</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.snmp_autodetect" href="snmp_autodetect.html">netmiko.snmp_autodetect</a></code></dt>
<dd>
<div class="desc"><p>This module is used to auto-detect the type of a device in order to automatically create a
Netmiko connection …</p></div>
</dd>
<dt><code class="name"><a title="netmiko.sophos" href="sophos/index.html">netmiko.sophos</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.ssh_auth" href="ssh_auth.html">netmiko.ssh_auth</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.ssh_autodetect" href="ssh_autodetect.html">netmiko.ssh_autodetect</a></code></dt>
<dd>
<div class="desc"><p>The ssh_autodetect module is used to auto-detect the netmiko device_type to use to further initiate
a new SSH connection with a remote host. This …</p></div>
</dd>
<dt><code class="name"><a title="netmiko.supermicro" href="supermicro/index.html">netmiko.supermicro</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.terminal_server" href="terminal_server/index.html">netmiko.terminal_server</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.tplink" href="tplink/index.html">netmiko.tplink</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.ubiquiti" href="ubiquiti/index.html">netmiko.ubiquiti</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.utilities" href="utilities.html">netmiko.utilities</a></code></dt>
<dd>
<div class="desc"><p>Miscellaneous utility functions.</p></div>
</dd>
<dt><code class="name"><a title="netmiko.vyos" href="vyos/index.html">netmiko.vyos</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.watchguard" href="watchguard/index.html">netmiko.watchguard</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.yamaha" href="yamaha/index.html">netmiko.yamaha</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.zte" href="zte/index.html">netmiko.zte</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
<dt><code class="name"><a title="netmiko.zyxel" href="zyxel/index.html">netmiko.zyxel</a></code></dt>
<dd>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="netmiko.ConnLogOnly"><code class="name flex">
<span>def <span class="ident">ConnLogOnly</span></span>(<span>log_file: str = 'netmiko.log', log_level: Optional[int] = None, log_format: Optional[str] = None, **kwargs: Any) ‑> Optional[<a title="netmiko.BaseConnection" href="#netmiko.BaseConnection">BaseConnection</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Dispatcher function that will return either: netmiko_object or None</p>
<p>Excluding errors in logging configuration should never generate an exception
all errors should be logged.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConnLogOnly(
    log_file: str = &#34;netmiko.log&#34;,
    log_level: Optional[int] = None,
    log_format: Optional[str] = None,
    **kwargs: Any,
) -&gt; Optional[&#34;BaseConnection&#34;]:
    &#34;&#34;&#34;
    Dispatcher function that will return either: netmiko_object or None

    Excluding errors in logging configuration should never generate an exception
    all errors should be logged.
    &#34;&#34;&#34;

    import logging

    if log_level is None:
        log_level = logging.ERROR
    if log_format is None:
        log_format = &#34;%(asctime)s %(levelname)s %(name)s %(message)s&#34;

    logging.basicConfig(filename=log_file, level=log_level, format=log_format)
    logger = logging.getLogger(__name__)

    try:
        kwargs[&#34;auto_connect&#34;] = False
        net_connect = ConnectHandler(**kwargs)
        hostname = net_connect.host
        port = net_connect.port
        device_type = net_connect.device_type

        net_connect._open()
        msg = f&#34;Netmiko connection succesful to {hostname}:{port}&#34;
        logger.info(msg)
        return net_connect
    except NetmikoAuthenticationException as e:
        msg = (
            f&#34;Authentication failure to: {hostname}:{port} ({device_type})\n\n{str(e)}&#34;
        )
        logger.error(msg)
        return None
    except NetmikoTimeoutException as e:
        if &#34;DNS failure&#34; in str(e):
            msg = f&#34;Device failed due to a DNS failure, hostname {hostname}&#34;
        elif &#34;TCP connection to device failed&#34; in str(e):
            msg = f&#34;Netmiko was unable to reach the provided host and port: {hostname}:{port}&#34;
            msg += f&#34;\n\n{str(e)}&#34;
        logger.error(msg)
        return None
    except Exception as e:
        msg = f&#34;An unknown exception occurred during connection:\n\n{str(e)}&#34;
        logger.error(msg)
        return None</code></pre>
</details>
</dd>
<dt id="netmiko.ConnUnify"><code class="name flex">
<span>def <span class="ident">ConnUnify</span></span>(<span>**kwargs: Any) ‑> <a title="netmiko.BaseConnection" href="#netmiko.BaseConnection">BaseConnection</a></span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConnUnify(
    **kwargs: Any,
) -&gt; &#34;BaseConnection&#34;:

    try:
        kwargs[&#34;auto_connect&#34;] = False
        net_connect = ConnectHandler(**kwargs)
        hostname = net_connect.host
        port = net_connect.port
        device_type = net_connect.device_type
        general_msg = f&#34;Connection failure to {hostname}:{port} ({device_type})\n\n&#34;

        net_connect._open()
        return net_connect
    except NetmikoAuthenticationException as e:
        msg = general_msg + str(e)
        raise ConnectionException(msg)
    except NetmikoTimeoutException as e:
        msg = general_msg + str(e)
        raise ConnectionException(msg)
    except Exception as e:
        msg = f&#34;An unknown exception occurred during connection:\n\n{str(e)}&#34;
        raise ConnectionException(msg)</code></pre>
</details>
</dd>
<dt id="netmiko.ConnectHandler"><code class="name flex">
<span>def <span class="ident">ConnectHandler</span></span>(<span>*args: Any, **kwargs: Any) ‑> <a title="netmiko.BaseConnection" href="#netmiko.BaseConnection">BaseConnection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Factory function selects the proper class and creates object based on device_type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConnectHandler(*args: Any, **kwargs: Any) -&gt; &#34;BaseConnection&#34;:
    &#34;&#34;&#34;Factory function selects the proper class and creates object based on device_type.&#34;&#34;&#34;
    device_type = kwargs[&#34;device_type&#34;]
    if device_type not in platforms:
        if device_type is None:
            msg_str = platforms_str
        else:
            msg_str = telnet_platforms_str if &#34;telnet&#34; in device_type else platforms_str
        raise ValueError(
            &#34;Unsupported &#39;device_type&#39; &#34;
            &#34;currently supported platforms are: {}&#34;.format(msg_str)
        )
    ConnectionClass = ssh_dispatcher(device_type)
    return ConnectionClass(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="netmiko.FileTransfer"><code class="name flex">
<span>def <span class="ident">FileTransfer</span></span>(<span>*args: Any, **kwargs: Any) ‑> BaseFileTransfer</span>
</code></dt>
<dd>
<div class="desc"><p>Factory function selects the proper SCP class and creates object based on device_type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def FileTransfer(*args: Any, **kwargs: Any) -&gt; &#34;BaseFileTransfer&#34;:
    &#34;&#34;&#34;Factory function selects the proper SCP class and creates object based on device_type.&#34;&#34;&#34;
    if len(args) &gt;= 1:
        device_type = args[0].device_type
    else:
        device_type = kwargs[&#34;ssh_conn&#34;].device_type
    if device_type not in scp_platforms:
        raise ValueError(
            &#34;Unsupported SCP device_type: &#34;
            &#34;currently supported platforms are: {}&#34;.format(scp_platforms_str)
        )
    FileTransferClass: Type[&#34;BaseFileTransfer&#34;]
    FileTransferClass = FILE_TRANSFER_MAP[device_type]
    return FileTransferClass(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="netmiko.Netmiko"><code class="name flex">
<span>def <span class="ident">Netmiko</span></span>(<span>*args: Any, **kwargs: Any) ‑> <a title="netmiko.BaseConnection" href="#netmiko.BaseConnection">BaseConnection</a></span>
</code></dt>
<dd>
<div class="desc"><p>Factory function selects the proper class and creates object based on device_type.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ConnectHandler(*args: Any, **kwargs: Any) -&gt; &#34;BaseConnection&#34;:
    &#34;&#34;&#34;Factory function selects the proper class and creates object based on device_type.&#34;&#34;&#34;
    device_type = kwargs[&#34;device_type&#34;]
    if device_type not in platforms:
        if device_type is None:
            msg_str = platforms_str
        else:
            msg_str = telnet_platforms_str if &#34;telnet&#34; in device_type else platforms_str
        raise ValueError(
            &#34;Unsupported &#39;device_type&#39; &#34;
            &#34;currently supported platforms are: {}&#34;.format(msg_str)
        )
    ConnectionClass = ssh_dispatcher(device_type)
    return ConnectionClass(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="netmiko.file_transfer"><code class="name flex">
<span>def <span class="ident">file_transfer</span></span>(<span>ssh_conn: <a title="netmiko.BaseConnection" href="#netmiko.BaseConnection">BaseConnection</a>, source_file: str, dest_file: str, file_system: Optional[str] = None, direction: str = 'put', disable_md5: bool = False, inline_transfer: bool = False, overwrite_file: bool = False, socket_timeout: float = 10.0, progress: Optional[Callable[..., Any]] = None, progress4: Optional[Callable[..., Any]] = None, verify_file: Optional[bool] = None) ‑> Dict[str, bool]</span>
</code></dt>
<dd>
<div class="desc"><p>Use Secure Copy or Inline (IOS-only) to transfer files to/from network devices.</p>
<p>inline_transfer ONLY SUPPORTS TEXT FILES and will not support binary file transfers.</p>
<p>return {
'file_exists': boolean,
'file_transferred': boolean,
'file_verified': boolean,
}</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_transfer(
    ssh_conn: &#34;BaseConnection&#34;,
    source_file: str,
    dest_file: str,
    file_system: Optional[str] = None,
    direction: str = &#34;put&#34;,
    disable_md5: bool = False,
    inline_transfer: bool = False,
    overwrite_file: bool = False,
    socket_timeout: float = 10.0,
    progress: Optional[Callable[..., Any]] = None,
    progress4: Optional[Callable[..., Any]] = None,
    verify_file: Optional[bool] = None,
) -&gt; Dict[str, bool]:
    &#34;&#34;&#34;Use Secure Copy or Inline (IOS-only) to transfer files to/from network devices.

    inline_transfer ONLY SUPPORTS TEXT FILES and will not support binary file transfers.

    return {
        &#39;file_exists&#39;: boolean,
        &#39;file_transferred&#39;: boolean,
        &#39;file_verified&#39;: boolean,
    }
    &#34;&#34;&#34;
    transferred_and_verified = {
        &#34;file_exists&#34;: True,
        &#34;file_transferred&#34;: True,
        &#34;file_verified&#34;: True,
    }
    transferred_and_notverified = {
        &#34;file_exists&#34;: True,
        &#34;file_transferred&#34;: True,
        &#34;file_verified&#34;: False,
    }
    nottransferred_but_verified = {
        &#34;file_exists&#34;: True,
        &#34;file_transferred&#34;: False,
        &#34;file_verified&#34;: True,
    }

    if &#34;cisco_ios&#34; in ssh_conn.device_type or &#34;cisco_xe&#34; in ssh_conn.device_type:
        cisco_ios = True
    else:
        cisco_ios = False
    if not cisco_ios and inline_transfer:
        raise ValueError(&#34;Inline Transfer only supported for Cisco IOS/Cisco IOS-XE&#34;)

    # Replace disable_md5 argument with verify_file argument across time
    if verify_file is None:
        verify_file = not disable_md5

    scp_args = {
        &#34;ssh_conn&#34;: ssh_conn,
        &#34;source_file&#34;: source_file,
        &#34;dest_file&#34;: dest_file,
        &#34;direction&#34;: direction,
        &#34;socket_timeout&#34;: socket_timeout,
        &#34;progress&#34;: progress,
        &#34;progress4&#34;: progress4,
    }
    if file_system is not None:
        scp_args[&#34;file_system&#34;] = file_system

    TransferClass: Callable[..., BaseFileTransfer]
    if inline_transfer:
        TransferClass = InLineTransfer
    else:
        TransferClass = FileTransfer

    with TransferClass(**scp_args) as scp_transfer:
        if scp_transfer.check_file_exists():
            if overwrite_file:
                if verify_file:
                    if scp_transfer.verify_file():
                        return nottransferred_but_verified
                    else:
                        # File exists, you can overwrite it, MD5 is wrong (transfer file)
                        verifyspace_and_transferfile(scp_transfer)
                        if scp_transfer.verify_file():
                            return transferred_and_verified
                        else:
                            raise ValueError(
                                &#34;MD5 failure between source and destination files&#34;
                            )
                else:
                    # File exists, you can overwrite it, but MD5 not allowed (transfer file)
                    verifyspace_and_transferfile(scp_transfer)
                    return transferred_and_notverified
            else:
                # File exists, but you can&#39;t overwrite it.
                if verify_file:
                    if scp_transfer.verify_file():
                        return nottransferred_but_verified
                msg = &#34;File already exists and overwrite_file is disabled&#34;
                raise ValueError(msg)
        else:
            verifyspace_and_transferfile(scp_transfer)
            # File doesn&#39;t exist
            if verify_file:
                if scp_transfer.verify_file():
                    return transferred_and_verified
                else:
                    raise ValueError(&#34;MD5 failure between source and destination files&#34;)
            else:
                return transferred_and_notverified</code></pre>
</details>
</dd>
<dt id="netmiko.progress_bar"><code class="name flex">
<span>def <span class="ident">progress_bar</span></span>(<span>filename: ~AnyStr, size: int, sent: int, peername: Optional[str] = None) ‑> None</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def progress_bar(
    filename: AnyStr, size: int, sent: int, peername: Optional[str] = None
) -&gt; None:
    max_width = 50
    if isinstance(filename, bytes):
        filename_str = filename.decode()
    else:
        filename_str = filename
    clear_screen = chr(27) + &#34;[2J&#34;
    terminating_char = &#34;|&#34;

    # Percentage done
    percent_complete = sent / size
    percent_str = f&#34;{percent_complete*100:.2f}%&#34;
    hash_count = int(percent_complete * max_width)
    progress = hash_count * &#34;&gt;&#34;

    if peername is None:
        header_msg = f&#34;Transferring file: {filename_str}\n&#34;
    else:
        header_msg = f&#34;Transferring file to {peername}: {filename_str}\n&#34;

    msg = f&#34;{progress:&lt;50}{terminating_char:1} ({percent_str})&#34;
    print(clear_screen)
    print(header_msg)
    print(msg)</code></pre>
</details>
</dd>
<dt id="netmiko.redispatch"><code class="name flex">
<span>def <span class="ident">redispatch</span></span>(<span>obj: <a title="netmiko.BaseConnection" href="#netmiko.BaseConnection">BaseConnection</a>, device_type: str, session_prep: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Dynamically change Netmiko object's class to proper class.
Generally used with terminal_server device_type when you need to redispatch after interacting
with terminal server.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def redispatch(
    obj: &#34;BaseConnection&#34;, device_type: str, session_prep: bool = True
) -&gt; None:
    &#34;&#34;&#34;Dynamically change Netmiko object&#39;s class to proper class.
    Generally used with terminal_server device_type when you need to redispatch after interacting
    with terminal server.
    &#34;&#34;&#34;
    new_class = ssh_dispatcher(device_type)
    obj.device_type = device_type
    obj.__class__ = new_class
    if session_prep:
        obj._try_session_preparation()</code></pre>
</details>
</dd>
<dt id="netmiko.ssh_dispatcher"><code class="name flex">
<span>def <span class="ident">ssh_dispatcher</span></span>(<span>device_type: str) ‑> Type[<a title="netmiko.BaseConnection" href="#netmiko.BaseConnection">BaseConnection</a>]</span>
</code></dt>
<dd>
<div class="desc"><p>Select the class to be instantiated based on vendor/platform.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def ssh_dispatcher(device_type: str) -&gt; Type[&#34;BaseConnection&#34;]:
    &#34;&#34;&#34;Select the class to be instantiated based on vendor/platform.&#34;&#34;&#34;
    return CLASS_MAPPER[device_type]</code></pre>
</details>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="netmiko.BaseConnection"><code class="flex name class">
<span>class <span class="ident">BaseConnection</span></span>
<span>(</span><span>ip: str = '', host: str = '', username: str = '', password: Optional[str] = None, secret: str = '', port: Optional[int] = None, device_type: str = '', verbose: bool = False, global_delay_factor: float = 1.0, global_cmd_verify: Optional[bool] = None, use_keys: bool = False, key_file: Optional[str] = None, pkey: Optional[paramiko.pkey.PKey] = None, passphrase: Optional[str] = None, disabled_algorithms: Optional[Dict[str, Any]] = None, allow_agent: bool = False, ssh_strict: bool = False, system_host_keys: bool = False, alt_host_keys: bool = False, alt_key_file: str = '', ssh_config_file: Optional[str] = None, conn_timeout: int = 10, auth_timeout: Optional[int] = None, banner_timeout: int = 15, blocking_timeout: int = 20, timeout: int = 100, session_timeout: int = 60, read_timeout_override: Optional[float] = None, keepalive: int = 0, default_enter: Optional[str] = None, response_return: Optional[str] = None, serial_settings: Optional[Dict[str, Any]] = None, fast_cli: bool = True, session_log: Optional[<a title="netmiko.session_log.SessionLog" href="session_log.html#netmiko.session_log.SessionLog">SessionLog</a>] = None, session_log_record_writes: bool = False, session_log_file_mode: str = 'write', allow_auto_change: bool = False, encoding: str = 'utf-8', sock: Optional[socket.socket] = None, auto_connect: bool = True, delay_factor_compat: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Defines vendor independent methods.</p>
<p>Otherwise method left as a stub method.</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if &lt;code&gt;host&lt;/code&gt; is
        provided.

    :param host: Hostname of target device. Not required if &lt;code&gt;ip&lt;/code&gt; is
            provided.

    :param username: Username to authenticate against target device if
            required.

    :param password: Password to authenticate against target device if
            required.

    :param secret: The enable password if target device requires one.

    :param port: The destination port used to connect to the target
            device.

    :param device_type: Class selection based on device type.

    :param verbose: Enable additional messages to standard output.

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).

    :param use_keys: Connect to target device using SSH keys.

    :param key_file: Filename path of the SSH key file to use.

    :param pkey: SSH key object to use.

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.

    :param disabled_algorithms: Dictionary of SSH algorithms to disable. Refer to the Paramiko
            documentation for a description of the expected format.

    :param allow_agent: Enable use of SSH key-agent.

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).

    :param system_host_keys: Load host keys from the users known_hosts file.

    :param alt_host_keys: If &lt;code&gt;True&lt;/code&gt; host keys will be loaded from the file specified in
            alt_key_file.

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).

    :param ssh_config_file: File name of OpenSSH configuration file.

    :param timeout: Connection timeout.

    :param session_timeout: Set a timeout for parallel requests.

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: True)

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)

    :param sock: An open socket or socket-like object (such as a &lt;code&gt;.Channel&lt;/code&gt;) to use for
            communication to the target host (default: None).

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function &lt;code&gt;cmd\_verify&lt;/code&gt;
            argument. Value of &lt;code&gt;None&lt;/code&gt; indicates to use function &lt;code&gt;cmd\_verify&lt;/code&gt; argument.

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).

    :param delay_factor_compat: Set send_command and send_command_timing back to using Netmiko
            3.x behavior for delay_factor/global_delay_factor/max_loops. This argument will be
            eliminated in Netmiko 5.x (default: False).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class BaseConnection:
    &#34;&#34;&#34;
    Defines vendor independent methods.

    Otherwise method left as a stub method.
    &#34;&#34;&#34;

    def __init__(
        self,
        ip: str = &#34;&#34;,
        host: str = &#34;&#34;,
        username: str = &#34;&#34;,
        password: Optional[str] = None,
        secret: str = &#34;&#34;,
        port: Optional[int] = None,
        device_type: str = &#34;&#34;,
        verbose: bool = False,
        global_delay_factor: float = 1.0,
        global_cmd_verify: Optional[bool] = None,
        use_keys: bool = False,
        key_file: Optional[str] = None,
        pkey: Optional[paramiko.PKey] = None,
        passphrase: Optional[str] = None,
        disabled_algorithms: Optional[Dict[str, Any]] = None,
        allow_agent: bool = False,
        ssh_strict: bool = False,
        system_host_keys: bool = False,
        alt_host_keys: bool = False,
        alt_key_file: str = &#34;&#34;,
        ssh_config_file: Optional[str] = None,
        #
        # Connect timeouts
        # ssh-connect --&gt; TCP conn (conn_timeout) --&gt; SSH-banner (banner_timeout)
        #       --&gt; Auth response (auth_timeout)
        conn_timeout: int = 10,
        # Timeout to wait for authentication response
        auth_timeout: Optional[int] = None,
        banner_timeout: int = 15,  # Timeout to wait for the banner to be presented
        # Other timeouts
        blocking_timeout: int = 20,  # Read blocking timeout
        timeout: int = 100,  # TCP connect timeout | overloaded to read-loop timeout
        session_timeout: int = 60,  # Used for locking/sharing the connection
        read_timeout_override: Optional[float] = None,
        keepalive: int = 0,
        default_enter: Optional[str] = None,
        response_return: Optional[str] = None,
        serial_settings: Optional[Dict[str, Any]] = None,
        fast_cli: bool = True,
        _legacy_mode: bool = False,
        session_log: Optional[SessionLog] = None,
        session_log_record_writes: bool = False,
        session_log_file_mode: str = &#34;write&#34;,
        allow_auto_change: bool = False,
        encoding: str = &#34;utf-8&#34;,
        sock: Optional[socket.socket] = None,
        auto_connect: bool = True,
        delay_factor_compat: bool = False,
    ) -&gt; None:
        &#34;&#34;&#34;
        Initialize attributes for establishing connection to target device.

        :param ip: IP address of target device. Not required if `host` is
            provided.

        :param host: Hostname of target device. Not required if `ip` is
                provided.

        :param username: Username to authenticate against target device if
                required.

        :param password: Password to authenticate against target device if
                required.

        :param secret: The enable password if target device requires one.

        :param port: The destination port used to connect to the target
                device.

        :param device_type: Class selection based on device type.

        :param verbose: Enable additional messages to standard output.

        :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).

        :param use_keys: Connect to target device using SSH keys.

        :param key_file: Filename path of the SSH key file to use.

        :param pkey: SSH key object to use.

        :param passphrase: Passphrase to use for encrypted key; password will be used for key
                decryption if not specified.

        :param disabled_algorithms: Dictionary of SSH algorithms to disable. Refer to the Paramiko
                documentation for a description of the expected format.

        :param allow_agent: Enable use of SSH key-agent.

        :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
                means unknown SSH host keys will be accepted).

        :param system_host_keys: Load host keys from the users known_hosts file.

        :param alt_host_keys: If `True` host keys will be loaded from the file specified in
                alt_key_file.

        :param alt_key_file: SSH host key file to use (if alt_host_keys=True).

        :param ssh_config_file: File name of OpenSSH configuration file.

        :param timeout: Connection timeout.

        :param session_timeout: Set a timeout for parallel requests.

        :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.

        :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).

        :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
                Currently defaults to 0, for backwards compatibility (it will not attempt
                to keep the connection alive).

        :param default_enter: Character(s) to send to correspond to enter key (default: \n).

        :param response_return: Character(s) to use in normalized return data to represent
                enter key (default: \n)

        :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
                to select smallest of global and specific. Sets default global_delay_factor to .1
                (default: True)

        :param session_log: File path or BufferedIOBase subclass object to write the session log to.

        :param session_log_record_writes: The session log generally only records channel reads due
                to eliminate command duplication due to command echo. You can enable this if you
                want to record both channel reads and channel writes in the log (default: False).

        :param session_log_file_mode: &#34;write&#34; or &#34;append&#34; for session_log file mode
                (default: &#34;write&#34;)

        :param allow_auto_change: Allow automatic configuration changes for terminal settings.
                (default: False)

        :param encoding: Encoding to be used when writing bytes to the output channel.
                (default: ascii)

        :param sock: An open socket or socket-like object (such as a `.Channel`) to use for
                communication to the target host (default: None).

        :param global_cmd_verify: Control whether command echo verification is enabled or disabled
                (default: None). Global attribute takes precedence over function `cmd_verify`
                argument. Value of `None` indicates to use function `cmd_verify` argument.

        :param auto_connect: Control whether Netmiko automatically establishes the connection as
                part of the object creation (default: True).

        :param delay_factor_compat: Set send_command and send_command_timing back to using Netmiko
                3.x behavior for delay_factor/global_delay_factor/max_loops. This argument will be
                eliminated in Netmiko 5.x (default: False).
        &#34;&#34;&#34;

        self.remote_conn: Union[
            None, telnetlib.Telnet, paramiko.Channel, serial.Serial
        ] = None
        # Does the platform support a configuration mode
        self._config_mode = True
        self._read_buffer = &#34;&#34;
        self.delay_factor_compat = delay_factor_compat

        self.TELNET_RETURN = &#34;\r\n&#34;
        if default_enter is None:
            if &#34;telnet&#34; not in device_type:
                self.RETURN = &#34;\n&#34;
            else:
                self.RETURN = self.TELNET_RETURN
        else:
            self.RETURN = default_enter

        # Line Separator in response lines
        self.RESPONSE_RETURN = &#34;\n&#34; if response_return is None else response_return
        if ip:
            self.host = ip.strip()
        elif host:
            self.host = host.strip()
        if not ip and not host and &#34;serial&#34; not in device_type:
            raise ValueError(&#34;Either ip or host must be set&#34;)
        if port is None:
            if &#34;telnet&#34; in device_type:
                port = 23
            else:
                port = 22
        self.port = int(port)

        self.username = username
        self.password = password
        self.secret = secret
        self.device_type = device_type
        self.ansi_escape_codes = False
        self.verbose = verbose
        self.auth_timeout = auth_timeout
        self.banner_timeout = banner_timeout
        self.blocking_timeout = blocking_timeout
        self.conn_timeout = conn_timeout
        self.session_timeout = session_timeout
        self.timeout = timeout
        self.read_timeout_override = read_timeout_override
        self.keepalive = keepalive
        self.allow_auto_change = allow_auto_change
        self.encoding = encoding
        self.sock = sock
        self.fast_cli = fast_cli
        self._legacy_mode = _legacy_mode
        self.global_delay_factor = global_delay_factor
        self.global_cmd_verify = global_cmd_verify
        if self.fast_cli and self.global_delay_factor == 1:
            self.global_delay_factor = 0.1
        self.session_log = None
        self._session_log_close = False

        # prevent logging secret data
        no_log = {}
        if self.password:
            no_log[&#34;password&#34;] = self.password
        if self.secret:
            no_log[&#34;secret&#34;] = self.secret
        log.addFilter(SecretsFilter(no_log=no_log))

        # Netmiko will close the session_log if we open the file
        if session_log is not None:
            if isinstance(session_log, str):
                # If session_log is a string, open a file corresponding to string name.
                self.session_log = SessionLog(
                    file_name=session_log,
                    file_mode=session_log_file_mode,
                    no_log=no_log,
                    record_writes=session_log_record_writes,
                )
                self.session_log.open()
            elif isinstance(session_log, io.BufferedIOBase):
                # In-memory buffer or an already open file handle
                self.session_log = SessionLog(
                    buffered_io=session_log,
                    no_log=no_log,
                    record_writes=session_log_record_writes,
                )
            else:
                raise ValueError(
                    &#34;session_log must be a path to a file, a file handle, &#34;
                    &#34;or a BufferedIOBase subclass.&#34;
                )

        # Default values
        self.serial_settings = {
            &#34;port&#34;: &#34;COM1&#34;,
            &#34;baudrate&#34;: 9600,
            &#34;bytesize&#34;: serial.EIGHTBITS,
            &#34;parity&#34;: serial.PARITY_NONE,
            &#34;stopbits&#34;: serial.STOPBITS_ONE,
        }
        if serial_settings is None:
            serial_settings = {}
        self.serial_settings.update(serial_settings)

        if &#34;serial&#34; in device_type:
            self.host = &#34;serial&#34;
            comm_port = self.serial_settings.pop(&#34;port&#34;)
            # Get the proper comm port reference if a name was enterred
            comm_port = check_serial_port(comm_port)
            self.serial_settings.update({&#34;port&#34;: comm_port})

        # set in set_base_prompt method
        self.base_prompt = &#34;&#34;
        self._session_locker = Lock()

        # determine if telnet or SSH
        if &#34;_telnet&#34; in device_type:
            self.protocol = &#34;telnet&#34;
            self.password = password or &#34;&#34;
        elif &#34;_serial&#34; in device_type:
            self.protocol = &#34;serial&#34;
            self.password = password or &#34;&#34;
        else:
            self.protocol = &#34;ssh&#34;

            self.key_policy: paramiko.client.MissingHostKeyPolicy
            if not ssh_strict:
                self.key_policy = paramiko.AutoAddPolicy()
            else:
                self.key_policy = paramiko.RejectPolicy()

            # Options for SSH host_keys
            self.use_keys = use_keys
            self.key_file = (
                path.abspath(path.expanduser(key_file)) if key_file else None
            )
            if self.use_keys is True:
                self._key_check()
            self.pkey = pkey
            self.passphrase = passphrase
            self.allow_agent = allow_agent
            self.system_host_keys = system_host_keys
            self.alt_host_keys = alt_host_keys
            self.alt_key_file = alt_key_file
            self.disabled_algorithms = disabled_algorithms or {}

            # For SSH proxy support
            self.ssh_config_file = ssh_config_file

        # Establish the remote connection
        if auto_connect:
            self._open()

    def _open(self) -&gt; None:
        &#34;&#34;&#34;Decouple connection creation from __init__ for mocking.&#34;&#34;&#34;
        self._modify_connection_params()
        self.establish_connection()
        self._try_session_preparation()

    def __enter__(self) -&gt; &#34;BaseConnection&#34;:
        &#34;&#34;&#34;Establish a session using a Context Manager.&#34;&#34;&#34;
        return self

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -&gt; None:
        &#34;&#34;&#34;Gracefully close connection on Context Manager exit.&#34;&#34;&#34;
        self.disconnect()

    def _modify_connection_params(self) -&gt; None:
        &#34;&#34;&#34;Modify connection parameters prior to SSH connection.&#34;&#34;&#34;
        pass

    def _timeout_exceeded(self, start: float, msg: str = &#34;Timeout exceeded!&#34;) -&gt; bool:
        &#34;&#34;&#34;Raise NetmikoTimeoutException if waiting too much in the serving queue.

        :param start: Initial start time to see if session lock timeout has been exceeded
        :type start: float (from time.time() call i.e. epoch time)

        :param msg: Exception message if timeout was exceeded
        :type msg: str
        &#34;&#34;&#34;
        if not start:
            # Must provide a comparison time
            return False
        if time.time() - start &gt; self.session_timeout:
            # session_timeout exceeded
            raise NetmikoTimeoutException(msg)
        return False

    def _lock_netmiko_session(self, start: Optional[float] = None) -&gt; bool:
        &#34;&#34;&#34;Try to acquire the Netmiko session lock. If not available, wait in the queue until
        the channel is available again.

        :param start: Initial start time to measure the session timeout
        :type start: float (from time.time() call i.e. epoch time)
        &#34;&#34;&#34;
        if not start:
            start = time.time()
        # Wait here until the SSH channel lock is acquired or until session_timeout exceeded
        while not self._session_locker.acquire(False) and not self._timeout_exceeded(
            start, &#34;The netmiko channel is not available!&#34;
        ):
            time.sleep(0.1)
        return True

    def _unlock_netmiko_session(self) -&gt; None:
        &#34;&#34;&#34;
        Release the channel at the end of the task.
        &#34;&#34;&#34;
        if self._session_locker.locked():
            self._session_locker.release()

    def _autodetect_fs(self, cmd: str = &#34;&#34;, pattern: str = &#34;&#34;) -&gt; str:
        raise NotImplementedError

    def _enter_shell(self) -&gt; str:
        raise NotImplementedError

    def _return_cli(self) -&gt; str:
        raise NotImplementedError

    def _key_check(self) -&gt; bool:
        &#34;&#34;&#34;Verify key_file exists.&#34;&#34;&#34;
        msg = f&#34;&#34;&#34;
use_keys has been set to True, but specified key_file does not exist:

use_keys: {self.use_keys}
key_file: {self.key_file}
&#34;&#34;&#34;
        if self.key_file is None:
            raise ValueError(msg)

        my_key_file = Path(self.key_file)
        if not my_key_file.is_file():
            raise ValueError(msg)
        return True

    @lock_channel
    @log_writes
    def write_channel(self, out_data: str) -&gt; None:
        &#34;&#34;&#34;Generic method that will write data out the channel.

        :param out_data: data to be written to the channel
        :type out_data: str
        &#34;&#34;&#34;
        self.channel.write_channel(out_data)

    def is_alive(self) -&gt; bool:
        &#34;&#34;&#34;Returns a boolean flag with the state of the connection.&#34;&#34;&#34;
        null = chr(0)
        if self.remote_conn is None:
            log.error(&#34;Connection is not initialised, is_alive returns False&#34;)
            return False
        if self.protocol == &#34;telnet&#34;:
            try:
                # Try sending IAC + NOP (IAC is telnet way of sending command)
                # IAC = Interpret as Command; it comes before the NOP.
                log.debug(&#34;Sending IAC + NOP&#34;)
                # Need to send multiple times to test connection
                assert isinstance(self.remote_conn, telnetlib.Telnet)
                telnet_socket = self.remote_conn.get_socket()
                telnet_socket.sendall(telnetlib.IAC + telnetlib.NOP)
                telnet_socket.sendall(telnetlib.IAC + telnetlib.NOP)
                telnet_socket.sendall(telnetlib.IAC + telnetlib.NOP)
                return True
            except AttributeError:
                return False
        else:
            # SSH
            try:
                # Try sending ASCII null byte to maintain the connection alive
                log.debug(&#34;Sending the NULL byte&#34;)
                self.write_channel(null)
                assert isinstance(self.remote_conn, paramiko.Channel)
                assert self.remote_conn.transport is not None
                result = self.remote_conn.transport.is_active()
                assert isinstance(result, bool)
                return result
            except (socket.error, EOFError):
                log.error(&#34;Unable to send&#34;, exc_info=True)
                # If unable to send, we can tell for sure that the connection is unusable
                return False
        return False

    @lock_channel
    def read_channel(self) -&gt; str:
        &#34;&#34;&#34;Generic handler that will read all the data from given channel.&#34;&#34;&#34;
        new_data = self.channel.read_channel()
        new_data = self.normalize_linefeeds(new_data)
        if self.ansi_escape_codes:
            new_data = self.strip_ansi_escape_codes(new_data)
        log.debug(f&#34;read_channel: {new_data}&#34;)
        if self.session_log:
            self.session_log.write(new_data)

        # If data had been previously saved to the buffer, the prepend it to output
        # do post read_channel so session_log/log doesn&#39;t record buffered data twice
        if self._read_buffer:
            output = self._read_buffer + new_data
            self._read_buffer = &#34;&#34;
        else:
            output = new_data
        return output

    def read_until_pattern(
        self,
        pattern: str = &#34;&#34;,
        read_timeout: float = 10.0,
        re_flags: int = 0,
        max_loops: Optional[int] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Read channel until pattern is detected.

        Will return string up to and including pattern.

        Returns ReadTimeout if pattern not detected in read_timeout seconds.

        :param pattern: Regular expression pattern used to identify that reading is done.

        :param read_timeout: maximum time to wait looking for pattern. Will raise ReadTimeout.
            A read_timeout value of 0 will cause the loop to never timeout (i.e. it will keep
            reading indefinitely until pattern is detected.

        :param re_flags: regex flags used in conjunction with pattern (defaults to no flags).

        :param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.
        &#34;&#34;&#34;
        if max_loops is not None:
            msg = &#34;&#34;&#34;\n
Netmiko 4.x has deprecated the use of max_loops with read_until_pattern.
You should convert all uses of max_loops over to read_timeout=x
where x is the total number of seconds to wait before timing out.\n&#34;&#34;&#34;
            warnings.warn(msg, DeprecationWarning)

        if self.read_timeout_override:
            read_timeout = self.read_timeout_override

        output = &#34;&#34;
        loop_delay = 0.01
        start_time = time.time()
        # if read_timeout == 0 or 0.0 keep reading indefinitely
        while (time.time() - start_time &lt; read_timeout) or (not read_timeout):
            output += self.read_channel()
            if re.search(pattern, output, flags=re_flags):
                results = re.split(pattern, output, maxsplit=1, flags=re_flags)

                # The string matched by pattern must be retained in the output string.
                # re.split will do this if capturing parenthesis are used.
                if len(results) == 2:
                    # no capturing parenthesis, convert and try again.
                    pattern = f&#34;({pattern})&#34;
                    results = re.split(pattern, output, maxsplit=1, flags=re_flags)

                if len(results) != 3:
                    # well, we tried
                    msg = f&#34;&#34;&#34;Unable to successfully split output based on pattern:
pattern={pattern}
output={repr(output)}
results={results}
&#34;&#34;&#34;
                    raise ReadException(msg)

                # Process such that everything before and including pattern is return.
                # Everything else is retained in the _read_buffer
                output, match_str, buffer = results
                output = output + match_str
                if buffer:
                    self._read_buffer += buffer
                log.debug(f&#34;Pattern found: {pattern} {output}&#34;)
                return output
            time.sleep(loop_delay)

        msg = f&#34;&#34;&#34;\n\nPattern not detected: {repr(pattern)} in output.

Things you might try to fix this:
1. Adjust the regex pattern to better identify the terminating string. Note, in
many situations the pattern is automatically based on the network device&#39;s prompt.
2. Increase the read_timeout to a larger value.

You can also look at the Netmiko session_log or debug log for more information.\n\n&#34;&#34;&#34;
        raise ReadTimeout(msg)

    def read_channel_timing(
        self,
        last_read: float = 2.0,
        read_timeout: float = 120.0,
        delay_factor: Optional[float] = None,
        max_loops: Optional[int] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Read data on the channel based on timing delays.

        General pattern is keep reading until no new data is read.
        Once no new data is read wait `last_read` amount of time (one last read).
        As long as no new data, then return data.

        `read_timeout` is an absolute timer for how long to keep reading (which presupposes
        we are still getting new data).

        Setting `read_timeout` to zero will cause read_channel_timing to never expire based
        on an absolute timeout. It will only complete based on timeout based on their being
        no new data.

        :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        :param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.
        &#34;&#34;&#34;

        if delay_factor is not None or max_loops is not None:
            warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)

        if self.read_timeout_override:
            read_timeout = self.read_timeout_override

        # Time to delay in each read loop
        loop_delay = 0.1
        channel_data = &#34;&#34;
        start_time = time.time()

        # Set read_timeout to 0 to never timeout
        while (time.time() - start_time &lt; read_timeout) or (not read_timeout):
            time.sleep(loop_delay)
            new_data = self.read_channel()
            # gather new output
            if new_data:
                channel_data += new_data
            # if we have some output, but nothing new, then do the last read
            elif channel_data != &#34;&#34;:
                # Make sure really done (i.e. no new data)
                time.sleep(last_read)
                new_data = self.read_channel()
                if not new_data:
                    break
                else:
                    channel_data += new_data
        else:
            msg = f&#34;&#34;&#34;\n
read_channel_timing&#39;s absolute timer expired.

The network device was continually outputting data for longer than {read_timeout}
seconds.

If this is expected i.e. the command you are executing is continually emitting
data for a long period of time, then you can set &#39;read_timeout=x&#39; seconds. If
you want Netmiko to keep reading indefinitely (i.e. to only stop when there is
no new data), then you can set &#39;read_timeout=0&#39;.

You can look at the Netmiko session_log or debug log for more information.

&#34;&#34;&#34;
            raise ReadTimeout(msg)
        return channel_data

    def read_until_prompt(
        self,
        read_timeout: float = 10.0,
        read_entire_line: bool = False,
        re_flags: int = 0,
        max_loops: Optional[int] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Read channel up to and including self.base_prompt.&#34;&#34;&#34;
        pattern = re.escape(self.base_prompt)
        if read_entire_line:
            pattern = f&#34;{pattern}.*&#34;
        return self.read_until_pattern(
            pattern=pattern,
            re_flags=re_flags,
            max_loops=max_loops,
            read_timeout=read_timeout,
        )

    def read_until_prompt_or_pattern(
        self,
        pattern: str = &#34;&#34;,
        read_timeout: float = 10.0,
        read_entire_line: bool = False,
        re_flags: int = 0,
        max_loops: Optional[int] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Read until either self.base_prompt or pattern is detected.&#34;&#34;&#34;
        prompt_pattern = re.escape(self.base_prompt)
        if read_entire_line:
            prompt_pattern = f&#34;{prompt_pattern}.*&#34;
        if pattern:
            combined_pattern = r&#34;(?:{}|{})&#34;.format(prompt_pattern, pattern)
        else:
            combined_pattern = prompt_pattern
        return self.read_until_pattern(
            pattern=combined_pattern,
            re_flags=re_flags,
            max_loops=max_loops,
            read_timeout=read_timeout,
        )

    def serial_login(
        self,
        pri_prompt_terminator: str = r&#34;#\s*$&#34;,
        alt_prompt_terminator: str = r&#34;&gt;\s*$&#34;,
        username_pattern: str = r&#34;(?:[Uu]ser:|sername|ogin)&#34;,
        pwd_pattern: str = r&#34;assword&#34;,
        delay_factor: float = 1.0,
        max_loops: int = 20,
    ) -&gt; str:
        return self.telnet_login(
            pri_prompt_terminator,
            alt_prompt_terminator,
            username_pattern,
            pwd_pattern,
            delay_factor,
            max_loops,
        )

    def telnet_login(
        self,
        pri_prompt_terminator: str = r&#34;#\s*$&#34;,
        alt_prompt_terminator: str = r&#34;&gt;\s*$&#34;,
        username_pattern: str = r&#34;(?:user:|username|login|user name)&#34;,
        pwd_pattern: str = r&#34;assword&#34;,
        delay_factor: float = 1.0,
        max_loops: int = 20,
    ) -&gt; str:
        &#34;&#34;&#34;Telnet login. Can be username/password or just password.

        :param pri_prompt_terminator: Primary trailing delimiter for identifying a device prompt

        :param alt_prompt_terminator: Alternate trailing delimiter for identifying a device prompt

        :param username_pattern: Pattern used to identify the username prompt

        :param delay_factor: See __init__: global_delay_factor

        :param max_loops: Controls the wait time in conjunction with the delay_factor
        &#34;&#34;&#34;
        delay_factor = self.select_delay_factor(delay_factor)

        # Revert telnet_login back to old speeds/delays
        if delay_factor &lt; 1:
            if not self._legacy_mode and self.fast_cli:
                delay_factor = 1

        time.sleep(1 * delay_factor)

        output = &#34;&#34;
        return_msg = &#34;&#34;
        i = 1
        while i &lt;= max_loops:
            try:
                output = self.read_channel()
                return_msg += output

                # Search for username pattern / send username
                if re.search(username_pattern, output, flags=re.I):
                    # Sometimes username/password must be terminated with &#34;\r&#34; and not &#34;\r\n&#34;
                    self.write_channel(self.username + &#34;\r&#34;)
                    time.sleep(1 * delay_factor)
                    output = self.read_channel()
                    return_msg += output

                # Search for password pattern / send password
                if re.search(pwd_pattern, output, flags=re.I):
                    # Sometimes username/password must be terminated with &#34;\r&#34; and not &#34;\r\n&#34;
                    assert isinstance(self.password, str)
                    self.write_channel(self.password + &#34;\r&#34;)
                    time.sleep(0.5 * delay_factor)
                    output = self.read_channel()
                    return_msg += output
                    if re.search(
                        pri_prompt_terminator, output, flags=re.M
                    ) or re.search(alt_prompt_terminator, output, flags=re.M):
                        return return_msg

                # Check if proper data received
                if re.search(pri_prompt_terminator, output, flags=re.M) or re.search(
                    alt_prompt_terminator, output, flags=re.M
                ):
                    return return_msg

                self.write_channel(self.TELNET_RETURN)
                time.sleep(0.5 * delay_factor)
                i += 1
            except EOFError:
                assert self.remote_conn is not None
                self.remote_conn.close()
                msg = f&#34;Login failed: {self.host}&#34;
                raise NetmikoAuthenticationException(msg)

        # Last try to see if we already logged in
        self.write_channel(self.TELNET_RETURN)
        time.sleep(0.5 * delay_factor)
        output = self.read_channel()
        return_msg += output
        if re.search(pri_prompt_terminator, output, flags=re.M) or re.search(
            alt_prompt_terminator, output, flags=re.M
        ):
            return return_msg

        msg = f&#34;Login failed: {self.host}&#34;
        assert self.remote_conn is not None
        self.remote_conn.close()
        raise NetmikoAuthenticationException(msg)

    def _try_session_preparation(self, force_data: bool = True) -&gt; None:
        &#34;&#34;&#34;
        In case of an exception happening during `session_preparation()` Netmiko should
        gracefully clean-up after itself. This might be challenging for library users
        to do since they do not have a reference to the object. This is possibly related
        to threads used in Paramiko.
        &#34;&#34;&#34;
        try:
            # Netmiko needs there to be data for session_preparation to work.
            if force_data:
                self.write_channel(self.RETURN)
                time.sleep(0.1)
            self.session_preparation()
        except Exception:
            self.disconnect()
            raise

    def session_preparation(self) -&gt; None:
        &#34;&#34;&#34;
        Prepare the session after the connection has been established

        This method handles some differences that occur between various devices
        early on in the session.

        In general, it should include:
        self._test_channel_read(pattern=r&#34;some_pattern&#34;)
        self.set_base_prompt()
        self.set_terminal_width()
        self.disable_paging()
        &#34;&#34;&#34;
        self._test_channel_read()
        self.set_base_prompt()
        self.set_terminal_width()
        self.disable_paging()

    def _use_ssh_config(self, dict_arg: Dict[str, Any]) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Update SSH connection parameters based on contents of SSH config file.

        :param dict_arg: Dictionary of SSH connection parameters
        &#34;&#34;&#34;
        connect_dict = dict_arg.copy()

        # Use SSHConfig to generate source content.
        assert self.ssh_config_file is not None
        full_path = path.abspath(path.expanduser(self.ssh_config_file))
        source: Union[paramiko.config.SSHConfigDict, Dict[str, Any]]
        if path.exists(full_path):
            ssh_config_instance = paramiko.SSHConfig()
            with io.open(full_path, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as f:
                ssh_config_instance.parse(f)
                source = ssh_config_instance.lookup(self.host)
        else:
            source = {}

        # Keys get normalized to lower-case
        proxy: Optional[paramiko.proxy.ProxyCommand]
        if &#34;proxycommand&#34; in source:
            proxy = paramiko.ProxyCommand(source[&#34;proxycommand&#34;])
        elif &#34;proxyjump&#34; in source:
            hops = list(reversed(source[&#34;proxyjump&#34;].split(&#34;,&#34;)))
            if len(hops) &gt; 1:
                raise ValueError(
                    &#34;ProxyJump with more than one proxy server is not supported.&#34;
                )
            port = source.get(&#34;port&#34;, self.port)
            host = source.get(&#34;hostname&#34;, self.host)
            # -F {full_path} forces the continued use of the same SSH config file
            cmd = &#34;ssh -F {} -W {}:{} {}&#34;.format(full_path, host, port, hops[0])
            proxy = paramiko.ProxyCommand(cmd)
        else:
            proxy = None

        # Only update &#39;hostname&#39;, &#39;sock&#39;, &#39;port&#39;, and &#39;username&#39;
        # For &#39;port&#39; and &#39;username&#39; only update if using object defaults
        if connect_dict[&#34;port&#34;] == 22:
            connect_dict[&#34;port&#34;] = int(source.get(&#34;port&#34;, self.port))
        if connect_dict[&#34;username&#34;] == &#34;&#34;:
            connect_dict[&#34;username&#34;] = source.get(&#34;user&#34;, self.username)
        if proxy:
            connect_dict[&#34;sock&#34;] = proxy
        connect_dict[&#34;hostname&#34;] = source.get(&#34;hostname&#34;, self.host)

        return connect_dict

    def _connect_params_dict(self) -&gt; Dict[str, Any]:
        &#34;&#34;&#34;Generate dictionary of Paramiko connection parameters.&#34;&#34;&#34;
        conn_dict = {
            &#34;hostname&#34;: self.host,
            &#34;port&#34;: self.port,
            &#34;username&#34;: self.username,
            &#34;password&#34;: self.password,
            &#34;look_for_keys&#34;: self.use_keys,
            &#34;allow_agent&#34;: self.allow_agent,
            &#34;key_filename&#34;: self.key_file,
            &#34;pkey&#34;: self.pkey,
            &#34;passphrase&#34;: self.passphrase,
            &#34;disabled_algorithms&#34;: self.disabled_algorithms,
            &#34;timeout&#34;: self.conn_timeout,
            &#34;auth_timeout&#34;: self.auth_timeout,
            &#34;banner_timeout&#34;: self.banner_timeout,
            &#34;sock&#34;: self.sock,
        }

        # Check if using SSH &#39;config&#39; file mainly for SSH proxy support
        if self.ssh_config_file:
            conn_dict = self._use_ssh_config(conn_dict)
        return conn_dict

    def _sanitize_output(
        self,
        output: str,
        strip_command: bool = False,
        command_string: Optional[str] = None,
        strip_prompt: bool = False,
    ) -&gt; str:
        &#34;&#34;&#34;Strip out command echo and trailing router prompt.&#34;&#34;&#34;
        if strip_command and command_string:
            command_string = self.normalize_linefeeds(command_string)
            output = self.strip_command(command_string, output)
        if strip_prompt:
            output = self.strip_prompt(output)
        return output

    def establish_connection(self, width: int = 511, height: int = 1000) -&gt; None:
        &#34;&#34;&#34;Establish SSH connection to the network device

        Timeout will generate a NetmikoTimeoutException
        Authentication failure will generate a NetmikoAuthenticationException

        :param width: Specified width of the VT100 terminal window (default: 511)
        :type width: int

        :param height: Specified height of the VT100 terminal window (default: 1000)
        :type height: int
        &#34;&#34;&#34;
        self.channel: Channel
        if self.protocol == &#34;telnet&#34;:
            self.remote_conn = telnetlib.Telnet(
                self.host, port=self.port, timeout=self.timeout
            )
            # Migrating communication to channel class
            self.channel = TelnetChannel(conn=self.remote_conn, encoding=self.encoding)
            self.telnet_login()
        elif self.protocol == &#34;serial&#34;:
            self.remote_conn = serial.Serial(**self.serial_settings)
            self.channel = SerialChannel(conn=self.remote_conn, encoding=self.encoding)
            self.serial_login()
        elif self.protocol == &#34;ssh&#34;:
            ssh_connect_params = self._connect_params_dict()
            self.remote_conn_pre: Optional[paramiko.SSHClient]
            self.remote_conn_pre = self._build_ssh_client()

            # initiate SSH connection
            try:
                self.remote_conn_pre.connect(**ssh_connect_params)
            except socket.error as conn_error:
                self.paramiko_cleanup()
                msg = f&#34;&#34;&#34;TCP connection to device failed.

Common causes of this problem are:
1. Incorrect hostname or IP address.
2. Wrong TCP port.
3. Intermediate firewall blocking access.

Device settings: {self.device_type} {self.host}:{self.port}

&#34;&#34;&#34;

                # Handle DNS failures separately
                if &#34;Name or service not known&#34; in str(conn_error):
                    msg = (
                        f&#34;DNS failure--the hostname you provided was not resolvable &#34;
                        f&#34;in DNS: {self.host}:{self.port}&#34;
                    )

                msg = msg.lstrip()
                raise NetmikoTimeoutException(msg)
            except paramiko.ssh_exception.AuthenticationException as auth_err:
                self.paramiko_cleanup()
                msg = f&#34;&#34;&#34;Authentication to device failed.

Common causes of this problem are:
1. Invalid username and password
2. Incorrect SSH-key file
3. Connecting to the wrong device

Device settings: {self.device_type} {self.host}:{self.port}

&#34;&#34;&#34;

                msg += self.RETURN + str(auth_err)
                raise NetmikoAuthenticationException(msg)
            except paramiko.ssh_exception.SSHException as e:
                self.paramiko_cleanup()
                if &#34;No existing session&#34; in str(e):
                    msg = (
                        &#34;Paramiko: &#39;No existing session&#39; error: &#34;
                        &#34;try increasing &#39;conn_timeout&#39; to 15 seconds or larger.&#34;
                    )
                    raise NetmikoTimeoutException(msg)
                else:
                    msg = f&#34;&#34;&#34;
A paramiko SSHException occurred during connection creation:

{str(e)}

&#34;&#34;&#34;
                    raise NetmikoTimeoutException(msg)

            if self.verbose:
                print(f&#34;SSH connection established to {self.host}:{self.port}&#34;)

            # Use invoke_shell to establish an &#39;interactive session&#39;
            self.remote_conn = self.remote_conn_pre.invoke_shell(
                term=&#34;vt100&#34;, width=width, height=height
            )

            self.remote_conn.settimeout(self.blocking_timeout)
            if self.keepalive:
                assert isinstance(self.remote_conn.transport, paramiko.Transport)
                self.remote_conn.transport.set_keepalive(self.keepalive)

            # Migrating communication to channel class
            self.channel = SSHChannel(conn=self.remote_conn, encoding=self.encoding)

            self.special_login_handler()
            if self.verbose:
                print(&#34;Interactive SSH session established&#34;)

        return None

    def _test_channel_read(self, count: int = 40, pattern: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Try to read the channel (generally post login) verify you receive data back.

        :param count: the number of times to check the channel for data

        :param pattern: Regular expression pattern used to determine end of channel read
        &#34;&#34;&#34;

        def _increment_delay(
            main_delay: float, increment: float = 1.1, maximum: int = 8
        ) -&gt; float:
            &#34;&#34;&#34;Increment sleep time to a maximum value.&#34;&#34;&#34;
            main_delay = main_delay * increment
            if main_delay &gt;= maximum:
                main_delay = maximum
            return main_delay

        i = 0
        delay_factor = self.select_delay_factor(delay_factor=0)

        if pattern:
            return self.read_until_pattern(pattern=pattern, read_timeout=20)

        main_delay = delay_factor * 0.1
        time.sleep(main_delay * 10)
        new_data = &#34;&#34;
        while i &lt;= count:
            new_data += self.read_channel_timing(read_timeout=20)
            if new_data:
                return new_data

            self.write_channel(self.RETURN)
            main_delay = _increment_delay(main_delay)
            time.sleep(main_delay)
            i += 1

        raise NetmikoTimeoutException(&#34;Timed out waiting for data&#34;)

    def _build_ssh_client(self) -&gt; paramiko.SSHClient:
        &#34;&#34;&#34;Prepare for Paramiko SSH connection.&#34;&#34;&#34;
        # Create instance of SSHClient object
        remote_conn_pre = paramiko.SSHClient()

        # Load host_keys for better SSH security
        if self.system_host_keys:
            remote_conn_pre.load_system_host_keys()
        if self.alt_host_keys and path.isfile(self.alt_key_file):
            remote_conn_pre.load_host_keys(self.alt_key_file)

        # Default is to automatically add untrusted hosts (make sure appropriate for your env)
        remote_conn_pre.set_missing_host_key_policy(self.key_policy)
        return remote_conn_pre

    def select_delay_factor(self, delay_factor: float) -&gt; float:
        &#34;&#34;&#34;
        Choose the greater of delay_factor or self.global_delay_factor (default).
        In fast_cli choose the lesser of delay_factor of self.global_delay_factor.

        :param delay_factor: See __init__: global_delay_factor
        :type delay_factor: int
        &#34;&#34;&#34;
        if self.fast_cli:
            if delay_factor and delay_factor &lt;= self.global_delay_factor:
                return delay_factor
            else:
                return self.global_delay_factor
        else:
            if delay_factor &gt;= self.global_delay_factor:
                return delay_factor
            else:
                return self.global_delay_factor

    def special_login_handler(self, delay_factor: float = 1.0) -&gt; None:
        &#34;&#34;&#34;Handler for devices like WLC, Extreme ERS that throw up characters prior to login.&#34;&#34;&#34;
        pass

    def disable_paging(
        self,
        command: str = &#34;terminal length 0&#34;,
        delay_factor: Optional[float] = None,
        cmd_verify: bool = True,
        pattern: Optional[str] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Disable paging default to a Cisco CLI method.

        :param command: Device command to disable pagination of output

        :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.
        &#34;&#34;&#34;
        if delay_factor is not None:
            warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)

        command = self.normalize_cmd(command)
        log.debug(&#34;In disable_paging&#34;)
        log.debug(f&#34;Command: {command}&#34;)
        self.write_channel(command)
        # Make sure you read until you detect the command echo (avoid getting out of sync)
        if cmd_verify and self.global_cmd_verify is not False:
            output = self.read_until_pattern(
                pattern=re.escape(command.strip()), read_timeout=20
            )
        elif pattern:
            output = self.read_until_pattern(pattern=pattern, read_timeout=20)
        else:
            output = self.read_until_prompt()
        log.debug(f&#34;{output}&#34;)
        log.debug(&#34;Exiting disable_paging&#34;)
        return output

    def set_terminal_width(
        self,
        command: str = &#34;&#34;,
        delay_factor: Optional[float] = None,
        cmd_verify: bool = False,
        pattern: Optional[str] = None,
    ) -&gt; str:
        &#34;&#34;&#34;CLI terminals try to automatically adjust the line based on the width of the terminal.
        This causes the output to get distorted when accessed programmatically.

        Set terminal width to 511 which works on a broad set of devices.

        :param command: Command string to send to the device

        :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.
        &#34;&#34;&#34;
        if delay_factor is not None:
            warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)

        if not command:
            return &#34;&#34;
        command = self.normalize_cmd(command)
        self.write_channel(command)

        # Avoid cmd_verify here as terminal width must be set before doing cmd_verify
        if cmd_verify and self.global_cmd_verify is not False:
            output = self.read_until_pattern(pattern=re.escape(command.strip()))
        elif pattern:
            output = self.read_until_pattern(pattern=pattern)
        else:
            output = self.read_until_prompt()
        return output

    # Retry by sleeping .33 and then double sleep until 5 attempts (.33, .66, 1.32, etc)
    @retry(
        wait=wait_exponential(multiplier=0.33, min=0, max=5),
        stop=stop_after_attempt(5),
        reraise=True,
    )
    def set_base_prompt(
        self,
        pri_prompt_terminator: str = &#34;#&#34;,
        alt_prompt_terminator: str = &#34;&gt;&#34;,
        delay_factor: float = 1.0,
        pattern: Optional[str] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Sets self.base_prompt

        Used as delimiter for stripping of trailing prompt in output.

        Should be set to something that is general and applies in multiple contexts. For Cisco
        devices this will be set to router hostname (i.e. prompt without &gt; or #).

        This will be set on entering user exec or privileged exec on Cisco, but not when
        entering/exiting config mode.

        :param pri_prompt_terminator: Primary trailing delimiter for identifying a device prompt

        :param alt_prompt_terminator: Alternate trailing delimiter for identifying a device prompt

        :param delay_factor: See __init__: global_delay_factor

        :param pattern: Regular expression pattern to search for in find_prompt() call
        &#34;&#34;&#34;
        if pattern is None:
            if pri_prompt_terminator and alt_prompt_terminator:
                pri_term = re.escape(pri_prompt_terminator)
                alt_term = re.escape(alt_prompt_terminator)
                pattern = rf&#34;({pri_term}|{alt_term})&#34;
            elif pri_prompt_terminator:
                pattern = re.escape(pri_prompt_terminator)
            elif alt_prompt_terminator:
                pattern = re.escape(alt_prompt_terminator)

        if pattern:
            prompt = self.find_prompt(delay_factor=delay_factor, pattern=pattern)
        else:
            prompt = self.find_prompt(delay_factor=delay_factor)

        if not prompt[-1] in (pri_prompt_terminator, alt_prompt_terminator):
            raise ValueError(f&#34;Router prompt not found: {repr(prompt)}&#34;)

        # If all we have is the &#39;terminator&#39; just use that :-(
        if len(prompt) == 1:
            self.base_prompt = prompt
        else:
            # Strip off trailing terminator
            self.base_prompt = prompt[:-1]
        return self.base_prompt

    def find_prompt(
        self, delay_factor: float = 1.0, pattern: Optional[str] = None
    ) -&gt; str:
        &#34;&#34;&#34;Finds the current network device prompt, last line only.

        :param delay_factor: See __init__: global_delay_factor
        :type delay_factor: int

        :param pattern: Regular expression pattern to determine whether prompt is valid
        &#34;&#34;&#34;
        delay_factor = self.select_delay_factor(delay_factor)
        sleep_time = delay_factor * 0.25
        self.clear_buffer()
        self.write_channel(self.RETURN)

        if pattern:
            prompt = self.read_until_pattern(pattern=pattern)
        else:
            # Initial read
            time.sleep(sleep_time)
            prompt = self.read_channel().strip()

            count = 0
            while count &lt;= 12 and not prompt:
                if not prompt:
                    self.write_channel(self.RETURN)
                    time.sleep(sleep_time)
                    prompt = self.read_channel().strip()
                    if sleep_time &lt;= 3:
                        # Double the sleep_time when it is small
                        sleep_time *= 2
                    else:
                        sleep_time += 1
                count += 1

        # If multiple lines in the output take the last line
        prompt = prompt.split(self.RESPONSE_RETURN)[-1]
        prompt = prompt.strip()
        self.clear_buffer()
        if not prompt:
            raise ValueError(f&#34;Unable to find prompt: {prompt}&#34;)
        log.debug(f&#34;[find_prompt()]: prompt is {prompt}&#34;)
        return prompt

    def clear_buffer(
        self,
        backoff: bool = True,
        backoff_max: float = 3.0,
        delay_factor: Optional[float] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Read any data available in the channel.&#34;&#34;&#34;

        if delay_factor is None:
            delay_factor = self.global_delay_factor
        sleep_time = 0.1 * delay_factor

        output = &#34;&#34;
        for _ in range(10):
            time.sleep(sleep_time)
            data = self.read_channel()
            data = self.strip_ansi_escape_codes(data)
            output += data
            if not data:
                break
            # Double sleep time each time we detect data
            log.debug(&#34;Clear buffer detects data in the channel&#34;)
            if backoff:
                sleep_time *= 2
                sleep_time = backoff_max if sleep_time &gt;= backoff_max else sleep_time
        return output

    def command_echo_read(self, cmd: str, read_timeout: float) -&gt; str:

        # Make sure you read until you detect the command echo (avoid getting out of sync)
        new_data = self.read_until_pattern(
            pattern=re.escape(cmd), read_timeout=read_timeout
        )

        # There can be echoed prompts that haven&#39;t been cleared before the cmd echo
        # this can later mess up the trailing prompt pattern detection. Clear this out.
        lines = new_data.split(cmd)
        if len(lines) == 2:
            # lines[-1] should realistically just be the null string
            new_data = f&#34;{cmd}{lines[-1]}&#34;
        else:
            # cmd exists in the output multiple times? Just retain the original output
            pass
        return new_data

    @select_cmd_verify
    def send_command_timing(
        self,
        command_string: str,
        last_read: float = 2.0,
        read_timeout: float = 120.0,
        delay_factor: Optional[float] = None,
        max_loops: Optional[int] = None,
        strip_prompt: bool = True,
        strip_command: bool = True,
        normalize: bool = True,
        use_textfsm: bool = False,
        textfsm_template: Optional[str] = None,
        use_ttp: bool = False,
        ttp_template: Optional[str] = None,
        use_genie: bool = False,
        cmd_verify: bool = False,
    ) -&gt; Union[str, List[Any], Dict[str, Any]]:
        &#34;&#34;&#34;Execute command_string on the SSH channel using a delay-based mechanism. Generally
        used for show commands.

        :param command_string: The command to be executed on the remote device.

        :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        :param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        :param strip_prompt: Remove the trailing router prompt from the output (default: True).

        :param strip_command: Remove the echo of the command from the output (default: True).

        :param normalize: Ensure the proper enter is sent at end of command (default: True).

        :param use_textfsm: Process command output through TextFSM template (default: False).

        :param textfsm_template: Name of template to parse output with; can be fully qualified
            path, relative path, or name of file in current directory. (default: None).

        :param use_ttp: Process command output through TTP template (default: False).

        :param ttp_template: Name of template to parse output with; can be fully qualified
            path, relative path, or name of file in current directory. (default: None).

        :param use_genie: Process command output through PyATS/Genie parser (default: False).

        :param cmd_verify: Verify command echo before proceeding (default: False).
        &#34;&#34;&#34;
        if delay_factor is not None or max_loops is not None:
            warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)

        output = &#34;&#34;
        new_data = &#34;&#34;
        if normalize:
            command_string = self.normalize_cmd(command_string)
        self.write_channel(command_string)

        cmd = command_string.strip()
        if cmd and cmd_verify:
            new_data = self.command_echo_read(cmd=cmd, read_timeout=10)
        output += new_data
        output += self.read_channel_timing(
            last_read=last_read, read_timeout=read_timeout
        )

        output = self._sanitize_output(
            output,
            strip_command=strip_command,
            command_string=command_string,
            strip_prompt=strip_prompt,
        )
        return_data = structured_data_converter(
            command=command_string,
            raw_data=output,
            platform=self.device_type,
            use_textfsm=use_textfsm,
            use_ttp=use_ttp,
            use_genie=use_genie,
            textfsm_template=textfsm_template,
            ttp_template=ttp_template,
        )
        return return_data

    def _send_command_timing_str(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Wrapper for `send_command_timing` method that always returns a
        string&#34;&#34;&#34;
        output = self.send_command_timing(*args, **kwargs)
        assert isinstance(output, str)
        return output

    def strip_prompt(self, a_string: str) -&gt; str:
        &#34;&#34;&#34;Strip the trailing router prompt from the output.

        :param a_string: Returned string from device
        :type a_string: str
        &#34;&#34;&#34;
        response_list = a_string.split(self.RESPONSE_RETURN)
        last_line = response_list[-1]

        if self.base_prompt in last_line:
            return self.RESPONSE_RETURN.join(response_list[:-1])
        else:
            return a_string

    def _first_line_handler(self, data: str, search_pattern: str) -&gt; Tuple[str, bool]:
        &#34;&#34;&#34;
        In certain situations the first line will get repainted which causes a false
        match on the terminating pattern.

        Filter this out.

        returns a tuple of (data, first_line_processed)

        Where data is the original data potentially with the first line modified
        and the first_line_processed is a flag indicating that we have handled the
        first line.
        &#34;&#34;&#34;
        try:
            # First line is the echo line containing the command. In certain situations
            # it gets repainted and needs filtered
            lines = data.split(self.RETURN)
            first_line = lines[0]
            if BACKSPACE_CHAR in first_line:
                pattern = search_pattern + r&#34;.*$&#34;
                first_line = re.sub(pattern, repl=&#34;&#34;, string=first_line)
                lines[0] = first_line
                data = self.RETURN.join(lines)
            return (data, True)
        except IndexError:
            return (data, False)

    def _prompt_handler(self, auto_find_prompt: bool) -&gt; str:
        if auto_find_prompt:
            try:
                prompt = self.find_prompt()
            except ValueError:
                prompt = self.base_prompt
        else:
            prompt = self.base_prompt
        return re.escape(prompt.strip())

    @select_cmd_verify
    def send_command(
        self,
        command_string: str,
        expect_string: Optional[str] = None,
        read_timeout: float = 10.0,
        delay_factor: Optional[float] = None,
        max_loops: Optional[int] = None,
        auto_find_prompt: bool = True,
        strip_prompt: bool = True,
        strip_command: bool = True,
        normalize: bool = True,
        use_textfsm: bool = False,
        textfsm_template: Optional[str] = None,
        use_ttp: bool = False,
        ttp_template: Optional[str] = None,
        use_genie: bool = False,
        cmd_verify: bool = True,
    ) -&gt; Union[str, List[Any], Dict[str, Any]]:
        &#34;&#34;&#34;Execute command_string on the SSH channel using a pattern-based mechanism. Generally
        used for show commands. By default this method will keep waiting to receive data until the
        network device prompt is detected. The current network device prompt will be determined
        automatically.

        :param command_string: The command to be executed on the remote device.

        :param expect_string: Regular expression pattern to use for determining end of output.
            If left blank will default to being based on router prompt.

        :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        :param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        :param strip_prompt: Remove the trailing router prompt from the output (default: True).

        :param strip_command: Remove the echo of the command from the output (default: True).

        :param normalize: Ensure the proper enter is sent at end of command (default: True).

        :param use_textfsm: Process command output through TextFSM template (default: False).

        :param textfsm_template: Name of template to parse output with; can be fully qualified
            path, relative path, or name of file in current directory. (default: None).

        :param use_ttp: Process command output through TTP template (default: False).

        :param ttp_template: Name of template to parse output with; can be fully qualified
            path, relative path, or name of file in current directory. (default: None).

        :param use_genie: Process command output through PyATS/Genie parser (default: False).

        :param cmd_verify: Verify command echo before proceeding (default: True).
        &#34;&#34;&#34;

        # Time to delay in each read loop
        loop_delay = 0.025

        if self.read_timeout_override:
            read_timeout = self.read_timeout_override

        if self.delay_factor_compat:
            # For compatibility calculate the old equivalent read_timeout
            # i.e. what it would have been in Netmiko 3.x
            if delay_factor is None:
                tmp_delay_factor = self.global_delay_factor
            else:
                tmp_delay_factor = self.select_delay_factor(delay_factor)
            compat_timeout = calc_old_timeout(
                max_loops=max_loops,
                delay_factor=tmp_delay_factor,
                loop_delay=0.2,
                old_timeout=self.timeout,
            )
            msg = f&#34;&#34;&#34;\n
You have chosen to use Netmiko&#39;s delay_factor compatibility mode for
send_command. This will revert Netmiko to behave similarly to how it
did in Netmiko 3.x (i.e. to use delay_factor/global_delay_factor and
max_loops).

Using these parameters Netmiko has calculated an effective read_timeout
of {compat_timeout} and will set the read_timeout to this value.

Please convert your code to that new format i.e.:

    net_connect.send_command(cmd, read_timeout={compat_timeout})

And then disable delay_factor_compat.

delay_factor_compat will be removed in Netmiko 5.x.\n&#34;&#34;&#34;
            warnings.warn(msg, DeprecationWarning)

            # Override the read_timeout with Netmiko 3.x way :-(
            read_timeout = compat_timeout

        else:
            # No need for two deprecation messages so only display this if not using
            # delay_factor_compat
            if delay_factor is not None or max_loops is not None:
                msg = &#34;&#34;&#34;\n
Netmiko 4.x has deprecated the use of delay_factor/max_loops with
send_command. You should convert all uses of delay_factor and max_loops
over to read_timeout=x where x is the total number of seconds to wait
before timing out.\n&#34;&#34;&#34;
                warnings.warn(msg, DeprecationWarning)

        if expect_string is not None:
            search_pattern = expect_string
        else:
            search_pattern = self._prompt_handler(auto_find_prompt)

        if normalize:
            command_string = self.normalize_cmd(command_string)

        # Start the clock
        start_time = time.time()
        self.write_channel(command_string)
        new_data = &#34;&#34;

        cmd = command_string.strip()
        if cmd and cmd_verify:
            new_data = self.command_echo_read(cmd=cmd, read_timeout=10)

        MAX_CHARS = 2_000_000
        DEQUE_SIZE = 20
        output = &#34;&#34;
        # Check only the past N-reads. This is for the case where the output is
        # very large (i.e. searching a very large string for a pattern a whole bunch of times)
        past_n_reads: Deque[str] = deque(maxlen=DEQUE_SIZE)
        first_line_processed = False

        # Keep reading data until search_pattern is found or until read_timeout
        while time.time() - start_time &lt; read_timeout:
            if new_data:
                output += new_data
                past_n_reads.append(new_data)

                # Case where we haven&#39;t processed the first_line yet (there is a potential issue
                # in the first line (in cases where the line is repainted).
                if not first_line_processed:
                    output, first_line_processed = self._first_line_handler(
                        output, search_pattern
                    )
                    # Check if we have already found our pattern
                    if re.search(search_pattern, output):
                        break

                else:
                    if len(output) &lt;= MAX_CHARS:
                        if re.search(search_pattern, output):
                            break
                    else:
                        # Switch to deque mode if output is greater than MAX_CHARS
                        # Check if pattern is in the past n reads
                        if re.search(search_pattern, &#34;&#34;.join(past_n_reads)):
                            break

            time.sleep(loop_delay)
            new_data = self.read_channel()

        else:  # nobreak
            msg = f&#34;&#34;&#34;
Pattern not detected: {repr(search_pattern)} in output.

Things you might try to fix this:
1. Explicitly set your pattern using the expect_string argument.
2. Increase the read_timeout to a larger value.

You can also look at the Netmiko session_log or debug log for more information.

&#34;&#34;&#34;
            raise ReadTimeout(msg)

        output = self._sanitize_output(
            output,
            strip_command=strip_command,
            command_string=command_string,
            strip_prompt=strip_prompt,
        )
        return_val = structured_data_converter(
            command=command_string,
            raw_data=output,
            platform=self.device_type,
            use_textfsm=use_textfsm,
            use_ttp=use_ttp,
            use_genie=use_genie,
            textfsm_template=textfsm_template,
            ttp_template=ttp_template,
        )
        return return_val

    def _send_command_str(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Wrapper for `send_command` method that always returns a string&#34;&#34;&#34;
        output = self.send_command(*args, **kwargs)
        assert isinstance(output, str)
        return output

    def send_command_expect(
        self, *args: Any, **kwargs: Any
    ) -&gt; Union[str, List[Any], Dict[str, Any]]:
        &#34;&#34;&#34;Support previous name of send_command method.&#34;&#34;&#34;
        return self.send_command(*args, **kwargs)

    def _multiline_kwargs(self, **kwargs: Any) -&gt; Dict[str, Any]:
        strip_prompt = kwargs.get(&#34;strip_prompt&#34;, False)
        kwargs[&#34;strip_prompt&#34;] = strip_prompt
        strip_command = kwargs.get(&#34;strip_command&#34;, False)
        kwargs[&#34;strip_command&#34;] = strip_command
        return kwargs

    def send_multiline(
        self,
        commands: Sequence[Union[str, List[str]]],
        multiline: bool = True,
        **kwargs: Any,
    ) -&gt; str:
        &#34;&#34;&#34;
        commands should either be:

        commands = [[cmd1, expect1], [cmd2, expect2], ...]]

        Or

        commands = [cmd1, cmd2, cmd3, ...]

        Any expect_string that is a null-string will use pattern based on
        device&#39;s prompt (unless expect_string argument is passed in via
        kwargs.

        &#34;&#34;&#34;
        output = &#34;&#34;
        if multiline:
            kwargs = self._multiline_kwargs(**kwargs)

        default_expect_string = kwargs.pop(&#34;expect_string&#34;, None)
        if not default_expect_string:
            auto_find_prompt = kwargs.get(&#34;auto_find_prompt&#34;, True)
            default_expect_string = self._prompt_handler(auto_find_prompt)

        if commands and isinstance(commands[0], str):
            # If list of commands just send directly using default_expect_string (probably prompt)
            for cmd in commands:
                cmd = str(cmd)
                output += self._send_command_str(
                    cmd, expect_string=default_expect_string, **kwargs
                )
        else:
            # If list of lists, then first element is cmd and second element is expect_string
            for cmd_item in commands:
                assert not isinstance(cmd_item, str)
                cmd, expect_string = cmd_item
                if not expect_string:
                    expect_string = default_expect_string
                output += self._send_command_str(
                    cmd, expect_string=expect_string, **kwargs
                )
        return output

    def send_multiline_timing(
        self, commands: Sequence[str], multiline: bool = True, **kwargs: Any
    ) -&gt; str:
        if multiline:
            kwargs = self._multiline_kwargs(**kwargs)
        output = &#34;&#34;
        for cmd in commands:
            cmd = str(cmd)
            output += self._send_command_timing_str(cmd, **kwargs)
        return output

    @staticmethod
    def strip_backspaces(output: str) -&gt; str:
        &#34;&#34;&#34;Strip any backspace characters out of the output.

        :param output: Output obtained from a remote network device.
        :type output: str
        &#34;&#34;&#34;
        backspace_char = &#34;\x08&#34;
        return output.replace(backspace_char, &#34;&#34;)

    def strip_command(self, command_string: str, output: str) -&gt; str:
        &#34;&#34;&#34;
        Strip command_string from output string

        Cisco IOS adds backspaces into output for long commands (i.e. for commands that line wrap)

        :param command_string: The command string sent to the device
        :type command_string: str

        :param output: The returned output as a result of the command string sent to the device
        :type output: str
        &#34;&#34;&#34;
        backspace_char = &#34;\x08&#34;

        # Check for line wrap (remove backspaces)
        if backspace_char in output:
            output = output.replace(backspace_char, &#34;&#34;)

        # Juniper has a weird case where the echoed command will be &#34; \n&#34;
        # i.e. there is an extra space there.
        cmd = command_string.strip()
        if output.startswith(cmd):
            output_lines = output.split(self.RESPONSE_RETURN)
            new_output = output_lines[1:]
            return self.RESPONSE_RETURN.join(new_output)
        else:
            # command_string isn&#39;t there; do nothing
            return output

    def normalize_linefeeds(self, a_string: str) -&gt; str:
        &#34;&#34;&#34;Convert `\r\r\n`,`\r\n`, `\n\r` to `\n.`

        :param a_string: A string that may have non-normalized line feeds
            i.e. output returned from device, or a device prompt
        :type a_string: str
        &#34;&#34;&#34;
        newline = re.compile(&#34;(\r\r\r\n|\r\r\n|\r\n|\n\r)&#34;)
        a_string = newline.sub(self.RESPONSE_RETURN, a_string)
        if self.RESPONSE_RETURN == &#34;\n&#34;:
            # Convert any remaining \r to \n
            return re.sub(&#34;\r&#34;, self.RESPONSE_RETURN, a_string)
        else:
            return a_string

    def normalize_cmd(self, command: str) -&gt; str:
        &#34;&#34;&#34;Normalize CLI commands to have a single trailing newline.

        :param command: Command that may require line feed to be normalized
        :type command: str
        &#34;&#34;&#34;
        command = command.rstrip()
        command += self.RETURN
        return command

    def check_enable_mode(self, check_string: str = &#34;&#34;) -&gt; bool:
        &#34;&#34;&#34;Check if in enable mode. Return boolean.

        :param check_string: Identification of privilege mode from device
        :type check_string: str
        &#34;&#34;&#34;
        self.write_channel(self.RETURN)
        output = self.read_until_prompt(read_entire_line=True)
        return check_string in output

    def enable(
        self,
        cmd: str = &#34;&#34;,
        pattern: str = &#34;ssword&#34;,
        enable_pattern: Optional[str] = None,
        re_flags: int = re.IGNORECASE,
    ) -&gt; str:
        &#34;&#34;&#34;Enter enable mode.

        :param cmd: Device command to enter enable mode

        :param pattern: pattern to search for indicating device is waiting for password

        :param enable_pattern: pattern indicating you have entered enable mode

        :param re_flags: Regular expression flags used in conjunction with pattern
        &#34;&#34;&#34;
        output = &#34;&#34;
        msg = (
            &#34;Failed to enter enable mode. Please ensure you pass &#34;
            &#34;the &#39;secret&#39; argument to ConnectHandler.&#34;
        )

        # Check if in enable mode
        if not self.check_enable_mode():
            # Send &#34;enable&#34; mode command
            self.write_channel(self.normalize_cmd(cmd))
            try:
                # Read the command echo
                end_data = &#34;&#34;
                if self.global_cmd_verify is not False:
                    output += self.read_until_pattern(pattern=re.escape(cmd.strip()))
                    end_data = output.split(cmd.strip())[-1]

                # Search for trailing prompt or password pattern
                if pattern not in output and self.base_prompt not in end_data:
                    output += self.read_until_prompt_or_pattern(
                        pattern=pattern, re_flags=re_flags
                    )
                # Send the &#34;secret&#34; in response to password pattern
                if re.search(pattern, output):
                    self.write_channel(self.normalize_cmd(self.secret))
                    output += self.read_until_prompt()

                # Search for terminating pattern if defined
                if enable_pattern and not re.search(enable_pattern, output):
                    output += self.read_until_pattern(pattern=enable_pattern)
                else:
                    if not self.check_enable_mode():
                        raise ValueError(msg)
            except NetmikoTimeoutException:
                raise ValueError(msg)
        return output

    def exit_enable_mode(self, exit_command: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Exit enable mode.

        :param exit_command: Command that exits the session from privileged mode
        :type exit_command: str
        &#34;&#34;&#34;
        output = &#34;&#34;
        if self.check_enable_mode():
            self.write_channel(self.normalize_cmd(exit_command))
            output += self.read_until_prompt()
            if self.check_enable_mode():
                raise ValueError(&#34;Failed to exit enable mode.&#34;)
        return output

    def check_config_mode(
        self, check_string: str = &#34;&#34;, pattern: str = &#34;&#34;, force_regex: bool = False
    ) -&gt; bool:
        &#34;&#34;&#34;Checks if the device is in configuration mode or not.

        :param check_string: Identification of configuration mode from the device
        :type check_string: str

        :param pattern: Pattern to terminate reading of channel
        :type pattern: str
        &#34;&#34;&#34;
        self.write_channel(self.RETURN)
        # You can encounter an issue here (on router name changes) prefer delay-based solution
        if not pattern:
            output = self.read_channel_timing(read_timeout=10.0)
        else:
            output = self.read_until_pattern(pattern=pattern)

        if force_regex:
            return bool(re.search(check_string, output))
        else:
            return check_string in output

    def config_mode(
        self, config_command: str = &#34;&#34;, pattern: str = &#34;&#34;, re_flags: int = 0
    ) -&gt; str:
        &#34;&#34;&#34;Enter into config_mode.

        :param config_command: Configuration command to send to the device
        :type config_command: str

        :param pattern: Pattern to terminate reading of channel
        :type pattern: str

        :param re_flags: Regular expression flags
        :type re_flags: RegexFlag
        &#34;&#34;&#34;
        output = &#34;&#34;
        if not self.check_config_mode():
            self.write_channel(self.normalize_cmd(config_command))
            # Make sure you read until you detect the command echo (avoid getting out of sync)
            if self.global_cmd_verify is not False:
                output += self.read_until_pattern(
                    pattern=re.escape(config_command.strip())
                )
            if pattern:
                output += self.read_until_pattern(pattern=pattern, re_flags=re_flags)
            else:
                output += self.read_until_prompt(read_entire_line=True)
            if not self.check_config_mode():
                raise ValueError(&#34;Failed to enter configuration mode.&#34;)
        return output

    def exit_config_mode(self, exit_config: str = &#34;&#34;, pattern: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Exit from configuration mode.

        :param exit_config: Command to exit configuration mode
        :type exit_config: str

        :param pattern: Pattern to terminate reading of channel
        :type pattern: str
        &#34;&#34;&#34;
        output = &#34;&#34;
        if self.check_config_mode():
            self.write_channel(self.normalize_cmd(exit_config))
            # Make sure you read until you detect the command echo (avoid getting out of sync)
            if self.global_cmd_verify is not False:
                output += self.read_until_pattern(
                    pattern=re.escape(exit_config.strip())
                )
            if pattern:
                output += self.read_until_pattern(pattern=pattern)
            else:
                output += self.read_until_prompt(read_entire_line=True)
            if self.check_config_mode():
                raise ValueError(&#34;Failed to exit configuration mode&#34;)
        log.debug(f&#34;exit_config_mode: {output}&#34;)
        return output

    def send_config_from_file(
        self, config_file: Union[str, bytes, &#34;PathLike[Any]&#34;], **kwargs: Any
    ) -&gt; str:
        &#34;&#34;&#34;
        Send configuration commands down the SSH channel from a file.

        The file is processed line-by-line and each command is sent down the
        SSH channel.

        **kwargs are passed to send_config_set method.

        :param config_file: Path to configuration file to be sent to the device

        :param kwargs: params to be sent to send_config_set method
        &#34;&#34;&#34;
        with io.open(config_file, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as cfg_file:
            commands = cfg_file.readlines()
        return self.send_config_set(commands, **kwargs)

    def send_config_set(
        self,
        config_commands: Union[str, Sequence[str], Iterator[str], TextIO, None] = None,
        *,
        exit_config_mode: bool = True,
        read_timeout: Optional[float] = None,
        delay_factor: Optional[float] = None,
        max_loops: Optional[int] = None,
        strip_prompt: bool = False,
        strip_command: bool = False,
        config_mode_command: Optional[str] = None,
        cmd_verify: bool = True,
        enter_config_mode: bool = True,
        error_pattern: str = &#34;&#34;,
        terminator: str = r&#34;#&#34;,
        bypass_commands: Optional[str] = None,
    ) -&gt; str:
        &#34;&#34;&#34;
        Send configuration commands down the SSH channel.

        config_commands is an iterable containing all of the configuration commands.
        The commands will be executed one after the other.

        Automatically exits/enters configuration mode.

        :param config_commands: Multiple configuration commands to be sent to the device

        :param exit_config_mode: Determines whether or not to exit config mode after complete

        :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        :param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        :param strip_prompt: Determines whether or not to strip the prompt

        :param strip_command: Determines whether or not to strip the command

        :param read_timeout: Absolute timer to send to read_channel_timing. Should be rarely needed.

        :param config_mode_command: The command to enter into config mode

        :param cmd_verify: Whether or not to verify command echo for each command in config_set

        :param enter_config_mode: Do you enter config mode before sending config commands

        :param error_pattern: Regular expression pattern to detect config errors in the
        output.

        :param terminator: Regular expression pattern to use as an alternate terminator in certain
        situations.

        :param bypass_commands: Regular expression pattern indicating configuration commands
        where cmd_verify is automatically disabled.
        &#34;&#34;&#34;

        if self.global_cmd_verify is not None:
            cmd_verify = self.global_cmd_verify

        if delay_factor is not None or max_loops is not None:
            warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)

            # Calculate an equivalent read_timeout (if using old settings)
            # Eliminate in Netmiko 5.x
            if read_timeout is None:
                max_loops = 150 if max_loops is None else max_loops
                delay_factor = 1.0 if delay_factor is None else delay_factor

                # If delay_factor has been set, then look at global_delay_factor
                delay_factor = self.select_delay_factor(delay_factor)

                read_timeout = calc_old_timeout(
                    max_loops=max_loops, delay_factor=delay_factor, loop_delay=0.1
                )

        if delay_factor is None:
            delay_factor = self.select_delay_factor(0)
        else:
            delay_factor = self.select_delay_factor(delay_factor)

        if read_timeout is None:
            read_timeout = 15
        else:
            read_timeout = read_timeout

        if config_commands is None:
            return &#34;&#34;
        elif isinstance(config_commands, str):
            config_commands = (config_commands,)

        if not hasattr(config_commands, &#34;__iter__&#34;):
            raise ValueError(&#34;Invalid argument passed into send_config_set&#34;)

        if bypass_commands is None:
            # Commands where cmd_verify is automatically disabled reg-ex logical-or
            bypass_commands = r&#34;^banner .*$&#34;

        # Set bypass_commands=&#34;&#34; to force no-bypass (usually for testing)
        bypass_detected = False
        if bypass_commands:
            # Make a copy of the iterator
            config_commands, config_commands_tmp = itertools.tee(config_commands, 2)
            bypass_detected = any(
                [True for cmd in config_commands_tmp if re.search(bypass_commands, cmd)]
            )
        if bypass_detected:
            cmd_verify = False

        # Send config commands
        output = &#34;&#34;
        if enter_config_mode:
            if config_mode_command:
                output += self.config_mode(config_mode_command)
            else:
                output += self.config_mode()

        # Perform output gathering line-by-line (legacy way)
        if self.fast_cli and self._legacy_mode and not error_pattern:
            for cmd in config_commands:
                self.write_channel(self.normalize_cmd(cmd))
            # Gather output
            output += self.read_channel_timing(read_timeout=read_timeout)

        elif not cmd_verify:
            for cmd in config_commands:
                self.write_channel(self.normalize_cmd(cmd))
                time.sleep(delay_factor * 0.05)

                # Gather the output incrementally due to error_pattern requirements
                if error_pattern:
                    output += self.read_channel_timing(read_timeout=read_timeout)
                    if re.search(error_pattern, output, flags=re.M):
                        msg = f&#34;Invalid input detected at command: {cmd}&#34;
                        raise ConfigInvalidException(msg)

            # Standard output gathering (no error_pattern)
            if not error_pattern:
                output += self.read_channel_timing(read_timeout=read_timeout)

        else:
            for cmd in config_commands:
                self.write_channel(self.normalize_cmd(cmd))

                # Make sure command is echoed
                output += self.read_until_pattern(pattern=re.escape(cmd.strip()))

                # Read until next prompt or terminator (#); the .*$ forces read of entire line
                pattern = f&#34;(?:{re.escape(self.base_prompt)}.*$|{terminator}.*$)&#34;
                output += self.read_until_pattern(pattern=pattern, re_flags=re.M)

                if error_pattern:
                    if re.search(error_pattern, output, flags=re.M):
                        msg = f&#34;Invalid input detected at command: {cmd}&#34;
                        raise ConfigInvalidException(msg)

        if exit_config_mode:
            output += self.exit_config_mode()
        output = self._sanitize_output(output)
        log.debug(f&#34;{output}&#34;)
        return output

    def strip_ansi_escape_codes(self, string_buffer: str) -&gt; str:
        &#34;&#34;&#34;
        Remove any ANSI (VT100) ESC codes from the output

        http://en.wikipedia.org/wiki/ANSI_escape_code

        Note: this does not capture ALL possible ANSI Escape Codes only the ones
        I have encountered

        Current codes that are filtered:
        ESC = &#39;\x1b&#39; or chr(27)
        ESC = is the escape character [^ in hex (&#39;\x1b&#39;)
        ESC[24;27H   Position cursor
        ESC[?25h     Show the cursor
        ESC[E        Next line (HP does ESC-E)
        ESC[K        Erase line from cursor to the end of line
        ESC[2K       Erase entire line
        ESC[1;24r    Enable scrolling from start to row end
        ESC[?6l      Reset mode screen with options 640 x 200 monochrome (graphics)
        ESC[?7l      Disable line wrapping
        ESC[2J       Code erase display
        ESC[00;32m   Color Green (30 to 37 are different colors)
        ESC[6n       Get cursor position
        ESC[1D       Move cursor position leftward by x characters (1 in this case)
        ESC[9999B    Move cursor down N-lines (very large value is attempt to move to the
                     very bottom of the screen).

        HP ProCurve and Cisco SG300 require this (possible others).

        :param string_buffer: The string to be processed to remove ANSI escape codes
        :type string_buffer: str
        &#34;&#34;&#34;  # noqa

        code_position_cursor = chr(27) + r&#34;\[\d+;\d+H&#34;
        code_show_cursor = chr(27) + r&#34;\[\?25h&#34;
        code_next_line = chr(27) + r&#34;E&#34;
        code_erase_line_end = chr(27) + r&#34;\[K&#34;
        code_erase_line = chr(27) + r&#34;\[2K&#34;
        code_erase_start_line = chr(27) + r&#34;\[K&#34;
        code_enable_scroll = chr(27) + r&#34;\[\d+;\d+r&#34;
        code_insert_line = chr(27) + r&#34;\[(\d+)L&#34;
        code_carriage_return = chr(27) + r&#34;\[1M&#34;
        code_disable_line_wrapping = chr(27) + r&#34;\[\?7l&#34;
        code_reset_mode_screen_options = chr(27) + r&#34;\[\?\d+l&#34;
        code_reset_graphics_mode = chr(27) + r&#34;\[00m&#34;
        code_erase_display = chr(27) + r&#34;\[2J&#34;
        code_erase_display_0 = chr(27) + r&#34;\[J&#34;
        code_graphics_mode = chr(27) + r&#34;\[\dm&#34;
        code_graphics_mode1 = chr(27) + r&#34;\[\d\d;\d\dm&#34;
        code_graphics_mode2 = chr(27) + r&#34;\[\d\d;\d\d;\d\dm&#34;
        code_graphics_mode3 = chr(27) + r&#34;\[(3|4)\dm&#34;
        code_graphics_mode4 = chr(27) + r&#34;\[(9|10)[0-7]m&#34;
        code_get_cursor_position = chr(27) + r&#34;\[6n&#34;
        code_cursor_position = chr(27) + r&#34;\[m&#34;
        code_attrs_off = chr(27) + r&#34;\[0m&#34;
        code_reverse = chr(27) + r&#34;\[7m&#34;
        code_cursor_left = chr(27) + r&#34;\[\d+D&#34;
        code_cursor_forward = chr(27) + r&#34;\[\d*C&#34;
        code_cursor_up = chr(27) + r&#34;\[\d*A&#34;
        code_cursor_down = chr(27) + r&#34;\[\d*B&#34;
        code_wrap_around = chr(27) + r&#34;\[\?7h&#34;
        code_bracketed_paste_mode = chr(27) + r&#34;\[\?2004h&#34;

        code_set = [
            code_position_cursor,
            code_show_cursor,
            code_erase_line,
            code_enable_scroll,
            code_erase_start_line,
            code_carriage_return,
            code_disable_line_wrapping,
            code_erase_line_end,
            code_reset_mode_screen_options,
            code_reset_graphics_mode,
            code_erase_display,
            code_graphics_mode,
            code_graphics_mode1,
            code_graphics_mode2,
            code_graphics_mode3,
            code_graphics_mode4,
            code_get_cursor_position,
            code_cursor_position,
            code_erase_display,
            code_erase_display_0,
            code_attrs_off,
            code_reverse,
            code_cursor_left,
            code_cursor_up,
            code_cursor_down,
            code_cursor_forward,
            code_wrap_around,
            code_bracketed_paste_mode,
        ]

        output = string_buffer
        for ansi_esc_code in code_set:
            output = re.sub(ansi_esc_code, &#34;&#34;, output)

        # CODE_NEXT_LINE must substitute with return
        output = re.sub(code_next_line, self.RETURN, output)

        # Aruba and ProCurve switches can use code_insert_line for &lt;enter&gt;
        insert_line_match = re.search(code_insert_line, output)
        if insert_line_match:
            # Substitute each insert_line with a new &lt;enter&gt;
            count = int(insert_line_match.group(1))
            output = re.sub(code_insert_line, count * self.RETURN, output)

        return output

    def cleanup(self, command: str = &#34;&#34;) -&gt; None:
        &#34;&#34;&#34;Logout of the session on the network device plus any additional cleanup.&#34;&#34;&#34;
        pass

    def paramiko_cleanup(self) -&gt; None:
        &#34;&#34;&#34;Cleanup Paramiko to try to gracefully handle SSH session ending.&#34;&#34;&#34;
        if self.remote_conn_pre is not None:
            self.remote_conn_pre.close()
        del self.remote_conn_pre

    def disconnect(self) -&gt; None:
        &#34;&#34;&#34;Try to gracefully close the session.&#34;&#34;&#34;
        try:
            self.cleanup()
        except Exception:
            # Keep going on cleanup process even if exceptions
            pass

        try:
            if self.protocol == &#34;ssh&#34;:
                self.paramiko_cleanup()
            elif self.protocol == &#34;telnet&#34;:
                assert isinstance(self.remote_conn, telnetlib.Telnet)
                self.remote_conn.close()
            elif self.protocol == &#34;serial&#34;:
                assert isinstance(self.remote_conn, serial.Serial)
                self.remote_conn.close()
        except Exception:
            # There have been race conditions observed on disconnect.
            pass
        finally:
            self.remote_conn_pre = None
            self.remote_conn = None
            if self.session_log:
                self.session_log.close()

    def commit(self) -&gt; str:
        &#34;&#34;&#34;Commit method for platforms that support this.&#34;&#34;&#34;
        raise AttributeError(&#34;Network device does not support &#39;commit()&#39; method&#34;)

    def save_config(
        self, cmd: str = &#34;&#34;, confirm: bool = False, confirm_response: str = &#34;&#34;
    ) -&gt; str:
        &#34;&#34;&#34;Not Implemented&#34;&#34;&#34;
        raise NotImplementedError

    def run_ttp(
        self,
        template: Union[str, bytes, &#34;PathLike[Any]&#34;],
        res_kwargs: Optional[Dict[str, Any]] = None,
        **kwargs: Any,
    ) -&gt; Any:
        &#34;&#34;&#34;
        Run TTP template parsing by using input parameters to collect
        devices output.

        :param template: template content, OS path to template or reference
            to template within TTP templates collection in
            ttp://path/to/template.txt format

        :param res_kwargs: ``**res_kwargs`` arguments to pass to TTP result method

        :param kwargs: any other ``**kwargs`` to use for TTP object instantiation

        TTP template must have inputs defined together with below parameters.

        :param method: name of Netmiko connection object method to call, default ``send_command``

        :param kwargs: Netmiko connection object method arguments

        :param commands: list of commands to collect

        Inputs&#39; load could be of one of the supported formats and controlled by input&#39;s ``load``
        attribute, supported values - python, yaml or json. For each input output collected
        from device and parsed accordingly.
        &#34;&#34;&#34;
        if res_kwargs is None:
            res_kwargs = {}
        return run_ttp_template(
            connection=self, template=template, res_kwargs=res_kwargs, **kwargs
        )</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="netmiko.audiocode.audiocode_ssh.AudiocodeBase" href="audiocode/audiocode_ssh.html#netmiko.audiocode.audiocode_ssh.AudiocodeBase">AudiocodeBase</a></li>
<li><a title="netmiko.base_connection.TelnetConnection" href="base_connection.html#netmiko.base_connection.TelnetConnection">TelnetConnection</a></li>
<li><a title="netmiko.checkpoint.checkpoint_gaia_ssh.CheckPointGaiaSSH" href="checkpoint/checkpoint_gaia_ssh.html#netmiko.checkpoint.checkpoint_gaia_ssh.CheckPointGaiaSSH">CheckPointGaiaSSH</a></li>
<li><a title="netmiko.ciena.ciena_saos.CienaSaosBase" href="ciena/ciena_saos.html#netmiko.ciena.ciena_saos.CienaSaosBase">CienaSaosBase</a></li>
<li><a title="netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH" href="cisco/cisco_wlc_ssh.html#netmiko.cisco.cisco_wlc_ssh.CiscoWlcSSH">CiscoWlcSSH</a></li>
<li><a title="netmiko.cisco_base_connection.CiscoBaseConnection" href="cisco_base_connection.html#netmiko.cisco_base_connection.CiscoBaseConnection">CiscoBaseConnection</a></li>
<li><a title="netmiko.citrix.netscaler_ssh.NetscalerSSH" href="citrix/netscaler_ssh.html#netmiko.citrix.netscaler_ssh.NetscalerSSH">NetscalerSSH</a></li>
<li><a title="netmiko.dell.dell_isilon_ssh.DellIsilonSSH" href="dell/dell_isilon_ssh.html#netmiko.dell.dell_isilon_ssh.DellIsilonSSH">DellIsilonSSH</a></li>
<li><a title="netmiko.ericsson.ericsson_ipos.EricssonIposSSH" href="ericsson/ericsson_ipos.html#netmiko.ericsson.ericsson_ipos.EricssonIposSSH">EricssonIposSSH</a></li>
<li><a title="netmiko.f5.f5_tmsh_ssh.F5TmshSSH" href="f5/f5_tmsh_ssh.html#netmiko.f5.f5_tmsh_ssh.F5TmshSSH">F5TmshSSH</a></li>
<li><a title="netmiko.flexvnf.flexvnf_ssh.FlexvnfSSH" href="flexvnf/flexvnf_ssh.html#netmiko.flexvnf.flexvnf_ssh.FlexvnfSSH">FlexvnfSSH</a></li>
<li><a title="netmiko.juniper.juniper.JuniperBase" href="juniper/juniper.html#netmiko.juniper.juniper.JuniperBase">JuniperBase</a></li>
<li><a title="netmiko.juniper.juniper_screenos.JuniperScreenOsSSH" href="juniper/juniper_screenos.html#netmiko.juniper.juniper_screenos.JuniperScreenOsSSH">JuniperScreenOsSSH</a></li>
<li><a title="netmiko.netapp.netapp_cdot_ssh.NetAppcDotSSH" href="netapp/netapp_cdot_ssh.html#netmiko.netapp.netapp_cdot_ssh.NetAppcDotSSH">NetAppcDotSSH</a></li>
<li><a title="netmiko.nokia.nokia_srl.NokiaSrlSSH" href="nokia/nokia_srl.html#netmiko.nokia.nokia_srl.NokiaSrlSSH">NokiaSrlSSH</a></li>
<li><a title="netmiko.nokia.nokia_sros.NokiaSros" href="nokia/nokia_sros.html#netmiko.nokia.nokia_sros.NokiaSros">NokiaSros</a></li>
<li><a title="netmiko.paloalto.paloalto_panos.PaloAltoPanosBase" href="paloalto/paloalto_panos.html#netmiko.paloalto.paloalto_panos.PaloAltoPanosBase">PaloAltoPanosBase</a></li>
<li><a title="netmiko.pluribus.pluribus_ssh.PluribusSSH" href="pluribus/pluribus_ssh.html#netmiko.pluribus.pluribus_ssh.PluribusSSH">PluribusSSH</a></li>
<li><a title="netmiko.rad.rad_etx.RadETXBase" href="rad/rad_etx.html#netmiko.rad.rad_etx.RadETXBase">RadETXBase</a></li>
<li><a title="netmiko.terminal_server.terminal_server.TerminalServer" href="terminal_server/terminal_server.html#netmiko.terminal_server.terminal_server.TerminalServer">TerminalServer</a></li>
<li><a title="netmiko.watchguard.fireware_ssh.WatchguardFirewareSSH" href="watchguard/fireware_ssh.html#netmiko.watchguard.fireware_ssh.WatchguardFirewareSSH">WatchguardFirewareSSH</a></li>
<li><a title="netmiko.yamaha.yamaha.YamahaBase" href="yamaha/yamaha.html#netmiko.yamaha.yamaha.YamahaBase">YamahaBase</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="netmiko.BaseConnection.strip_backspaces"><code class="name flex">
<span>def <span class="ident">strip_backspaces</span></span>(<span>output: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Strip any backspace characters out of the output.</p>
<p>:param output: Output obtained from a remote network device.
:type output: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def strip_backspaces(output: str) -&gt; str:
    &#34;&#34;&#34;Strip any backspace characters out of the output.

    :param output: Output obtained from a remote network device.
    :type output: str
    &#34;&#34;&#34;
    backspace_char = &#34;\x08&#34;
    return output.replace(backspace_char, &#34;&#34;)</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="netmiko.BaseConnection.check_config_mode"><code class="name flex">
<span>def <span class="ident">check_config_mode</span></span>(<span>self, check_string: str = '', pattern: str = '', force_regex: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the device is in configuration mode or not.</p>
<p>:param check_string: Identification of configuration mode from the device
:type check_string: str</p>
<p>:param pattern: Pattern to terminate reading of channel
:type pattern: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_config_mode(
    self, check_string: str = &#34;&#34;, pattern: str = &#34;&#34;, force_regex: bool = False
) -&gt; bool:
    &#34;&#34;&#34;Checks if the device is in configuration mode or not.

    :param check_string: Identification of configuration mode from the device
    :type check_string: str

    :param pattern: Pattern to terminate reading of channel
    :type pattern: str
    &#34;&#34;&#34;
    self.write_channel(self.RETURN)
    # You can encounter an issue here (on router name changes) prefer delay-based solution
    if not pattern:
        output = self.read_channel_timing(read_timeout=10.0)
    else:
        output = self.read_until_pattern(pattern=pattern)

    if force_regex:
        return bool(re.search(check_string, output))
    else:
        return check_string in output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.check_enable_mode"><code class="name flex">
<span>def <span class="ident">check_enable_mode</span></span>(<span>self, check_string: str = '') ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Check if in enable mode. Return boolean.</p>
<p>:param check_string: Identification of privilege mode from device
:type check_string: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_enable_mode(self, check_string: str = &#34;&#34;) -&gt; bool:
    &#34;&#34;&#34;Check if in enable mode. Return boolean.

    :param check_string: Identification of privilege mode from device
    :type check_string: str
    &#34;&#34;&#34;
    self.write_channel(self.RETURN)
    output = self.read_until_prompt(read_entire_line=True)
    return check_string in output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self, command: str = '') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Logout of the session on the network device plus any additional cleanup.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self, command: str = &#34;&#34;) -&gt; None:
    &#34;&#34;&#34;Logout of the session on the network device plus any additional cleanup.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.clear_buffer"><code class="name flex">
<span>def <span class="ident">clear_buffer</span></span>(<span>self, backoff: bool = True, backoff_max: float = 3.0, delay_factor: Optional[float] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Read any data available in the channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def clear_buffer(
    self,
    backoff: bool = True,
    backoff_max: float = 3.0,
    delay_factor: Optional[float] = None,
) -&gt; str:
    &#34;&#34;&#34;Read any data available in the channel.&#34;&#34;&#34;

    if delay_factor is None:
        delay_factor = self.global_delay_factor
    sleep_time = 0.1 * delay_factor

    output = &#34;&#34;
    for _ in range(10):
        time.sleep(sleep_time)
        data = self.read_channel()
        data = self.strip_ansi_escape_codes(data)
        output += data
        if not data:
            break
        # Double sleep time each time we detect data
        log.debug(&#34;Clear buffer detects data in the channel&#34;)
        if backoff:
            sleep_time *= 2
            sleep_time = backoff_max if sleep_time &gt;= backoff_max else sleep_time
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.command_echo_read"><code class="name flex">
<span>def <span class="ident">command_echo_read</span></span>(<span>self, cmd: str, read_timeout: float) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def command_echo_read(self, cmd: str, read_timeout: float) -&gt; str:

    # Make sure you read until you detect the command echo (avoid getting out of sync)
    new_data = self.read_until_pattern(
        pattern=re.escape(cmd), read_timeout=read_timeout
    )

    # There can be echoed prompts that haven&#39;t been cleared before the cmd echo
    # this can later mess up the trailing prompt pattern detection. Clear this out.
    lines = new_data.split(cmd)
    if len(lines) == 2:
        # lines[-1] should realistically just be the null string
        new_data = f&#34;{cmd}{lines[-1]}&#34;
    else:
        # cmd exists in the output multiple times? Just retain the original output
        pass
    return new_data</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Commit method for platforms that support this.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(self) -&gt; str:
    &#34;&#34;&#34;Commit method for platforms that support this.&#34;&#34;&#34;
    raise AttributeError(&#34;Network device does not support &#39;commit()&#39; method&#34;)</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.config_mode"><code class="name flex">
<span>def <span class="ident">config_mode</span></span>(<span>self, config_command: str = '', pattern: str = '', re_flags: int = 0) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Enter into config_mode.</p>
<p>:param config_command: Configuration command to send to the device
:type config_command: str</p>
<p>:param pattern: Pattern to terminate reading of channel
:type pattern: str</p>
<p>:param re_flags: Regular expression flags
:type re_flags: RegexFlag</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_mode(
    self, config_command: str = &#34;&#34;, pattern: str = &#34;&#34;, re_flags: int = 0
) -&gt; str:
    &#34;&#34;&#34;Enter into config_mode.

    :param config_command: Configuration command to send to the device
    :type config_command: str

    :param pattern: Pattern to terminate reading of channel
    :type pattern: str

    :param re_flags: Regular expression flags
    :type re_flags: RegexFlag
    &#34;&#34;&#34;
    output = &#34;&#34;
    if not self.check_config_mode():
        self.write_channel(self.normalize_cmd(config_command))
        # Make sure you read until you detect the command echo (avoid getting out of sync)
        if self.global_cmd_verify is not False:
            output += self.read_until_pattern(
                pattern=re.escape(config_command.strip())
            )
        if pattern:
            output += self.read_until_pattern(pattern=pattern, re_flags=re_flags)
        else:
            output += self.read_until_prompt(read_entire_line=True)
        if not self.check_config_mode():
            raise ValueError(&#34;Failed to enter configuration mode.&#34;)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.disable_paging"><code class="name flex">
<span>def <span class="ident">disable_paging</span></span>(<span>self, command: str = 'terminal length 0', delay_factor: Optional[float] = None, cmd_verify: bool = True, pattern: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Disable paging default to a Cisco CLI method.</p>
<p>:param command: Device command to disable pagination of output</p>
<p>:param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disable_paging(
    self,
    command: str = &#34;terminal length 0&#34;,
    delay_factor: Optional[float] = None,
    cmd_verify: bool = True,
    pattern: Optional[str] = None,
) -&gt; str:
    &#34;&#34;&#34;Disable paging default to a Cisco CLI method.

    :param command: Device command to disable pagination of output

    :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.
    &#34;&#34;&#34;
    if delay_factor is not None:
        warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)

    command = self.normalize_cmd(command)
    log.debug(&#34;In disable_paging&#34;)
    log.debug(f&#34;Command: {command}&#34;)
    self.write_channel(command)
    # Make sure you read until you detect the command echo (avoid getting out of sync)
    if cmd_verify and self.global_cmd_verify is not False:
        output = self.read_until_pattern(
            pattern=re.escape(command.strip()), read_timeout=20
        )
    elif pattern:
        output = self.read_until_pattern(pattern=pattern, read_timeout=20)
    else:
        output = self.read_until_prompt()
    log.debug(f&#34;{output}&#34;)
    log.debug(&#34;Exiting disable_paging&#34;)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.disconnect"><code class="name flex">
<span>def <span class="ident">disconnect</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Try to gracefully close the session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def disconnect(self) -&gt; None:
    &#34;&#34;&#34;Try to gracefully close the session.&#34;&#34;&#34;
    try:
        self.cleanup()
    except Exception:
        # Keep going on cleanup process even if exceptions
        pass

    try:
        if self.protocol == &#34;ssh&#34;:
            self.paramiko_cleanup()
        elif self.protocol == &#34;telnet&#34;:
            assert isinstance(self.remote_conn, telnetlib.Telnet)
            self.remote_conn.close()
        elif self.protocol == &#34;serial&#34;:
            assert isinstance(self.remote_conn, serial.Serial)
            self.remote_conn.close()
    except Exception:
        # There have been race conditions observed on disconnect.
        pass
    finally:
        self.remote_conn_pre = None
        self.remote_conn = None
        if self.session_log:
            self.session_log.close()</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.enable"><code class="name flex">
<span>def <span class="ident">enable</span></span>(<span>self, cmd: str = '', pattern: str = 'ssword', enable_pattern: Optional[str] = None, re_flags: int = re.IGNORECASE) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Enter enable mode.</p>
<p>:param cmd: Device command to enter enable mode</p>
<p>:param pattern: pattern to search for indicating device is waiting for password</p>
<p>:param enable_pattern: pattern indicating you have entered enable mode</p>
<p>:param re_flags: Regular expression flags used in conjunction with pattern</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enable(
    self,
    cmd: str = &#34;&#34;,
    pattern: str = &#34;ssword&#34;,
    enable_pattern: Optional[str] = None,
    re_flags: int = re.IGNORECASE,
) -&gt; str:
    &#34;&#34;&#34;Enter enable mode.

    :param cmd: Device command to enter enable mode

    :param pattern: pattern to search for indicating device is waiting for password

    :param enable_pattern: pattern indicating you have entered enable mode

    :param re_flags: Regular expression flags used in conjunction with pattern
    &#34;&#34;&#34;
    output = &#34;&#34;
    msg = (
        &#34;Failed to enter enable mode. Please ensure you pass &#34;
        &#34;the &#39;secret&#39; argument to ConnectHandler.&#34;
    )

    # Check if in enable mode
    if not self.check_enable_mode():
        # Send &#34;enable&#34; mode command
        self.write_channel(self.normalize_cmd(cmd))
        try:
            # Read the command echo
            end_data = &#34;&#34;
            if self.global_cmd_verify is not False:
                output += self.read_until_pattern(pattern=re.escape(cmd.strip()))
                end_data = output.split(cmd.strip())[-1]

            # Search for trailing prompt or password pattern
            if pattern not in output and self.base_prompt not in end_data:
                output += self.read_until_prompt_or_pattern(
                    pattern=pattern, re_flags=re_flags
                )
            # Send the &#34;secret&#34; in response to password pattern
            if re.search(pattern, output):
                self.write_channel(self.normalize_cmd(self.secret))
                output += self.read_until_prompt()

            # Search for terminating pattern if defined
            if enable_pattern and not re.search(enable_pattern, output):
                output += self.read_until_pattern(pattern=enable_pattern)
            else:
                if not self.check_enable_mode():
                    raise ValueError(msg)
        except NetmikoTimeoutException:
            raise ValueError(msg)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.establish_connection"><code class="name flex">
<span>def <span class="ident">establish_connection</span></span>(<span>self, width: int = 511, height: int = 1000) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Establish SSH connection to the network device</p>
<p>Timeout will generate a NetmikoTimeoutException
Authentication failure will generate a NetmikoAuthenticationException</p>
<p>:param width: Specified width of the VT100 terminal window (default: 511)
:type width: int</p>
<p>:param height: Specified height of the VT100 terminal window (default: 1000)
:type height: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def establish_connection(self, width: int = 511, height: int = 1000) -&gt; None:
        &#34;&#34;&#34;Establish SSH connection to the network device

        Timeout will generate a NetmikoTimeoutException
        Authentication failure will generate a NetmikoAuthenticationException

        :param width: Specified width of the VT100 terminal window (default: 511)
        :type width: int

        :param height: Specified height of the VT100 terminal window (default: 1000)
        :type height: int
        &#34;&#34;&#34;
        self.channel: Channel
        if self.protocol == &#34;telnet&#34;:
            self.remote_conn = telnetlib.Telnet(
                self.host, port=self.port, timeout=self.timeout
            )
            # Migrating communication to channel class
            self.channel = TelnetChannel(conn=self.remote_conn, encoding=self.encoding)
            self.telnet_login()
        elif self.protocol == &#34;serial&#34;:
            self.remote_conn = serial.Serial(**self.serial_settings)
            self.channel = SerialChannel(conn=self.remote_conn, encoding=self.encoding)
            self.serial_login()
        elif self.protocol == &#34;ssh&#34;:
            ssh_connect_params = self._connect_params_dict()
            self.remote_conn_pre: Optional[paramiko.SSHClient]
            self.remote_conn_pre = self._build_ssh_client()

            # initiate SSH connection
            try:
                self.remote_conn_pre.connect(**ssh_connect_params)
            except socket.error as conn_error:
                self.paramiko_cleanup()
                msg = f&#34;&#34;&#34;TCP connection to device failed.

Common causes of this problem are:
1. Incorrect hostname or IP address.
2. Wrong TCP port.
3. Intermediate firewall blocking access.

Device settings: {self.device_type} {self.host}:{self.port}

&#34;&#34;&#34;

                # Handle DNS failures separately
                if &#34;Name or service not known&#34; in str(conn_error):
                    msg = (
                        f&#34;DNS failure--the hostname you provided was not resolvable &#34;
                        f&#34;in DNS: {self.host}:{self.port}&#34;
                    )

                msg = msg.lstrip()
                raise NetmikoTimeoutException(msg)
            except paramiko.ssh_exception.AuthenticationException as auth_err:
                self.paramiko_cleanup()
                msg = f&#34;&#34;&#34;Authentication to device failed.

Common causes of this problem are:
1. Invalid username and password
2. Incorrect SSH-key file
3. Connecting to the wrong device

Device settings: {self.device_type} {self.host}:{self.port}

&#34;&#34;&#34;

                msg += self.RETURN + str(auth_err)
                raise NetmikoAuthenticationException(msg)
            except paramiko.ssh_exception.SSHException as e:
                self.paramiko_cleanup()
                if &#34;No existing session&#34; in str(e):
                    msg = (
                        &#34;Paramiko: &#39;No existing session&#39; error: &#34;
                        &#34;try increasing &#39;conn_timeout&#39; to 15 seconds or larger.&#34;
                    )
                    raise NetmikoTimeoutException(msg)
                else:
                    msg = f&#34;&#34;&#34;
A paramiko SSHException occurred during connection creation:

{str(e)}

&#34;&#34;&#34;
                    raise NetmikoTimeoutException(msg)

            if self.verbose:
                print(f&#34;SSH connection established to {self.host}:{self.port}&#34;)

            # Use invoke_shell to establish an &#39;interactive session&#39;
            self.remote_conn = self.remote_conn_pre.invoke_shell(
                term=&#34;vt100&#34;, width=width, height=height
            )

            self.remote_conn.settimeout(self.blocking_timeout)
            if self.keepalive:
                assert isinstance(self.remote_conn.transport, paramiko.Transport)
                self.remote_conn.transport.set_keepalive(self.keepalive)

            # Migrating communication to channel class
            self.channel = SSHChannel(conn=self.remote_conn, encoding=self.encoding)

            self.special_login_handler()
            if self.verbose:
                print(&#34;Interactive SSH session established&#34;)

        return None</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.exit_config_mode"><code class="name flex">
<span>def <span class="ident">exit_config_mode</span></span>(<span>self, exit_config: str = '', pattern: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Exit from configuration mode.</p>
<p>:param exit_config: Command to exit configuration mode
:type exit_config: str</p>
<p>:param pattern: Pattern to terminate reading of channel
:type pattern: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_config_mode(self, exit_config: str = &#34;&#34;, pattern: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Exit from configuration mode.

    :param exit_config: Command to exit configuration mode
    :type exit_config: str

    :param pattern: Pattern to terminate reading of channel
    :type pattern: str
    &#34;&#34;&#34;
    output = &#34;&#34;
    if self.check_config_mode():
        self.write_channel(self.normalize_cmd(exit_config))
        # Make sure you read until you detect the command echo (avoid getting out of sync)
        if self.global_cmd_verify is not False:
            output += self.read_until_pattern(
                pattern=re.escape(exit_config.strip())
            )
        if pattern:
            output += self.read_until_pattern(pattern=pattern)
        else:
            output += self.read_until_prompt(read_entire_line=True)
        if self.check_config_mode():
            raise ValueError(&#34;Failed to exit configuration mode&#34;)
    log.debug(f&#34;exit_config_mode: {output}&#34;)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.exit_enable_mode"><code class="name flex">
<span>def <span class="ident">exit_enable_mode</span></span>(<span>self, exit_command: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Exit enable mode.</p>
<p>:param exit_command: Command that exits the session from privileged mode
:type exit_command: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_enable_mode(self, exit_command: str = &#34;&#34;) -&gt; str:
    &#34;&#34;&#34;Exit enable mode.

    :param exit_command: Command that exits the session from privileged mode
    :type exit_command: str
    &#34;&#34;&#34;
    output = &#34;&#34;
    if self.check_enable_mode():
        self.write_channel(self.normalize_cmd(exit_command))
        output += self.read_until_prompt()
        if self.check_enable_mode():
            raise ValueError(&#34;Failed to exit enable mode.&#34;)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.find_prompt"><code class="name flex">
<span>def <span class="ident">find_prompt</span></span>(<span>self, delay_factor: float = 1.0, pattern: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Finds the current network device prompt, last line only.</p>
<p>:param delay_factor: See <strong>init</strong>: global_delay_factor
:type delay_factor: int</p>
<p>:param pattern: Regular expression pattern to determine whether prompt is valid</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def find_prompt(
    self, delay_factor: float = 1.0, pattern: Optional[str] = None
) -&gt; str:
    &#34;&#34;&#34;Finds the current network device prompt, last line only.

    :param delay_factor: See __init__: global_delay_factor
    :type delay_factor: int

    :param pattern: Regular expression pattern to determine whether prompt is valid
    &#34;&#34;&#34;
    delay_factor = self.select_delay_factor(delay_factor)
    sleep_time = delay_factor * 0.25
    self.clear_buffer()
    self.write_channel(self.RETURN)

    if pattern:
        prompt = self.read_until_pattern(pattern=pattern)
    else:
        # Initial read
        time.sleep(sleep_time)
        prompt = self.read_channel().strip()

        count = 0
        while count &lt;= 12 and not prompt:
            if not prompt:
                self.write_channel(self.RETURN)
                time.sleep(sleep_time)
                prompt = self.read_channel().strip()
                if sleep_time &lt;= 3:
                    # Double the sleep_time when it is small
                    sleep_time *= 2
                else:
                    sleep_time += 1
            count += 1

    # If multiple lines in the output take the last line
    prompt = prompt.split(self.RESPONSE_RETURN)[-1]
    prompt = prompt.strip()
    self.clear_buffer()
    if not prompt:
        raise ValueError(f&#34;Unable to find prompt: {prompt}&#34;)
    log.debug(f&#34;[find_prompt()]: prompt is {prompt}&#34;)
    return prompt</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.is_alive"><code class="name flex">
<span>def <span class="ident">is_alive</span></span>(<span>self) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Returns a boolean flag with the state of the connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def is_alive(self) -&gt; bool:
    &#34;&#34;&#34;Returns a boolean flag with the state of the connection.&#34;&#34;&#34;
    null = chr(0)
    if self.remote_conn is None:
        log.error(&#34;Connection is not initialised, is_alive returns False&#34;)
        return False
    if self.protocol == &#34;telnet&#34;:
        try:
            # Try sending IAC + NOP (IAC is telnet way of sending command)
            # IAC = Interpret as Command; it comes before the NOP.
            log.debug(&#34;Sending IAC + NOP&#34;)
            # Need to send multiple times to test connection
            assert isinstance(self.remote_conn, telnetlib.Telnet)
            telnet_socket = self.remote_conn.get_socket()
            telnet_socket.sendall(telnetlib.IAC + telnetlib.NOP)
            telnet_socket.sendall(telnetlib.IAC + telnetlib.NOP)
            telnet_socket.sendall(telnetlib.IAC + telnetlib.NOP)
            return True
        except AttributeError:
            return False
    else:
        # SSH
        try:
            # Try sending ASCII null byte to maintain the connection alive
            log.debug(&#34;Sending the NULL byte&#34;)
            self.write_channel(null)
            assert isinstance(self.remote_conn, paramiko.Channel)
            assert self.remote_conn.transport is not None
            result = self.remote_conn.transport.is_active()
            assert isinstance(result, bool)
            return result
        except (socket.error, EOFError):
            log.error(&#34;Unable to send&#34;, exc_info=True)
            # If unable to send, we can tell for sure that the connection is unusable
            return False
    return False</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.normalize_cmd"><code class="name flex">
<span>def <span class="ident">normalize_cmd</span></span>(<span>self, command: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize CLI commands to have a single trailing newline.</p>
<p>:param command: Command that may require line feed to be normalized
:type command: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_cmd(self, command: str) -&gt; str:
    &#34;&#34;&#34;Normalize CLI commands to have a single trailing newline.

    :param command: Command that may require line feed to be normalized
    :type command: str
    &#34;&#34;&#34;
    command = command.rstrip()
    command += self.RETURN
    return command</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.normalize_linefeeds"><code class="name flex">
<span>def <span class="ident">normalize_linefeeds</span></span>(<span>self, a_string: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Convert `</p>
<p><code>,</code>
<code>, </code></p>
<p><code> to </code>
.`</p>
<pre><code>    :param a_string: A string that may have non-normalized line feeds
        i.e. output returned from device, or a device prompt
    :type a_string: str
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def normalize_linefeeds(self, a_string: str) -&gt; str:
    &#34;&#34;&#34;Convert `\r\r\n`,`\r\n`, `\n\r` to `\n.`

    :param a_string: A string that may have non-normalized line feeds
        i.e. output returned from device, or a device prompt
    :type a_string: str
    &#34;&#34;&#34;
    newline = re.compile(&#34;(\r\r\r\n|\r\r\n|\r\n|\n\r)&#34;)
    a_string = newline.sub(self.RESPONSE_RETURN, a_string)
    if self.RESPONSE_RETURN == &#34;\n&#34;:
        # Convert any remaining \r to \n
        return re.sub(&#34;\r&#34;, self.RESPONSE_RETURN, a_string)
    else:
        return a_string</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.paramiko_cleanup"><code class="name flex">
<span>def <span class="ident">paramiko_cleanup</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Cleanup Paramiko to try to gracefully handle SSH session ending.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def paramiko_cleanup(self) -&gt; None:
    &#34;&#34;&#34;Cleanup Paramiko to try to gracefully handle SSH session ending.&#34;&#34;&#34;
    if self.remote_conn_pre is not None:
        self.remote_conn_pre.close()
    del self.remote_conn_pre</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.read_channel"><code class="name flex">
<span>def <span class="ident">read_channel</span></span>(<span>self) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Generic handler that will read all the data from given channel.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@lock_channel
def read_channel(self) -&gt; str:
    &#34;&#34;&#34;Generic handler that will read all the data from given channel.&#34;&#34;&#34;
    new_data = self.channel.read_channel()
    new_data = self.normalize_linefeeds(new_data)
    if self.ansi_escape_codes:
        new_data = self.strip_ansi_escape_codes(new_data)
    log.debug(f&#34;read_channel: {new_data}&#34;)
    if self.session_log:
        self.session_log.write(new_data)

    # If data had been previously saved to the buffer, the prepend it to output
    # do post read_channel so session_log/log doesn&#39;t record buffered data twice
    if self._read_buffer:
        output = self._read_buffer + new_data
        self._read_buffer = &#34;&#34;
    else:
        output = new_data
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.read_channel_timing"><code class="name flex">
<span>def <span class="ident">read_channel_timing</span></span>(<span>self, last_read: float = 2.0, read_timeout: float = 120.0, delay_factor: Optional[float] = None, max_loops: Optional[int] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Read data on the channel based on timing delays.</p>
<p>General pattern is keep reading until no new data is read.
Once no new data is read wait <code>last_read</code> amount of time (one last read).
As long as no new data, then return data.</p>
<p><code>read_timeout</code> is an absolute timer for how long to keep reading (which presupposes
we are still getting new data).</p>
<p>Setting <code>read_timeout</code> to zero will cause read_channel_timing to never expire based
on an absolute timeout. It will only complete based on timeout based on their being
no new data.</p>
<p>:param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p>
<p>:param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def read_channel_timing(
        self,
        last_read: float = 2.0,
        read_timeout: float = 120.0,
        delay_factor: Optional[float] = None,
        max_loops: Optional[int] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Read data on the channel based on timing delays.

        General pattern is keep reading until no new data is read.
        Once no new data is read wait `last_read` amount of time (one last read).
        As long as no new data, then return data.

        `read_timeout` is an absolute timer for how long to keep reading (which presupposes
        we are still getting new data).

        Setting `read_timeout` to zero will cause read_channel_timing to never expire based
        on an absolute timeout. It will only complete based on timeout based on their being
        no new data.

        :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        :param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.
        &#34;&#34;&#34;

        if delay_factor is not None or max_loops is not None:
            warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)

        if self.read_timeout_override:
            read_timeout = self.read_timeout_override

        # Time to delay in each read loop
        loop_delay = 0.1
        channel_data = &#34;&#34;
        start_time = time.time()

        # Set read_timeout to 0 to never timeout
        while (time.time() - start_time &lt; read_timeout) or (not read_timeout):
            time.sleep(loop_delay)
            new_data = self.read_channel()
            # gather new output
            if new_data:
                channel_data += new_data
            # if we have some output, but nothing new, then do the last read
            elif channel_data != &#34;&#34;:
                # Make sure really done (i.e. no new data)
                time.sleep(last_read)
                new_data = self.read_channel()
                if not new_data:
                    break
                else:
                    channel_data += new_data
        else:
            msg = f&#34;&#34;&#34;\n
read_channel_timing&#39;s absolute timer expired.

The network device was continually outputting data for longer than {read_timeout}
seconds.

If this is expected i.e. the command you are executing is continually emitting
data for a long period of time, then you can set &#39;read_timeout=x&#39; seconds. If
you want Netmiko to keep reading indefinitely (i.e. to only stop when there is
no new data), then you can set &#39;read_timeout=0&#39;.

You can look at the Netmiko session_log or debug log for more information.

&#34;&#34;&#34;
            raise ReadTimeout(msg)
        return channel_data</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.read_until_pattern"><code class="name flex">
<span>def <span class="ident">read_until_pattern</span></span>(<span>self, pattern: str = '', read_timeout: float = 10.0, re_flags: int = 0, max_loops: Optional[int] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Read channel until pattern is detected.</p>
<p>Will return string up to and including pattern.</p>
<p>Returns ReadTimeout if pattern not detected in read_timeout seconds.</p>
<p>:param pattern: Regular expression pattern used to identify that reading is done.</p>
<p>:param read_timeout: maximum time to wait looking for pattern. Will raise ReadTimeout.
A read_timeout value of 0 will cause the loop to never timeout (i.e. it will keep
reading indefinitely until pattern is detected.</p>
<p>:param re_flags: regex flags used in conjunction with pattern (defaults to no flags).</p>
<p>:param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    def read_until_pattern(
        self,
        pattern: str = &#34;&#34;,
        read_timeout: float = 10.0,
        re_flags: int = 0,
        max_loops: Optional[int] = None,
    ) -&gt; str:
        &#34;&#34;&#34;Read channel until pattern is detected.

        Will return string up to and including pattern.

        Returns ReadTimeout if pattern not detected in read_timeout seconds.

        :param pattern: Regular expression pattern used to identify that reading is done.

        :param read_timeout: maximum time to wait looking for pattern. Will raise ReadTimeout.
            A read_timeout value of 0 will cause the loop to never timeout (i.e. it will keep
            reading indefinitely until pattern is detected.

        :param re_flags: regex flags used in conjunction with pattern (defaults to no flags).

        :param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.
        &#34;&#34;&#34;
        if max_loops is not None:
            msg = &#34;&#34;&#34;\n
Netmiko 4.x has deprecated the use of max_loops with read_until_pattern.
You should convert all uses of max_loops over to read_timeout=x
where x is the total number of seconds to wait before timing out.\n&#34;&#34;&#34;
            warnings.warn(msg, DeprecationWarning)

        if self.read_timeout_override:
            read_timeout = self.read_timeout_override

        output = &#34;&#34;
        loop_delay = 0.01
        start_time = time.time()
        # if read_timeout == 0 or 0.0 keep reading indefinitely
        while (time.time() - start_time &lt; read_timeout) or (not read_timeout):
            output += self.read_channel()
            if re.search(pattern, output, flags=re_flags):
                results = re.split(pattern, output, maxsplit=1, flags=re_flags)

                # The string matched by pattern must be retained in the output string.
                # re.split will do this if capturing parenthesis are used.
                if len(results) == 2:
                    # no capturing parenthesis, convert and try again.
                    pattern = f&#34;({pattern})&#34;
                    results = re.split(pattern, output, maxsplit=1, flags=re_flags)

                if len(results) != 3:
                    # well, we tried
                    msg = f&#34;&#34;&#34;Unable to successfully split output based on pattern:
pattern={pattern}
output={repr(output)}
results={results}
&#34;&#34;&#34;
                    raise ReadException(msg)

                # Process such that everything before and including pattern is return.
                # Everything else is retained in the _read_buffer
                output, match_str, buffer = results
                output = output + match_str
                if buffer:
                    self._read_buffer += buffer
                log.debug(f&#34;Pattern found: {pattern} {output}&#34;)
                return output
            time.sleep(loop_delay)

        msg = f&#34;&#34;&#34;\n\nPattern not detected: {repr(pattern)} in output.

Things you might try to fix this:
1. Adjust the regex pattern to better identify the terminating string. Note, in
many situations the pattern is automatically based on the network device&#39;s prompt.
2. Increase the read_timeout to a larger value.

You can also look at the Netmiko session_log or debug log for more information.\n\n&#34;&#34;&#34;
        raise ReadTimeout(msg)</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.read_until_prompt"><code class="name flex">
<span>def <span class="ident">read_until_prompt</span></span>(<span>self, read_timeout: float = 10.0, read_entire_line: bool = False, re_flags: int = 0, max_loops: Optional[int] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Read channel up to and including self.base_prompt.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_until_prompt(
    self,
    read_timeout: float = 10.0,
    read_entire_line: bool = False,
    re_flags: int = 0,
    max_loops: Optional[int] = None,
) -&gt; str:
    &#34;&#34;&#34;Read channel up to and including self.base_prompt.&#34;&#34;&#34;
    pattern = re.escape(self.base_prompt)
    if read_entire_line:
        pattern = f&#34;{pattern}.*&#34;
    return self.read_until_pattern(
        pattern=pattern,
        re_flags=re_flags,
        max_loops=max_loops,
        read_timeout=read_timeout,
    )</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.read_until_prompt_or_pattern"><code class="name flex">
<span>def <span class="ident">read_until_prompt_or_pattern</span></span>(<span>self, pattern: str = '', read_timeout: float = 10.0, read_entire_line: bool = False, re_flags: int = 0, max_loops: Optional[int] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Read until either self.base_prompt or pattern is detected.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def read_until_prompt_or_pattern(
    self,
    pattern: str = &#34;&#34;,
    read_timeout: float = 10.0,
    read_entire_line: bool = False,
    re_flags: int = 0,
    max_loops: Optional[int] = None,
) -&gt; str:
    &#34;&#34;&#34;Read until either self.base_prompt or pattern is detected.&#34;&#34;&#34;
    prompt_pattern = re.escape(self.base_prompt)
    if read_entire_line:
        prompt_pattern = f&#34;{prompt_pattern}.*&#34;
    if pattern:
        combined_pattern = r&#34;(?:{}|{})&#34;.format(prompt_pattern, pattern)
    else:
        combined_pattern = prompt_pattern
    return self.read_until_pattern(
        pattern=combined_pattern,
        re_flags=re_flags,
        max_loops=max_loops,
        read_timeout=read_timeout,
    )</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.run_ttp"><code class="name flex">
<span>def <span class="ident">run_ttp</span></span>(<span>self, template: Union[str, bytes, ForwardRef('PathLike[Any]')], res_kwargs: Optional[Dict[str, Any]] = None, **kwargs: Any) ‑> Any</span>
</code></dt>
<dd>
<div class="desc"><p>Run TTP template parsing by using input parameters to collect
devices output.</p>
<p>:param template: template content, OS path to template or reference
to template within TTP templates collection in
ttp://path/to/template.txt format</p>
<p>:param res_kwargs: <code>**res_kwargs</code> arguments to pass to TTP result method</p>
<p>:param kwargs: any other <code>**kwargs</code> to use for TTP object instantiation</p>
<p>TTP template must have inputs defined together with below parameters.</p>
<p>:param method: name of Netmiko connection object method to call, default <code>send_command</code></p>
<p>:param kwargs: Netmiko connection object method arguments</p>
<p>:param commands: list of commands to collect</p>
<p>Inputs' load could be of one of the supported formats and controlled by input's <code>load</code>
attribute, supported values - python, yaml or json. For each input output collected
from device and parsed accordingly.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def run_ttp(
    self,
    template: Union[str, bytes, &#34;PathLike[Any]&#34;],
    res_kwargs: Optional[Dict[str, Any]] = None,
    **kwargs: Any,
) -&gt; Any:
    &#34;&#34;&#34;
    Run TTP template parsing by using input parameters to collect
    devices output.

    :param template: template content, OS path to template or reference
        to template within TTP templates collection in
        ttp://path/to/template.txt format

    :param res_kwargs: ``**res_kwargs`` arguments to pass to TTP result method

    :param kwargs: any other ``**kwargs`` to use for TTP object instantiation

    TTP template must have inputs defined together with below parameters.

    :param method: name of Netmiko connection object method to call, default ``send_command``

    :param kwargs: Netmiko connection object method arguments

    :param commands: list of commands to collect

    Inputs&#39; load could be of one of the supported formats and controlled by input&#39;s ``load``
    attribute, supported values - python, yaml or json. For each input output collected
    from device and parsed accordingly.
    &#34;&#34;&#34;
    if res_kwargs is None:
        res_kwargs = {}
    return run_ttp_template(
        connection=self, template=template, res_kwargs=res_kwargs, **kwargs
    )</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.save_config"><code class="name flex">
<span>def <span class="ident">save_config</span></span>(<span>self, cmd: str = '', confirm: bool = False, confirm_response: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Not Implemented</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def save_config(
    self, cmd: str = &#34;&#34;, confirm: bool = False, confirm_response: str = &#34;&#34;
) -&gt; str:
    &#34;&#34;&#34;Not Implemented&#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.select_delay_factor"><code class="name flex">
<span>def <span class="ident">select_delay_factor</span></span>(<span>self, delay_factor: float) ‑> float</span>
</code></dt>
<dd>
<div class="desc"><p>Choose the greater of delay_factor or self.global_delay_factor (default).
In fast_cli choose the lesser of delay_factor of self.global_delay_factor.</p>
<p>:param delay_factor: See <strong>init</strong>: global_delay_factor
:type delay_factor: int</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def select_delay_factor(self, delay_factor: float) -&gt; float:
    &#34;&#34;&#34;
    Choose the greater of delay_factor or self.global_delay_factor (default).
    In fast_cli choose the lesser of delay_factor of self.global_delay_factor.

    :param delay_factor: See __init__: global_delay_factor
    :type delay_factor: int
    &#34;&#34;&#34;
    if self.fast_cli:
        if delay_factor and delay_factor &lt;= self.global_delay_factor:
            return delay_factor
        else:
            return self.global_delay_factor
    else:
        if delay_factor &gt;= self.global_delay_factor:
            return delay_factor
        else:
            return self.global_delay_factor</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.send_command"><code class="name flex">
<span>def <span class="ident">send_command</span></span>(<span>self, command_string: str, expect_string: Optional[str] = None, read_timeout: float = 10.0, delay_factor: Optional[float] = None, max_loops: Optional[int] = None, auto_find_prompt: bool = True, strip_prompt: bool = True, strip_command: bool = True, normalize: bool = True, use_textfsm: bool = False, textfsm_template: Optional[str] = None, use_ttp: bool = False, ttp_template: Optional[str] = None, use_genie: bool = False, cmd_verify: bool = True) ‑> Union[str, List[Any], Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute command_string on the SSH channel using a pattern-based mechanism. Generally
used for show commands. By default this method will keep waiting to receive data until the
network device prompt is detected. The current network device prompt will be determined
automatically.</p>
<p>:param command_string: The command to be executed on the remote device.</p>
<p>:param expect_string: Regular expression pattern to use for determining end of output.
If left blank will default to being based on router prompt.</p>
<p>:param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p>
<p>:param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p>
<p>:param strip_prompt: Remove the trailing router prompt from the output (default: True).</p>
<p>:param strip_command: Remove the echo of the command from the output (default: True).</p>
<p>:param normalize: Ensure the proper enter is sent at end of command (default: True).</p>
<p>:param use_textfsm: Process command output through TextFSM template (default: False).</p>
<p>:param textfsm_template: Name of template to parse output with; can be fully qualified
path, relative path, or name of file in current directory. (default: None).</p>
<p>:param use_ttp: Process command output through TTP template (default: False).</p>
<p>:param ttp_template: Name of template to parse output with; can be fully qualified
path, relative path, or name of file in current directory. (default: None).</p>
<p>:param use_genie: Process command output through PyATS/Genie parser (default: False).</p>
<p>:param cmd_verify: Verify command echo before proceeding (default: True).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">    @select_cmd_verify
    def send_command(
        self,
        command_string: str,
        expect_string: Optional[str] = None,
        read_timeout: float = 10.0,
        delay_factor: Optional[float] = None,
        max_loops: Optional[int] = None,
        auto_find_prompt: bool = True,
        strip_prompt: bool = True,
        strip_command: bool = True,
        normalize: bool = True,
        use_textfsm: bool = False,
        textfsm_template: Optional[str] = None,
        use_ttp: bool = False,
        ttp_template: Optional[str] = None,
        use_genie: bool = False,
        cmd_verify: bool = True,
    ) -&gt; Union[str, List[Any], Dict[str, Any]]:
        &#34;&#34;&#34;Execute command_string on the SSH channel using a pattern-based mechanism. Generally
        used for show commands. By default this method will keep waiting to receive data until the
        network device prompt is detected. The current network device prompt will be determined
        automatically.

        :param command_string: The command to be executed on the remote device.

        :param expect_string: Regular expression pattern to use for determining end of output.
            If left blank will default to being based on router prompt.

        :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        :param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        :param strip_prompt: Remove the trailing router prompt from the output (default: True).

        :param strip_command: Remove the echo of the command from the output (default: True).

        :param normalize: Ensure the proper enter is sent at end of command (default: True).

        :param use_textfsm: Process command output through TextFSM template (default: False).

        :param textfsm_template: Name of template to parse output with; can be fully qualified
            path, relative path, or name of file in current directory. (default: None).

        :param use_ttp: Process command output through TTP template (default: False).

        :param ttp_template: Name of template to parse output with; can be fully qualified
            path, relative path, or name of file in current directory. (default: None).

        :param use_genie: Process command output through PyATS/Genie parser (default: False).

        :param cmd_verify: Verify command echo before proceeding (default: True).
        &#34;&#34;&#34;

        # Time to delay in each read loop
        loop_delay = 0.025

        if self.read_timeout_override:
            read_timeout = self.read_timeout_override

        if self.delay_factor_compat:
            # For compatibility calculate the old equivalent read_timeout
            # i.e. what it would have been in Netmiko 3.x
            if delay_factor is None:
                tmp_delay_factor = self.global_delay_factor
            else:
                tmp_delay_factor = self.select_delay_factor(delay_factor)
            compat_timeout = calc_old_timeout(
                max_loops=max_loops,
                delay_factor=tmp_delay_factor,
                loop_delay=0.2,
                old_timeout=self.timeout,
            )
            msg = f&#34;&#34;&#34;\n
You have chosen to use Netmiko&#39;s delay_factor compatibility mode for
send_command. This will revert Netmiko to behave similarly to how it
did in Netmiko 3.x (i.e. to use delay_factor/global_delay_factor and
max_loops).

Using these parameters Netmiko has calculated an effective read_timeout
of {compat_timeout} and will set the read_timeout to this value.

Please convert your code to that new format i.e.:

    net_connect.send_command(cmd, read_timeout={compat_timeout})

And then disable delay_factor_compat.

delay_factor_compat will be removed in Netmiko 5.x.\n&#34;&#34;&#34;
            warnings.warn(msg, DeprecationWarning)

            # Override the read_timeout with Netmiko 3.x way :-(
            read_timeout = compat_timeout

        else:
            # No need for two deprecation messages so only display this if not using
            # delay_factor_compat
            if delay_factor is not None or max_loops is not None:
                msg = &#34;&#34;&#34;\n
Netmiko 4.x has deprecated the use of delay_factor/max_loops with
send_command. You should convert all uses of delay_factor and max_loops
over to read_timeout=x where x is the total number of seconds to wait
before timing out.\n&#34;&#34;&#34;
                warnings.warn(msg, DeprecationWarning)

        if expect_string is not None:
            search_pattern = expect_string
        else:
            search_pattern = self._prompt_handler(auto_find_prompt)

        if normalize:
            command_string = self.normalize_cmd(command_string)

        # Start the clock
        start_time = time.time()
        self.write_channel(command_string)
        new_data = &#34;&#34;

        cmd = command_string.strip()
        if cmd and cmd_verify:
            new_data = self.command_echo_read(cmd=cmd, read_timeout=10)

        MAX_CHARS = 2_000_000
        DEQUE_SIZE = 20
        output = &#34;&#34;
        # Check only the past N-reads. This is for the case where the output is
        # very large (i.e. searching a very large string for a pattern a whole bunch of times)
        past_n_reads: Deque[str] = deque(maxlen=DEQUE_SIZE)
        first_line_processed = False

        # Keep reading data until search_pattern is found or until read_timeout
        while time.time() - start_time &lt; read_timeout:
            if new_data:
                output += new_data
                past_n_reads.append(new_data)

                # Case where we haven&#39;t processed the first_line yet (there is a potential issue
                # in the first line (in cases where the line is repainted).
                if not first_line_processed:
                    output, first_line_processed = self._first_line_handler(
                        output, search_pattern
                    )
                    # Check if we have already found our pattern
                    if re.search(search_pattern, output):
                        break

                else:
                    if len(output) &lt;= MAX_CHARS:
                        if re.search(search_pattern, output):
                            break
                    else:
                        # Switch to deque mode if output is greater than MAX_CHARS
                        # Check if pattern is in the past n reads
                        if re.search(search_pattern, &#34;&#34;.join(past_n_reads)):
                            break

            time.sleep(loop_delay)
            new_data = self.read_channel()

        else:  # nobreak
            msg = f&#34;&#34;&#34;
Pattern not detected: {repr(search_pattern)} in output.

Things you might try to fix this:
1. Explicitly set your pattern using the expect_string argument.
2. Increase the read_timeout to a larger value.

You can also look at the Netmiko session_log or debug log for more information.

&#34;&#34;&#34;
            raise ReadTimeout(msg)

        output = self._sanitize_output(
            output,
            strip_command=strip_command,
            command_string=command_string,
            strip_prompt=strip_prompt,
        )
        return_val = structured_data_converter(
            command=command_string,
            raw_data=output,
            platform=self.device_type,
            use_textfsm=use_textfsm,
            use_ttp=use_ttp,
            use_genie=use_genie,
            textfsm_template=textfsm_template,
            ttp_template=ttp_template,
        )
        return return_val</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.send_command_expect"><code class="name flex">
<span>def <span class="ident">send_command_expect</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> Union[str, List[Any], Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Support previous name of send_command method.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_command_expect(
    self, *args: Any, **kwargs: Any
) -&gt; Union[str, List[Any], Dict[str, Any]]:
    &#34;&#34;&#34;Support previous name of send_command method.&#34;&#34;&#34;
    return self.send_command(*args, **kwargs)</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.send_command_timing"><code class="name flex">
<span>def <span class="ident">send_command_timing</span></span>(<span>self, command_string: str, last_read: float = 2.0, read_timeout: float = 120.0, delay_factor: Optional[float] = None, max_loops: Optional[int] = None, strip_prompt: bool = True, strip_command: bool = True, normalize: bool = True, use_textfsm: bool = False, textfsm_template: Optional[str] = None, use_ttp: bool = False, ttp_template: Optional[str] = None, use_genie: bool = False, cmd_verify: bool = False) ‑> Union[str, List[Any], Dict[str, Any]]</span>
</code></dt>
<dd>
<div class="desc"><p>Execute command_string on the SSH channel using a delay-based mechanism. Generally
used for show commands.</p>
<p>:param command_string: The command to be executed on the remote device.</p>
<p>:param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p>
<p>:param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p>
<p>:param strip_prompt: Remove the trailing router prompt from the output (default: True).</p>
<p>:param strip_command: Remove the echo of the command from the output (default: True).</p>
<p>:param normalize: Ensure the proper enter is sent at end of command (default: True).</p>
<p>:param use_textfsm: Process command output through TextFSM template (default: False).</p>
<p>:param textfsm_template: Name of template to parse output with; can be fully qualified
path, relative path, or name of file in current directory. (default: None).</p>
<p>:param use_ttp: Process command output through TTP template (default: False).</p>
<p>:param ttp_template: Name of template to parse output with; can be fully qualified
path, relative path, or name of file in current directory. (default: None).</p>
<p>:param use_genie: Process command output through PyATS/Genie parser (default: False).</p>
<p>:param cmd_verify: Verify command echo before proceeding (default: False).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@select_cmd_verify
def send_command_timing(
    self,
    command_string: str,
    last_read: float = 2.0,
    read_timeout: float = 120.0,
    delay_factor: Optional[float] = None,
    max_loops: Optional[int] = None,
    strip_prompt: bool = True,
    strip_command: bool = True,
    normalize: bool = True,
    use_textfsm: bool = False,
    textfsm_template: Optional[str] = None,
    use_ttp: bool = False,
    ttp_template: Optional[str] = None,
    use_genie: bool = False,
    cmd_verify: bool = False,
) -&gt; Union[str, List[Any], Dict[str, Any]]:
    &#34;&#34;&#34;Execute command_string on the SSH channel using a delay-based mechanism. Generally
    used for show commands.

    :param command_string: The command to be executed on the remote device.

    :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

    :param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

    :param strip_prompt: Remove the trailing router prompt from the output (default: True).

    :param strip_command: Remove the echo of the command from the output (default: True).

    :param normalize: Ensure the proper enter is sent at end of command (default: True).

    :param use_textfsm: Process command output through TextFSM template (default: False).

    :param textfsm_template: Name of template to parse output with; can be fully qualified
        path, relative path, or name of file in current directory. (default: None).

    :param use_ttp: Process command output through TTP template (default: False).

    :param ttp_template: Name of template to parse output with; can be fully qualified
        path, relative path, or name of file in current directory. (default: None).

    :param use_genie: Process command output through PyATS/Genie parser (default: False).

    :param cmd_verify: Verify command echo before proceeding (default: False).
    &#34;&#34;&#34;
    if delay_factor is not None or max_loops is not None:
        warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)

    output = &#34;&#34;
    new_data = &#34;&#34;
    if normalize:
        command_string = self.normalize_cmd(command_string)
    self.write_channel(command_string)

    cmd = command_string.strip()
    if cmd and cmd_verify:
        new_data = self.command_echo_read(cmd=cmd, read_timeout=10)
    output += new_data
    output += self.read_channel_timing(
        last_read=last_read, read_timeout=read_timeout
    )

    output = self._sanitize_output(
        output,
        strip_command=strip_command,
        command_string=command_string,
        strip_prompt=strip_prompt,
    )
    return_data = structured_data_converter(
        command=command_string,
        raw_data=output,
        platform=self.device_type,
        use_textfsm=use_textfsm,
        use_ttp=use_ttp,
        use_genie=use_genie,
        textfsm_template=textfsm_template,
        ttp_template=ttp_template,
    )
    return return_data</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.send_config_from_file"><code class="name flex">
<span>def <span class="ident">send_config_from_file</span></span>(<span>self, config_file: Union[str, bytes, ForwardRef('PathLike[Any]')], **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Send configuration commands down the SSH channel from a file.</p>
<p>The file is processed line-by-line and each command is sent down the
SSH channel.</p>
<p>**kwargs are passed to send_config_set method.</p>
<p>:param config_file: Path to configuration file to be sent to the device</p>
<p>:param kwargs: params to be sent to send_config_set method</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_config_from_file(
    self, config_file: Union[str, bytes, &#34;PathLike[Any]&#34;], **kwargs: Any
) -&gt; str:
    &#34;&#34;&#34;
    Send configuration commands down the SSH channel from a file.

    The file is processed line-by-line and each command is sent down the
    SSH channel.

    **kwargs are passed to send_config_set method.

    :param config_file: Path to configuration file to be sent to the device

    :param kwargs: params to be sent to send_config_set method
    &#34;&#34;&#34;
    with io.open(config_file, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as cfg_file:
        commands = cfg_file.readlines()
    return self.send_config_set(commands, **kwargs)</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.send_config_set"><code class="name flex">
<span>def <span class="ident">send_config_set</span></span>(<span>self, config_commands: Union[str, Sequence[str], Iterator[str], TextIO, ForwardRef(None)] = None, *, exit_config_mode: bool = True, read_timeout: Optional[float] = None, delay_factor: Optional[float] = None, max_loops: Optional[int] = None, strip_prompt: bool = False, strip_command: bool = False, config_mode_command: Optional[str] = None, cmd_verify: bool = True, enter_config_mode: bool = True, error_pattern: str = '', terminator: str = '#', bypass_commands: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Send configuration commands down the SSH channel.</p>
<p>config_commands is an iterable containing all of the configuration commands.
The commands will be executed one after the other.</p>
<p>Automatically exits/enters configuration mode.</p>
<p>:param config_commands: Multiple configuration commands to be sent to the device</p>
<p>:param exit_config_mode: Determines whether or not to exit config mode after complete</p>
<p>:param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p>
<p>:param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p>
<p>:param strip_prompt: Determines whether or not to strip the prompt</p>
<p>:param strip_command: Determines whether or not to strip the command</p>
<p>:param read_timeout: Absolute timer to send to read_channel_timing. Should be rarely needed.</p>
<p>:param config_mode_command: The command to enter into config mode</p>
<p>:param cmd_verify: Whether or not to verify command echo for each command in config_set</p>
<p>:param enter_config_mode: Do you enter config mode before sending config commands</p>
<p>:param error_pattern: Regular expression pattern to detect config errors in the
output.</p>
<p>:param terminator: Regular expression pattern to use as an alternate terminator in certain
situations.</p>
<p>:param bypass_commands: Regular expression pattern indicating configuration commands
where cmd_verify is automatically disabled.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_config_set(
    self,
    config_commands: Union[str, Sequence[str], Iterator[str], TextIO, None] = None,
    *,
    exit_config_mode: bool = True,
    read_timeout: Optional[float] = None,
    delay_factor: Optional[float] = None,
    max_loops: Optional[int] = None,
    strip_prompt: bool = False,
    strip_command: bool = False,
    config_mode_command: Optional[str] = None,
    cmd_verify: bool = True,
    enter_config_mode: bool = True,
    error_pattern: str = &#34;&#34;,
    terminator: str = r&#34;#&#34;,
    bypass_commands: Optional[str] = None,
) -&gt; str:
    &#34;&#34;&#34;
    Send configuration commands down the SSH channel.

    config_commands is an iterable containing all of the configuration commands.
    The commands will be executed one after the other.

    Automatically exits/enters configuration mode.

    :param config_commands: Multiple configuration commands to be sent to the device

    :param exit_config_mode: Determines whether or not to exit config mode after complete

    :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

    :param max_loops: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

    :param strip_prompt: Determines whether or not to strip the prompt

    :param strip_command: Determines whether or not to strip the command

    :param read_timeout: Absolute timer to send to read_channel_timing. Should be rarely needed.

    :param config_mode_command: The command to enter into config mode

    :param cmd_verify: Whether or not to verify command echo for each command in config_set

    :param enter_config_mode: Do you enter config mode before sending config commands

    :param error_pattern: Regular expression pattern to detect config errors in the
    output.

    :param terminator: Regular expression pattern to use as an alternate terminator in certain
    situations.

    :param bypass_commands: Regular expression pattern indicating configuration commands
    where cmd_verify is automatically disabled.
    &#34;&#34;&#34;

    if self.global_cmd_verify is not None:
        cmd_verify = self.global_cmd_verify

    if delay_factor is not None or max_loops is not None:
        warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)

        # Calculate an equivalent read_timeout (if using old settings)
        # Eliminate in Netmiko 5.x
        if read_timeout is None:
            max_loops = 150 if max_loops is None else max_loops
            delay_factor = 1.0 if delay_factor is None else delay_factor

            # If delay_factor has been set, then look at global_delay_factor
            delay_factor = self.select_delay_factor(delay_factor)

            read_timeout = calc_old_timeout(
                max_loops=max_loops, delay_factor=delay_factor, loop_delay=0.1
            )

    if delay_factor is None:
        delay_factor = self.select_delay_factor(0)
    else:
        delay_factor = self.select_delay_factor(delay_factor)

    if read_timeout is None:
        read_timeout = 15
    else:
        read_timeout = read_timeout

    if config_commands is None:
        return &#34;&#34;
    elif isinstance(config_commands, str):
        config_commands = (config_commands,)

    if not hasattr(config_commands, &#34;__iter__&#34;):
        raise ValueError(&#34;Invalid argument passed into send_config_set&#34;)

    if bypass_commands is None:
        # Commands where cmd_verify is automatically disabled reg-ex logical-or
        bypass_commands = r&#34;^banner .*$&#34;

    # Set bypass_commands=&#34;&#34; to force no-bypass (usually for testing)
    bypass_detected = False
    if bypass_commands:
        # Make a copy of the iterator
        config_commands, config_commands_tmp = itertools.tee(config_commands, 2)
        bypass_detected = any(
            [True for cmd in config_commands_tmp if re.search(bypass_commands, cmd)]
        )
    if bypass_detected:
        cmd_verify = False

    # Send config commands
    output = &#34;&#34;
    if enter_config_mode:
        if config_mode_command:
            output += self.config_mode(config_mode_command)
        else:
            output += self.config_mode()

    # Perform output gathering line-by-line (legacy way)
    if self.fast_cli and self._legacy_mode and not error_pattern:
        for cmd in config_commands:
            self.write_channel(self.normalize_cmd(cmd))
        # Gather output
        output += self.read_channel_timing(read_timeout=read_timeout)

    elif not cmd_verify:
        for cmd in config_commands:
            self.write_channel(self.normalize_cmd(cmd))
            time.sleep(delay_factor * 0.05)

            # Gather the output incrementally due to error_pattern requirements
            if error_pattern:
                output += self.read_channel_timing(read_timeout=read_timeout)
                if re.search(error_pattern, output, flags=re.M):
                    msg = f&#34;Invalid input detected at command: {cmd}&#34;
                    raise ConfigInvalidException(msg)

        # Standard output gathering (no error_pattern)
        if not error_pattern:
            output += self.read_channel_timing(read_timeout=read_timeout)

    else:
        for cmd in config_commands:
            self.write_channel(self.normalize_cmd(cmd))

            # Make sure command is echoed
            output += self.read_until_pattern(pattern=re.escape(cmd.strip()))

            # Read until next prompt or terminator (#); the .*$ forces read of entire line
            pattern = f&#34;(?:{re.escape(self.base_prompt)}.*$|{terminator}.*$)&#34;
            output += self.read_until_pattern(pattern=pattern, re_flags=re.M)

            if error_pattern:
                if re.search(error_pattern, output, flags=re.M):
                    msg = f&#34;Invalid input detected at command: {cmd}&#34;
                    raise ConfigInvalidException(msg)

    if exit_config_mode:
        output += self.exit_config_mode()
    output = self._sanitize_output(output)
    log.debug(f&#34;{output}&#34;)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.send_multiline"><code class="name flex">
<span>def <span class="ident">send_multiline</span></span>(<span>self, commands: Sequence[Union[str, List[str]]], multiline: bool = True, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>commands should either be:</p>
<p>commands = [[cmd1, expect1], [cmd2, expect2], &hellip;]]</p>
<p>Or</p>
<p>commands = [cmd1, cmd2, cmd3, &hellip;]</p>
<p>Any expect_string that is a null-string will use pattern based on
device's prompt (unless expect_string argument is passed in via
kwargs.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_multiline(
    self,
    commands: Sequence[Union[str, List[str]]],
    multiline: bool = True,
    **kwargs: Any,
) -&gt; str:
    &#34;&#34;&#34;
    commands should either be:

    commands = [[cmd1, expect1], [cmd2, expect2], ...]]

    Or

    commands = [cmd1, cmd2, cmd3, ...]

    Any expect_string that is a null-string will use pattern based on
    device&#39;s prompt (unless expect_string argument is passed in via
    kwargs.

    &#34;&#34;&#34;
    output = &#34;&#34;
    if multiline:
        kwargs = self._multiline_kwargs(**kwargs)

    default_expect_string = kwargs.pop(&#34;expect_string&#34;, None)
    if not default_expect_string:
        auto_find_prompt = kwargs.get(&#34;auto_find_prompt&#34;, True)
        default_expect_string = self._prompt_handler(auto_find_prompt)

    if commands and isinstance(commands[0], str):
        # If list of commands just send directly using default_expect_string (probably prompt)
        for cmd in commands:
            cmd = str(cmd)
            output += self._send_command_str(
                cmd, expect_string=default_expect_string, **kwargs
            )
    else:
        # If list of lists, then first element is cmd and second element is expect_string
        for cmd_item in commands:
            assert not isinstance(cmd_item, str)
            cmd, expect_string = cmd_item
            if not expect_string:
                expect_string = default_expect_string
            output += self._send_command_str(
                cmd, expect_string=expect_string, **kwargs
            )
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.send_multiline_timing"><code class="name flex">
<span>def <span class="ident">send_multiline_timing</span></span>(<span>self, commands: Sequence[str], multiline: bool = True, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def send_multiline_timing(
    self, commands: Sequence[str], multiline: bool = True, **kwargs: Any
) -&gt; str:
    if multiline:
        kwargs = self._multiline_kwargs(**kwargs)
    output = &#34;&#34;
    for cmd in commands:
        cmd = str(cmd)
        output += self._send_command_timing_str(cmd, **kwargs)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.serial_login"><code class="name flex">
<span>def <span class="ident">serial_login</span></span>(<span>self, pri_prompt_terminator: str = '#\\s*$', alt_prompt_terminator: str = &#x27;&gt;\\s*$&#x27;, username_pattern: str = '(?:[Uu]ser:|sername|ogin)', pwd_pattern: str = 'assword', delay_factor: float = 1.0, max_loops: int = 20) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def serial_login(
    self,
    pri_prompt_terminator: str = r&#34;#\s*$&#34;,
    alt_prompt_terminator: str = r&#34;&gt;\s*$&#34;,
    username_pattern: str = r&#34;(?:[Uu]ser:|sername|ogin)&#34;,
    pwd_pattern: str = r&#34;assword&#34;,
    delay_factor: float = 1.0,
    max_loops: int = 20,
) -&gt; str:
    return self.telnet_login(
        pri_prompt_terminator,
        alt_prompt_terminator,
        username_pattern,
        pwd_pattern,
        delay_factor,
        max_loops,
    )</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.session_preparation"><code class="name flex">
<span>def <span class="ident">session_preparation</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the session after the connection has been established</p>
<p>This method handles some differences that occur between various devices
early on in the session.</p>
<p>In general, it should include:
self._test_channel_read(pattern=r"some_pattern")
self.set_base_prompt()
self.set_terminal_width()
self.disable_paging()</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def session_preparation(self) -&gt; None:
    &#34;&#34;&#34;
    Prepare the session after the connection has been established

    This method handles some differences that occur between various devices
    early on in the session.

    In general, it should include:
    self._test_channel_read(pattern=r&#34;some_pattern&#34;)
    self.set_base_prompt()
    self.set_terminal_width()
    self.disable_paging()
    &#34;&#34;&#34;
    self._test_channel_read()
    self.set_base_prompt()
    self.set_terminal_width()
    self.disable_paging()</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.set_base_prompt"><code class="name flex">
<span>def <span class="ident">set_base_prompt</span></span>(<span>self, pri_prompt_terminator: str = '#', alt_prompt_terminator: str = &#x27;&gt;&#x27;, delay_factor: float = 1.0, pattern: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Sets self.base_prompt</p>
<p>Used as delimiter for stripping of trailing prompt in output.</p>
<p>Should be set to something that is general and applies in multiple contexts. For Cisco
devices this will be set to router hostname (i.e. prompt without &gt; or #).</p>
<p>This will be set on entering user exec or privileged exec on Cisco, but not when
entering/exiting config mode.</p>
<p>:param pri_prompt_terminator: Primary trailing delimiter for identifying a device prompt</p>
<p>:param alt_prompt_terminator: Alternate trailing delimiter for identifying a device prompt</p>
<p>:param delay_factor: See <strong>init</strong>: global_delay_factor</p>
<p>:param pattern: Regular expression pattern to search for in find_prompt() call</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@retry(
    wait=wait_exponential(multiplier=0.33, min=0, max=5),
    stop=stop_after_attempt(5),
    reraise=True,
)
def set_base_prompt(
    self,
    pri_prompt_terminator: str = &#34;#&#34;,
    alt_prompt_terminator: str = &#34;&gt;&#34;,
    delay_factor: float = 1.0,
    pattern: Optional[str] = None,
) -&gt; str:
    &#34;&#34;&#34;Sets self.base_prompt

    Used as delimiter for stripping of trailing prompt in output.

    Should be set to something that is general and applies in multiple contexts. For Cisco
    devices this will be set to router hostname (i.e. prompt without &gt; or #).

    This will be set on entering user exec or privileged exec on Cisco, but not when
    entering/exiting config mode.

    :param pri_prompt_terminator: Primary trailing delimiter for identifying a device prompt

    :param alt_prompt_terminator: Alternate trailing delimiter for identifying a device prompt

    :param delay_factor: See __init__: global_delay_factor

    :param pattern: Regular expression pattern to search for in find_prompt() call
    &#34;&#34;&#34;
    if pattern is None:
        if pri_prompt_terminator and alt_prompt_terminator:
            pri_term = re.escape(pri_prompt_terminator)
            alt_term = re.escape(alt_prompt_terminator)
            pattern = rf&#34;({pri_term}|{alt_term})&#34;
        elif pri_prompt_terminator:
            pattern = re.escape(pri_prompt_terminator)
        elif alt_prompt_terminator:
            pattern = re.escape(alt_prompt_terminator)

    if pattern:
        prompt = self.find_prompt(delay_factor=delay_factor, pattern=pattern)
    else:
        prompt = self.find_prompt(delay_factor=delay_factor)

    if not prompt[-1] in (pri_prompt_terminator, alt_prompt_terminator):
        raise ValueError(f&#34;Router prompt not found: {repr(prompt)}&#34;)

    # If all we have is the &#39;terminator&#39; just use that :-(
    if len(prompt) == 1:
        self.base_prompt = prompt
    else:
        # Strip off trailing terminator
        self.base_prompt = prompt[:-1]
    return self.base_prompt</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.set_terminal_width"><code class="name flex">
<span>def <span class="ident">set_terminal_width</span></span>(<span>self, command: str = '', delay_factor: Optional[float] = None, cmd_verify: bool = False, pattern: Optional[str] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>CLI terminals try to automatically adjust the line based on the width of the terminal.
This causes the output to get distorted when accessed programmatically.</p>
<p>Set terminal width to 511 which works on a broad set of devices.</p>
<p>:param command: Command string to send to the device</p>
<p>:param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_terminal_width(
    self,
    command: str = &#34;&#34;,
    delay_factor: Optional[float] = None,
    cmd_verify: bool = False,
    pattern: Optional[str] = None,
) -&gt; str:
    &#34;&#34;&#34;CLI terminals try to automatically adjust the line based on the width of the terminal.
    This causes the output to get distorted when accessed programmatically.

    Set terminal width to 511 which works on a broad set of devices.

    :param command: Command string to send to the device

    :param delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.
    &#34;&#34;&#34;
    if delay_factor is not None:
        warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)

    if not command:
        return &#34;&#34;
    command = self.normalize_cmd(command)
    self.write_channel(command)

    # Avoid cmd_verify here as terminal width must be set before doing cmd_verify
    if cmd_verify and self.global_cmd_verify is not False:
        output = self.read_until_pattern(pattern=re.escape(command.strip()))
    elif pattern:
        output = self.read_until_pattern(pattern=pattern)
    else:
        output = self.read_until_prompt()
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.special_login_handler"><code class="name flex">
<span>def <span class="ident">special_login_handler</span></span>(<span>self, delay_factor: float = 1.0) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Handler for devices like WLC, Extreme ERS that throw up characters prior to login.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def special_login_handler(self, delay_factor: float = 1.0) -&gt; None:
    &#34;&#34;&#34;Handler for devices like WLC, Extreme ERS that throw up characters prior to login.&#34;&#34;&#34;
    pass</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.strip_ansi_escape_codes"><code class="name flex">
<span>def <span class="ident">strip_ansi_escape_codes</span></span>(<span>self, string_buffer: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Remove any ANSI (VT100) ESC codes from the output</p>
<p><a href="http://en.wikipedia.org/wiki/ANSI_escape_code">http://en.wikipedia.org/wiki/ANSI_escape_code</a></p>
<p>Note: this does not capture ALL possible ANSI Escape Codes only the ones
I have encountered</p>
<p>Current codes that are filtered:
ESC = '' or chr(27)
ESC = is the escape character [^ in hex ('')
ESC[24;27H
Position cursor
ESC[?25h
Show the cursor
ESC[E
Next line (HP does ESC-E)
ESC[K
Erase line from cursor to the end of line
ESC[2K
Erase entire line
ESC[1;24r
Enable scrolling from start to row end
ESC[?6l
Reset mode screen with options 640 x 200 monochrome (graphics)
ESC[?7l
Disable line wrapping
ESC[2J
Code erase display
ESC[00;32m
Color Green (30 to 37 are different colors)
ESC[6n
Get cursor position
ESC[1D
Move cursor position leftward by x characters (1 in this case)
ESC[9999B
Move cursor down N-lines (very large value is attempt to move to the
very bottom of the screen).</p>
<p>HP ProCurve and Cisco SG300 require this (possible others).</p>
<p>:param string_buffer: The string to be processed to remove ANSI escape codes
:type string_buffer: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_ansi_escape_codes(self, string_buffer: str) -&gt; str:
    &#34;&#34;&#34;
    Remove any ANSI (VT100) ESC codes from the output

    http://en.wikipedia.org/wiki/ANSI_escape_code

    Note: this does not capture ALL possible ANSI Escape Codes only the ones
    I have encountered

    Current codes that are filtered:
    ESC = &#39;\x1b&#39; or chr(27)
    ESC = is the escape character [^ in hex (&#39;\x1b&#39;)
    ESC[24;27H   Position cursor
    ESC[?25h     Show the cursor
    ESC[E        Next line (HP does ESC-E)
    ESC[K        Erase line from cursor to the end of line
    ESC[2K       Erase entire line
    ESC[1;24r    Enable scrolling from start to row end
    ESC[?6l      Reset mode screen with options 640 x 200 monochrome (graphics)
    ESC[?7l      Disable line wrapping
    ESC[2J       Code erase display
    ESC[00;32m   Color Green (30 to 37 are different colors)
    ESC[6n       Get cursor position
    ESC[1D       Move cursor position leftward by x characters (1 in this case)
    ESC[9999B    Move cursor down N-lines (very large value is attempt to move to the
                 very bottom of the screen).

    HP ProCurve and Cisco SG300 require this (possible others).

    :param string_buffer: The string to be processed to remove ANSI escape codes
    :type string_buffer: str
    &#34;&#34;&#34;  # noqa

    code_position_cursor = chr(27) + r&#34;\[\d+;\d+H&#34;
    code_show_cursor = chr(27) + r&#34;\[\?25h&#34;
    code_next_line = chr(27) + r&#34;E&#34;
    code_erase_line_end = chr(27) + r&#34;\[K&#34;
    code_erase_line = chr(27) + r&#34;\[2K&#34;
    code_erase_start_line = chr(27) + r&#34;\[K&#34;
    code_enable_scroll = chr(27) + r&#34;\[\d+;\d+r&#34;
    code_insert_line = chr(27) + r&#34;\[(\d+)L&#34;
    code_carriage_return = chr(27) + r&#34;\[1M&#34;
    code_disable_line_wrapping = chr(27) + r&#34;\[\?7l&#34;
    code_reset_mode_screen_options = chr(27) + r&#34;\[\?\d+l&#34;
    code_reset_graphics_mode = chr(27) + r&#34;\[00m&#34;
    code_erase_display = chr(27) + r&#34;\[2J&#34;
    code_erase_display_0 = chr(27) + r&#34;\[J&#34;
    code_graphics_mode = chr(27) + r&#34;\[\dm&#34;
    code_graphics_mode1 = chr(27) + r&#34;\[\d\d;\d\dm&#34;
    code_graphics_mode2 = chr(27) + r&#34;\[\d\d;\d\d;\d\dm&#34;
    code_graphics_mode3 = chr(27) + r&#34;\[(3|4)\dm&#34;
    code_graphics_mode4 = chr(27) + r&#34;\[(9|10)[0-7]m&#34;
    code_get_cursor_position = chr(27) + r&#34;\[6n&#34;
    code_cursor_position = chr(27) + r&#34;\[m&#34;
    code_attrs_off = chr(27) + r&#34;\[0m&#34;
    code_reverse = chr(27) + r&#34;\[7m&#34;
    code_cursor_left = chr(27) + r&#34;\[\d+D&#34;
    code_cursor_forward = chr(27) + r&#34;\[\d*C&#34;
    code_cursor_up = chr(27) + r&#34;\[\d*A&#34;
    code_cursor_down = chr(27) + r&#34;\[\d*B&#34;
    code_wrap_around = chr(27) + r&#34;\[\?7h&#34;
    code_bracketed_paste_mode = chr(27) + r&#34;\[\?2004h&#34;

    code_set = [
        code_position_cursor,
        code_show_cursor,
        code_erase_line,
        code_enable_scroll,
        code_erase_start_line,
        code_carriage_return,
        code_disable_line_wrapping,
        code_erase_line_end,
        code_reset_mode_screen_options,
        code_reset_graphics_mode,
        code_erase_display,
        code_graphics_mode,
        code_graphics_mode1,
        code_graphics_mode2,
        code_graphics_mode3,
        code_graphics_mode4,
        code_get_cursor_position,
        code_cursor_position,
        code_erase_display,
        code_erase_display_0,
        code_attrs_off,
        code_reverse,
        code_cursor_left,
        code_cursor_up,
        code_cursor_down,
        code_cursor_forward,
        code_wrap_around,
        code_bracketed_paste_mode,
    ]

    output = string_buffer
    for ansi_esc_code in code_set:
        output = re.sub(ansi_esc_code, &#34;&#34;, output)

    # CODE_NEXT_LINE must substitute with return
    output = re.sub(code_next_line, self.RETURN, output)

    # Aruba and ProCurve switches can use code_insert_line for &lt;enter&gt;
    insert_line_match = re.search(code_insert_line, output)
    if insert_line_match:
        # Substitute each insert_line with a new &lt;enter&gt;
        count = int(insert_line_match.group(1))
        output = re.sub(code_insert_line, count * self.RETURN, output)

    return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.strip_command"><code class="name flex">
<span>def <span class="ident">strip_command</span></span>(<span>self, command_string: str, output: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Strip command_string from output string</p>
<p>Cisco IOS adds backspaces into output for long commands (i.e. for commands that line wrap)</p>
<p>:param command_string: The command string sent to the device
:type command_string: str</p>
<p>:param output: The returned output as a result of the command string sent to the device
:type output: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_command(self, command_string: str, output: str) -&gt; str:
    &#34;&#34;&#34;
    Strip command_string from output string

    Cisco IOS adds backspaces into output for long commands (i.e. for commands that line wrap)

    :param command_string: The command string sent to the device
    :type command_string: str

    :param output: The returned output as a result of the command string sent to the device
    :type output: str
    &#34;&#34;&#34;
    backspace_char = &#34;\x08&#34;

    # Check for line wrap (remove backspaces)
    if backspace_char in output:
        output = output.replace(backspace_char, &#34;&#34;)

    # Juniper has a weird case where the echoed command will be &#34; \n&#34;
    # i.e. there is an extra space there.
    cmd = command_string.strip()
    if output.startswith(cmd):
        output_lines = output.split(self.RESPONSE_RETURN)
        new_output = output_lines[1:]
        return self.RESPONSE_RETURN.join(new_output)
    else:
        # command_string isn&#39;t there; do nothing
        return output</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.strip_prompt"><code class="name flex">
<span>def <span class="ident">strip_prompt</span></span>(<span>self, a_string: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Strip the trailing router prompt from the output.</p>
<p>:param a_string: Returned string from device
:type a_string: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_prompt(self, a_string: str) -&gt; str:
    &#34;&#34;&#34;Strip the trailing router prompt from the output.

    :param a_string: Returned string from device
    :type a_string: str
    &#34;&#34;&#34;
    response_list = a_string.split(self.RESPONSE_RETURN)
    last_line = response_list[-1]

    if self.base_prompt in last_line:
        return self.RESPONSE_RETURN.join(response_list[:-1])
    else:
        return a_string</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.telnet_login"><code class="name flex">
<span>def <span class="ident">telnet_login</span></span>(<span>self, pri_prompt_terminator: str = '#\\s*$', alt_prompt_terminator: str = &#x27;&gt;\\s*$&#x27;, username_pattern: str = '(?:user:|username|login|user name)', pwd_pattern: str = 'assword', delay_factor: float = 1.0, max_loops: int = 20) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Telnet login. Can be username/password or just password.</p>
<p>:param pri_prompt_terminator: Primary trailing delimiter for identifying a device prompt</p>
<p>:param alt_prompt_terminator: Alternate trailing delimiter for identifying a device prompt</p>
<p>:param username_pattern: Pattern used to identify the username prompt</p>
<p>:param delay_factor: See <strong>init</strong>: global_delay_factor</p>
<p>:param max_loops: Controls the wait time in conjunction with the delay_factor</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def telnet_login(
    self,
    pri_prompt_terminator: str = r&#34;#\s*$&#34;,
    alt_prompt_terminator: str = r&#34;&gt;\s*$&#34;,
    username_pattern: str = r&#34;(?:user:|username|login|user name)&#34;,
    pwd_pattern: str = r&#34;assword&#34;,
    delay_factor: float = 1.0,
    max_loops: int = 20,
) -&gt; str:
    &#34;&#34;&#34;Telnet login. Can be username/password or just password.

    :param pri_prompt_terminator: Primary trailing delimiter for identifying a device prompt

    :param alt_prompt_terminator: Alternate trailing delimiter for identifying a device prompt

    :param username_pattern: Pattern used to identify the username prompt

    :param delay_factor: See __init__: global_delay_factor

    :param max_loops: Controls the wait time in conjunction with the delay_factor
    &#34;&#34;&#34;
    delay_factor = self.select_delay_factor(delay_factor)

    # Revert telnet_login back to old speeds/delays
    if delay_factor &lt; 1:
        if not self._legacy_mode and self.fast_cli:
            delay_factor = 1

    time.sleep(1 * delay_factor)

    output = &#34;&#34;
    return_msg = &#34;&#34;
    i = 1
    while i &lt;= max_loops:
        try:
            output = self.read_channel()
            return_msg += output

            # Search for username pattern / send username
            if re.search(username_pattern, output, flags=re.I):
                # Sometimes username/password must be terminated with &#34;\r&#34; and not &#34;\r\n&#34;
                self.write_channel(self.username + &#34;\r&#34;)
                time.sleep(1 * delay_factor)
                output = self.read_channel()
                return_msg += output

            # Search for password pattern / send password
            if re.search(pwd_pattern, output, flags=re.I):
                # Sometimes username/password must be terminated with &#34;\r&#34; and not &#34;\r\n&#34;
                assert isinstance(self.password, str)
                self.write_channel(self.password + &#34;\r&#34;)
                time.sleep(0.5 * delay_factor)
                output = self.read_channel()
                return_msg += output
                if re.search(
                    pri_prompt_terminator, output, flags=re.M
                ) or re.search(alt_prompt_terminator, output, flags=re.M):
                    return return_msg

            # Check if proper data received
            if re.search(pri_prompt_terminator, output, flags=re.M) or re.search(
                alt_prompt_terminator, output, flags=re.M
            ):
                return return_msg

            self.write_channel(self.TELNET_RETURN)
            time.sleep(0.5 * delay_factor)
            i += 1
        except EOFError:
            assert self.remote_conn is not None
            self.remote_conn.close()
            msg = f&#34;Login failed: {self.host}&#34;
            raise NetmikoAuthenticationException(msg)

    # Last try to see if we already logged in
    self.write_channel(self.TELNET_RETURN)
    time.sleep(0.5 * delay_factor)
    output = self.read_channel()
    return_msg += output
    if re.search(pri_prompt_terminator, output, flags=re.M) or re.search(
        alt_prompt_terminator, output, flags=re.M
    ):
        return return_msg

    msg = f&#34;Login failed: {self.host}&#34;
    assert self.remote_conn is not None
    self.remote_conn.close()
    raise NetmikoAuthenticationException(msg)</code></pre>
</details>
</dd>
<dt id="netmiko.BaseConnection.write_channel"><code class="name flex">
<span>def <span class="ident">write_channel</span></span>(<span>self, out_data: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Generic method that will write data out the channel.</p>
<p>:param out_data: data to be written to the channel
:type out_data: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@lock_channel
@log_writes
def write_channel(self, out_data: str) -&gt; None:
    &#34;&#34;&#34;Generic method that will write data out the channel.

    :param out_data: data to be written to the channel
    :type out_data: str
    &#34;&#34;&#34;
    self.channel.write_channel(out_data)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="netmiko.ConfigInvalidException"><code class="flex name class">
<span>class <span class="ident">ConfigInvalidException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Exception raised for invalid configuration error.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConfigInvalidException(NetmikoBaseException):
    &#34;&#34;&#34;Exception raised for invalid configuration error.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.exceptions.NetmikoBaseException" href="exceptions.html#netmiko.exceptions.NetmikoBaseException">NetmikoBaseException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="netmiko.ConnectionException"><code class="flex name class">
<span>class <span class="ident">ConnectionException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Generic exception indicating the connection failed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConnectionException(NetmikoBaseException):
    &#34;&#34;&#34;Generic exception indicating the connection failed.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.exceptions.NetmikoBaseException" href="exceptions.html#netmiko.exceptions.NetmikoBaseException">NetmikoBaseException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="netmiko.InLineTransfer"><code class="flex name class">
<span>class <span class="ident">InLineTransfer</span></span>
<span>(</span><span>ssh_conn: <a title="netmiko.base_connection.BaseConnection" href="base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a>, source_file: str = '', dest_file: str = '', file_system: Optional[str] = None, direction: str = 'put', source_config: Optional[str] = None, socket_timeout: float = 10.0, progress: Optional[Callable[..., Any]] = None, progress4: Optional[Callable[..., Any]] = None, hash_supported: bool = True)</span>
</code></dt>
<dd>
<div class="desc"><p>Use TCL on Cisco IOS to directly transfer file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class InLineTransfer(CiscoIosFileTransfer):
    &#34;&#34;&#34;Use TCL on Cisco IOS to directly transfer file.&#34;&#34;&#34;

    def __init__(
        self,
        ssh_conn: BaseConnection,
        source_file: str = &#34;&#34;,
        dest_file: str = &#34;&#34;,
        file_system: Optional[str] = None,
        direction: str = &#34;put&#34;,
        source_config: Optional[str] = None,
        socket_timeout: float = 10.0,
        progress: Optional[Callable[..., Any]] = None,
        progress4: Optional[Callable[..., Any]] = None,
        hash_supported: bool = True,
    ) -&gt; None:

        if not dest_file:
            raise ValueError(
                &#34;Destination file must be specified for InlineTransfer operations.&#34;
            )
        if hash_supported is False:
            raise ValueError(&#34;hash_supported=False is not supported for InLineTransfer&#34;)

        if source_file and source_config:
            msg = &#34;Invalid call to InLineTransfer both source_file and source_config specified.&#34;
            raise ValueError(msg)
        if direction != &#34;put&#34;:
            raise ValueError(&#34;Only put operation supported by InLineTransfer.&#34;)

        if progress is not None or progress4 is not None:
            raise NotImplementedError(
                &#34;Progress bar is not supported on inline transfers.&#34;
            )
        else:
            self.progress = progress
            self.progress4 = progress4

        self.ssh_ctl_chan = ssh_conn
        self.source_file = source_file
        if source_file:
            self.source_config = None
            self.source_md5 = self.file_md5(source_file)
            self.file_size = os.stat(source_file).st_size
        elif source_config:
            self.source_config = source_config
            self.source_md5 = self.config_md5(source_config)
            self.file_size = len(source_config.encode(&#34;UTF-8&#34;))
        self.dest_file = dest_file
        self.direction = direction

        if not file_system:
            self.file_system = self.ssh_ctl_chan._autodetect_fs()
        else:
            self.file_system = file_system

        self.socket_timeout = socket_timeout

    @staticmethod
    def _read_file(file_name: str) -&gt; str:
        with io.open(file_name, &#34;rt&#34;, encoding=&#34;utf-8&#34;) as f:
            return f.read()

    @staticmethod
    def _tcl_newline_rationalize(tcl_string: str) -&gt; str:
        r&#34;&#34;&#34;
        When using put inside a TCL {} section the newline is considered a new TCL
        statement and causes a missing curly-brace message. Convert &#34;\n&#34; to &#34;\r&#34;. TCL
        will convert the &#34;\r&#34; to a &#34;\n&#34; i.e. you will see a &#34;\n&#34; inside the file on the
        Cisco IOS device.
        &#34;&#34;&#34;
        NEWLINE = r&#34;\n&#34;
        CARRIAGE_RETURN = r&#34;\r&#34;
        tmp_string = re.sub(NEWLINE, CARRIAGE_RETURN, tcl_string)
        if re.search(r&#34;[{}]&#34;, tmp_string):
            msg = &#34;Curly brace detected in string; TCL requires this be escaped.&#34;
            raise ValueError(msg)
        return tmp_string

    def __enter__(self) -&gt; &#34;InLineTransfer&#34;:
        self._enter_tcl_mode()
        return self

    def __exit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_value: Optional[BaseException],
        traceback: Optional[TracebackType],
    ) -&gt; None:
        self._exit_tcl_mode()

    def _enter_tcl_mode(self) -&gt; str:
        TCL_ENTER = &#34;tclsh&#34;
        cmd_failed = [&#39;Translating &#34;tclsh&#34;&#39;, &#34;% Unknown command&#34;, &#34;% Bad IP address&#34;]
        output = self.ssh_ctl_chan._send_command_str(
            TCL_ENTER,
            expect_string=r&#34;\(tcl\)#&#34;,
            strip_prompt=False,
            strip_command=False,
        )
        for pattern in cmd_failed:
            if pattern in output:
                raise ValueError(f&#34;Failed to enter tclsh mode on router: {output}&#34;)
        return output

    def _exit_tcl_mode(self) -&gt; str:
        TCL_EXIT = &#34;tclquit&#34;
        self.ssh_ctl_chan.write_channel(&#34;\r&#34;)
        time.sleep(1)
        output = self.ssh_ctl_chan.read_channel()
        if &#34;(tcl)&#34; in output:
            self.ssh_ctl_chan.write_channel(TCL_EXIT + &#34;\r&#34;)
        time.sleep(1)
        output += self.ssh_ctl_chan.read_channel()
        return output

    def establish_scp_conn(self) -&gt; None:
        raise NotImplementedError

    def close_scp_chan(self) -&gt; None:
        raise NotImplementedError

    def local_space_available(self) -&gt; bool:
        raise NotImplementedError

    def file_md5(self, file_name: str, add_newline: bool = False) -&gt; str:
        &#34;&#34;&#34;Compute MD5 hash of file.&#34;&#34;&#34;
        if add_newline is True:
            raise ValueError(
                &#34;add_newline argument is not supported for inline transfers.&#34;
            )
        file_contents = self._read_file(file_name)
        file_contents = file_contents + &#34;\n&#34;  # Cisco IOS automatically adds this
        file_contents_bytes = file_contents.encode(&#34;UTF-8&#34;)
        return hashlib.md5(file_contents_bytes).hexdigest()

    def config_md5(self, source_config: str) -&gt; str:
        &#34;&#34;&#34;Compute MD5 hash of text.&#34;&#34;&#34;
        file_contents = source_config + &#34;\n&#34;  # Cisco IOS automatically adds this
        file_contents_bytes = file_contents.encode(&#34;UTF-8&#34;)
        return hashlib.md5(file_contents_bytes).hexdigest()

    def put_file(self) -&gt; None:
        curlybrace = r&#34;{&#34;
        TCL_FILECMD_ENTER = &#39;puts [open &#34;{}{}&#34; w+] {}&#39;.format(
            self.file_system, self.dest_file, curlybrace
        )
        TCL_FILECMD_EXIT = &#34;}&#34;

        if self.source_file:
            file_contents = self._read_file(self.source_file)
        elif self.source_config:
            file_contents = self.source_config
        file_contents = self._tcl_newline_rationalize(file_contents)

        # Try to remove any existing data
        self.ssh_ctl_chan.clear_buffer()

        self.ssh_ctl_chan.write_channel(TCL_FILECMD_ENTER)
        time.sleep(0.25)
        self.ssh_ctl_chan.write_channel(file_contents)
        self.ssh_ctl_chan.write_channel(TCL_FILECMD_EXIT + &#34;\r&#34;)

        # This operation can be slow (depends on the size of the file)
        read_timeout = 100
        sleep_time = 4
        if self.file_size &gt;= 2500:
            read_timeout = 300
            sleep_time = 12
        elif self.file_size &gt;= 7500:
            read_timeout = 600
            sleep_time = 25

        # Initial delay
        time.sleep(sleep_time)

        # File paste and TCL_FILECMD_exit should be indicated by &#34;router(tcl)#&#34;
        output = self.ssh_ctl_chan.read_until_pattern(
            pattern=r&#34;\(tcl\).*$&#34;, re_flags=re.M, read_timeout=read_timeout
        )

        # The file doesn&#39;t write until tclquit
        TCL_EXIT = &#34;tclquit&#34;
        self.ssh_ctl_chan.write_channel(TCL_EXIT + &#34;\r&#34;)

        time.sleep(1)
        # Read all data remaining from the TCLSH session
        pattern = rf&#34;tclquit.*{self.ssh_ctl_chan.base_prompt}.*$&#34;
        re_flags = re.DOTALL | re.M
        output += self.ssh_ctl_chan.read_until_pattern(
            pattern=pattern, re_flags=re_flags, read_timeout=read_timeout
        )
        return None

    def get_file(self) -&gt; None:
        raise NotImplementedError

    def enable_scp(self, cmd: str = &#34;&#34;) -&gt; None:
        raise NotImplementedError

    def disable_scp(self, cmd: str = &#34;&#34;) -&gt; None:
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer" href="cisco/cisco_ios.html#netmiko.cisco.cisco_ios.CiscoIosFileTransfer">CiscoIosFileTransfer</a></li>
<li><a title="netmiko.cisco_base_connection.CiscoFileTransfer" href="cisco_base_connection.html#netmiko.cisco_base_connection.CiscoFileTransfer">CiscoFileTransfer</a></li>
<li><a title="netmiko.scp_handler.BaseFileTransfer" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer">BaseFileTransfer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="netmiko.InLineTransfer.config_md5"><code class="name flex">
<span>def <span class="ident">config_md5</span></span>(<span>self, source_config: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Compute MD5 hash of text.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_md5(self, source_config: str) -&gt; str:
    &#34;&#34;&#34;Compute MD5 hash of text.&#34;&#34;&#34;
    file_contents = source_config + &#34;\n&#34;  # Cisco IOS automatically adds this
    file_contents_bytes = file_contents.encode(&#34;UTF-8&#34;)
    return hashlib.md5(file_contents_bytes).hexdigest()</code></pre>
</details>
</dd>
<dt id="netmiko.InLineTransfer.file_md5"><code class="name flex">
<span>def <span class="ident">file_md5</span></span>(<span>self, file_name: str, add_newline: bool = False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Compute MD5 hash of file.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def file_md5(self, file_name: str, add_newline: bool = False) -&gt; str:
    &#34;&#34;&#34;Compute MD5 hash of file.&#34;&#34;&#34;
    if add_newline is True:
        raise ValueError(
            &#34;add_newline argument is not supported for inline transfers.&#34;
        )
    file_contents = self._read_file(file_name)
    file_contents = file_contents + &#34;\n&#34;  # Cisco IOS automatically adds this
    file_contents_bytes = file_contents.encode(&#34;UTF-8&#34;)
    return hashlib.md5(file_contents_bytes).hexdigest()</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer" href="cisco/cisco_ios.html#netmiko.cisco.cisco_ios.CiscoIosFileTransfer">CiscoIosFileTransfer</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.check_file_exists" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.check_file_exists">check_file_exists</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.close_scp_chan" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.close_scp_chan">close_scp_chan</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.compare_md5" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.compare_md5">compare_md5</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.disable_scp" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.disable_scp">disable_scp</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.enable_scp" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.enable_scp">enable_scp</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.establish_scp_conn" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.establish_scp_conn">establish_scp_conn</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.get_file" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.get_file">get_file</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.local_space_available" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.local_space_available">local_space_available</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.process_md5" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.process_md5">process_md5</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.put_file" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.put_file">put_file</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.remote_file_size" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_file_size">remote_file_size</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.remote_md5" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_md5">remote_md5</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.remote_space_available" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_space_available">remote_space_available</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.transfer_file" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.transfer_file">transfer_file</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.verify_file" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.verify_file">verify_file</a></code></li>
<li><code><a title="netmiko.cisco.cisco_ios.CiscoIosFileTransfer.verify_space_available" href="scp_handler.html#netmiko.scp_handler.BaseFileTransfer.verify_space_available">verify_space_available</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="netmiko.NetmikoAuthenticationException"><code class="flex name class">
<span>class <span class="ident">NetmikoAuthenticationException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>SSH authentication exception based on Paramiko AuthenticationException.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetmikoAuthenticationException(AuthenticationException):
    &#34;&#34;&#34;SSH authentication exception based on Paramiko AuthenticationException.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>paramiko.ssh_exception.AuthenticationException</li>
<li>paramiko.ssh_exception.SSHException</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="netmiko.NetmikoAuthenticationException"><code class="flex name class">
<span>class <span class="ident">NetMikoAuthenticationException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>SSH authentication exception based on Paramiko AuthenticationException.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetmikoAuthenticationException(AuthenticationException):
    &#34;&#34;&#34;SSH authentication exception based on Paramiko AuthenticationException.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>paramiko.ssh_exception.AuthenticationException</li>
<li>paramiko.ssh_exception.SSHException</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="netmiko.NetmikoBaseException"><code class="flex name class">
<span>class <span class="ident">NetmikoBaseException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>General base exception except for exceptions that inherit from Paramiko.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetmikoBaseException(Exception):
    &#34;&#34;&#34;General base exception except for exceptions that inherit from Paramiko.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="netmiko.exceptions.ConfigInvalidException" href="exceptions.html#netmiko.exceptions.ConfigInvalidException">ConfigInvalidException</a></li>
<li><a title="netmiko.exceptions.ConnectionException" href="exceptions.html#netmiko.exceptions.ConnectionException">ConnectionException</a></li>
<li><a title="netmiko.exceptions.ReadException" href="exceptions.html#netmiko.exceptions.ReadException">ReadException</a></li>
<li><a title="netmiko.exceptions.WriteException" href="exceptions.html#netmiko.exceptions.WriteException">WriteException</a></li>
</ul>
</dd>
<dt id="netmiko.NetmikoTimeoutException"><code class="flex name class">
<span>class <span class="ident">NetmikoTimeoutException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>SSH session timed trying to connect to the device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetmikoTimeoutException(SSHException):
    &#34;&#34;&#34;SSH session timed trying to connect to the device.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>paramiko.ssh_exception.SSHException</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="netmiko.NetmikoTimeoutException"><code class="flex name class">
<span>class <span class="ident">NetMikoTimeoutException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>SSH session timed trying to connect to the device.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class NetmikoTimeoutException(SSHException):
    &#34;&#34;&#34;SSH session timed trying to connect to the device.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li>paramiko.ssh_exception.SSHException</li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="netmiko.ReadException"><code class="flex name class">
<span>class <span class="ident">ReadException</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>General exception indicating an error occurred during a Netmiko read operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadException(NetmikoBaseException):
    &#34;&#34;&#34;General exception indicating an error occurred during a Netmiko read operation.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.exceptions.NetmikoBaseException" href="exceptions.html#netmiko.exceptions.NetmikoBaseException">NetmikoBaseException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="netmiko.exceptions.ReadTimeout" href="exceptions.html#netmiko.exceptions.ReadTimeout">ReadTimeout</a></li>
</ul>
</dd>
<dt id="netmiko.ReadTimeout"><code class="flex name class">
<span>class <span class="ident">ReadTimeout</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>General exception indicating an error occurred during a Netmiko read operation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ReadTimeout(ReadException):
    &#34;&#34;&#34;General exception indicating an error occurred during a Netmiko read operation.&#34;&#34;&#34;

    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.exceptions.ReadException" href="exceptions.html#netmiko.exceptions.ReadException">ReadException</a></li>
<li><a title="netmiko.exceptions.NetmikoBaseException" href="exceptions.html#netmiko.exceptions.NetmikoBaseException">NetmikoBaseException</a></li>
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="netmiko.SCPConn"><code class="flex name class">
<span>class <span class="ident">SCPConn</span></span>
<span>(</span><span>ssh_conn: <a title="netmiko.BaseConnection" href="#netmiko.BaseConnection">BaseConnection</a>, socket_timeout: float = 10.0, progress: Optional[Callable[..., Any]] = None, progress4: Optional[Callable[..., Any]] = None)</span>
</code></dt>
<dd>
<div class="desc"><p>Establish a secure copy channel to the remote network device.</p>
<p>Must close the SCP connection to get the file to write to the remote filesystem</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SCPConn(object):
    &#34;&#34;&#34;
    Establish a secure copy channel to the remote network device.

    Must close the SCP connection to get the file to write to the remote filesystem
    &#34;&#34;&#34;

    def __init__(
        self,
        ssh_conn: &#34;BaseConnection&#34;,
        socket_timeout: float = 10.0,
        progress: Optional[Callable[..., Any]] = None,
        progress4: Optional[Callable[..., Any]] = None,
    ) -&gt; None:
        self.ssh_ctl_chan = ssh_conn
        self.socket_timeout = socket_timeout
        self.progress = progress
        self.progress4 = progress4
        self.establish_scp_conn()

    def establish_scp_conn(self) -&gt; None:
        &#34;&#34;&#34;Establish the secure copy connection.&#34;&#34;&#34;
        ssh_connect_params = self.ssh_ctl_chan._connect_params_dict()
        self.scp_conn = self.ssh_ctl_chan._build_ssh_client()
        self.scp_conn.connect(**ssh_connect_params)
        self.scp_client = scp.SCPClient(
            self.scp_conn.get_transport(),
            socket_timeout=self.socket_timeout,
            progress=self.progress,
            progress4=self.progress4,
        )

    def scp_transfer_file(self, source_file: str, dest_file: str) -&gt; None:
        &#34;&#34;&#34;Put file using SCP (for backwards compatibility).&#34;&#34;&#34;
        self.scp_client.put(source_file, dest_file)

    def scp_get_file(self, source_file: str, dest_file: str) -&gt; None:
        &#34;&#34;&#34;Get file using SCP.&#34;&#34;&#34;
        self.scp_client.get(source_file, dest_file)

    def scp_put_file(self, source_file: str, dest_file: str) -&gt; None:
        &#34;&#34;&#34;Put file using SCP.&#34;&#34;&#34;
        self.scp_client.put(source_file, dest_file)

    def close(self) -&gt; None:
        &#34;&#34;&#34;Close the SCP connection.&#34;&#34;&#34;
        self.scp_conn.close()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="netmiko.SCPConn.close"><code class="name flex">
<span>def <span class="ident">close</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Close the SCP connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close(self) -&gt; None:
    &#34;&#34;&#34;Close the SCP connection.&#34;&#34;&#34;
    self.scp_conn.close()</code></pre>
</details>
</dd>
<dt id="netmiko.SCPConn.establish_scp_conn"><code class="name flex">
<span>def <span class="ident">establish_scp_conn</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Establish the secure copy connection.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def establish_scp_conn(self) -&gt; None:
    &#34;&#34;&#34;Establish the secure copy connection.&#34;&#34;&#34;
    ssh_connect_params = self.ssh_ctl_chan._connect_params_dict()
    self.scp_conn = self.ssh_ctl_chan._build_ssh_client()
    self.scp_conn.connect(**ssh_connect_params)
    self.scp_client = scp.SCPClient(
        self.scp_conn.get_transport(),
        socket_timeout=self.socket_timeout,
        progress=self.progress,
        progress4=self.progress4,
    )</code></pre>
</details>
</dd>
<dt id="netmiko.SCPConn.scp_get_file"><code class="name flex">
<span>def <span class="ident">scp_get_file</span></span>(<span>self, source_file: str, dest_file: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Get file using SCP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scp_get_file(self, source_file: str, dest_file: str) -&gt; None:
    &#34;&#34;&#34;Get file using SCP.&#34;&#34;&#34;
    self.scp_client.get(source_file, dest_file)</code></pre>
</details>
</dd>
<dt id="netmiko.SCPConn.scp_put_file"><code class="name flex">
<span>def <span class="ident">scp_put_file</span></span>(<span>self, source_file: str, dest_file: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Put file using SCP.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scp_put_file(self, source_file: str, dest_file: str) -&gt; None:
    &#34;&#34;&#34;Put file using SCP.&#34;&#34;&#34;
    self.scp_client.put(source_file, dest_file)</code></pre>
</details>
</dd>
<dt id="netmiko.SCPConn.scp_transfer_file"><code class="name flex">
<span>def <span class="ident">scp_transfer_file</span></span>(<span>self, source_file: str, dest_file: str) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Put file using SCP (for backwards compatibility).</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def scp_transfer_file(self, source_file: str, dest_file: str) -&gt; None:
    &#34;&#34;&#34;Put file using SCP (for backwards compatibility).&#34;&#34;&#34;
    self.scp_client.put(source_file, dest_file)</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="netmiko.SSHDetect"><code class="flex name class">
<span>class <span class="ident">SSHDetect</span></span>
<span>(</span><span>*args: Any, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>The SSHDetect class tries to automatically guess the device type running on the SSH remote end.
Be careful that the kwargs 'device_type' must be set to 'autodetect', otherwise it won't work at
all.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>*args</code></strong> :&ensp;<code>list</code></dt>
<dd>The same *args that you might provide to the netmiko.ssh_dispatcher.ConnectHandler.</dd>
<dt><strong><code>*kwargs</code></strong> :&ensp;<code>dict</code></dt>
<dd>The same *kwargs that you might provide to the netmiko.ssh_dispatcher.ConnectHandler.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>connection</code></strong> :&ensp;<code><a title="netmiko.terminal_server.TerminalServerSSH" href="terminal_server/index.html#netmiko.terminal_server.TerminalServerSSH">TerminalServerSSH</a></code></dt>
<dd>A basic connection to the remote SSH end.</dd>
<dt><strong><code>potential_matches</code></strong> :&ensp;<code>dict</code></dt>
<dd>Dict of (device_type, accuracy) that is populated through an interaction with the
remote end.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>autodetect()
Try to determine the device type.</p>
<p>Constructor of the SSHDetect class</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class SSHDetect(object):
    &#34;&#34;&#34;
    The SSHDetect class tries to automatically guess the device type running on the SSH remote end.
    Be careful that the kwargs &#39;device_type&#39; must be set to &#39;autodetect&#39;, otherwise it won&#39;t work at
    all.

    Parameters
    ----------
    *args : list
        The same *args that you might provide to the netmiko.ssh_dispatcher.ConnectHandler.
    *kwargs : dict
        The same *kwargs that you might provide to the netmiko.ssh_dispatcher.ConnectHandler.

    Attributes
    ----------
    connection : netmiko.terminal_server.TerminalServerSSH
        A basic connection to the remote SSH end.
    potential_matches: dict
        Dict of (device_type, accuracy) that is populated through an interaction with the
        remote end.

    Methods
    -------
    autodetect()
        Try to determine the device type.
    &#34;&#34;&#34;

    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
        &#34;&#34;&#34;
        Constructor of the SSHDetect class
        &#34;&#34;&#34;
        if kwargs[&#34;device_type&#34;] != &#34;autodetect&#34;:
            raise ValueError(&#34;The connection device_type must be &#39;autodetect&#39;&#34;)
        # Always set cmd_verify to False for autodetect
        kwargs[&#34;global_cmd_verify&#34;] = False
        self.connection = ConnectHandler(*args, **kwargs)
        # Call the _test_channel_read() in base to clear initial data
        output = BaseConnection._test_channel_read(self.connection)
        self.initial_buffer = output
        self.potential_matches: Dict[str, int] = {}
        self._results_cache: Dict[str, str] = {}

    def autodetect(self) -&gt; Union[str, None]:
        &#34;&#34;&#34;
        Try to guess the best &#39;device_type&#39; based on patterns defined in SSH_MAPPER_BASE

        Returns
        -------
        best_match : str or None
            The device type that is currently the best to use to interact with the device
        &#34;&#34;&#34;
        for device_type, autodetect_dict in SSH_MAPPER_BASE:
            tmp_dict = autodetect_dict.copy()
            call_method = tmp_dict.pop(&#34;dispatch&#34;)
            assert isinstance(call_method, str)
            autodetect_method = getattr(self, call_method)
            accuracy = autodetect_method(**tmp_dict)
            if accuracy:
                self.potential_matches[device_type] = accuracy
                if accuracy &gt;= 99:  # Stop the loop as we are sure of our match
                    best_match = sorted(
                        self.potential_matches.items(), key=lambda t: t[1], reverse=True
                    )
                    # WLC needs two different auto-dectect solutions
                    if &#34;cisco_wlc_85&#34; in best_match[0]:
                        best_match[0] = (&#34;cisco_wlc&#34;, 99)

                    self.connection.disconnect()
                    return best_match[0][0]

        if not self.potential_matches:
            self.connection.disconnect()
            return None

        best_match = sorted(
            self.potential_matches.items(), key=lambda t: t[1], reverse=True
        )
        self.connection.disconnect()
        return best_match[0][0]

    def _send_command(self, cmd: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;
        Handle reading/writing channel directly. It is also sanitizing the output received.

        Parameters
        ----------
        cmd : str, optional
            The command to send to the remote device (default : &#34;&#34;, just send a new line)

        Returns
        -------
        output : str
            The output from the command sent
        &#34;&#34;&#34;
        self.connection.write_channel(cmd + &#34;\n&#34;)
        time.sleep(1)
        output = self.connection.read_channel_timing()
        output = self.connection.strip_backspaces(output)
        return output

    def _send_command_wrapper(self, cmd: str) -&gt; str:
        &#34;&#34;&#34;
        Send command to the remote device with a caching feature to avoid sending the same command
        twice based on the SSH_MAPPER_BASE dict cmd key.

        Parameters
        ----------
        cmd : str
            The command to send to the remote device after checking cache.

        Returns
        -------
        response : str
            The response from the remote device.
        &#34;&#34;&#34;
        cached_results = self._results_cache.get(cmd)
        if not cached_results:
            response = self._send_command(cmd)
            self._results_cache[cmd] = response
            return response
        else:
            return cached_results

    def _autodetect_remote_version(
        self,
        search_patterns: Optional[List[str]] = None,
        re_flags: int = re.IGNORECASE,
        priority: int = 99,
        **kwargs: Any
    ) -&gt; int:
        &#34;&#34;&#34;
        Method to try auto-detect the device type, by matching a regular expression on the reported
        remote version of the SSH server.

        Parameters
        ----------
        search_patterns : list
            A list of regular expression to look for in the reported remote SSH version
            (default: None).
        re_flags: re.flags, optional
            Any flags from the python re module to modify the regular expression (default: re.I).
        priority: int, optional
            The confidence the match is right between 0 and 99 (default: 99).
        &#34;&#34;&#34;
        invalid_responses = [r&#34;^$&#34;]

        if not search_patterns:
            return 0

        try:
            remote_conn = self.connection.remote_conn
            assert isinstance(remote_conn, paramiko.Channel)
            assert remote_conn.transport is not None
            remote_version = remote_conn.transport.remote_version
            for pattern in invalid_responses:
                match = re.search(pattern, remote_version, flags=re.I)
                if match:
                    return 0
            for pattern in search_patterns:
                match = re.search(pattern, remote_version, flags=re_flags)
                if match:
                    return priority
        except Exception:
            return 0
        return 0

    def _autodetect_std(
        self,
        cmd: str = &#34;&#34;,
        search_patterns: Optional[List[str]] = None,
        re_flags: int = re.IGNORECASE,
        priority: int = 99,
    ) -&gt; int:
        &#34;&#34;&#34;
        Standard method to try to auto-detect the device type. This method will be called for each
        device_type present in SSH_MAPPER_BASE dict (&#39;dispatch&#39; key). It will attempt to send a
        command and match some regular expression from the ouput for each entry in SSH_MAPPER_BASE
        (&#39;cmd&#39; and &#39;search_pattern&#39; keys).

        Parameters
        ----------
        cmd : str
            The command to send to the remote device after checking cache.
        search_patterns : list
            A list of regular expression to look for in the command&#39;s output (default: None).
        re_flags: re.flags, optional
            Any flags from the python re module to modify the regular expression (default: re.I).
        priority: int, optional
            The confidence the match is right between 0 and 99 (default: 99).
        &#34;&#34;&#34;
        invalid_responses = [
            r&#34;% Invalid input detected&#34;,
            r&#34;syntax error, expecting&#34;,
            r&#34;Error: Unrecognized command&#34;,
            r&#34;%Error&#34;,
            r&#34;command not found&#34;,
            r&#34;Syntax Error: unexpected argument&#34;,
            r&#34;% Unrecognized command found at&#34;,
        ]
        if not cmd or not search_patterns:
            return 0
        try:
            # _send_command_wrapper will use already cached results if available
            response = self._send_command_wrapper(cmd)
            # Look for error conditions in output
            for pattern in invalid_responses:
                match = re.search(pattern, response, flags=re.I)
                if match:
                    return 0
            for pattern in search_patterns:
                match = re.search(pattern, response, flags=re_flags)
                if match:
                    return priority
        except Exception:
            return 0
        return 0</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="netmiko.SSHDetect.autodetect"><code class="name flex">
<span>def <span class="ident">autodetect</span></span>(<span>self) ‑> Optional[str]</span>
</code></dt>
<dd>
<div class="desc"><p>Try to guess the best 'device_type' based on patterns defined in SSH_MAPPER_BASE</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><strong><code>best_match</code></strong> :&ensp;<code>str</code> or <code>None</code></dt>
<dd>The device type that is currently the best to use to interact with the device</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def autodetect(self) -&gt; Union[str, None]:
    &#34;&#34;&#34;
    Try to guess the best &#39;device_type&#39; based on patterns defined in SSH_MAPPER_BASE

    Returns
    -------
    best_match : str or None
        The device type that is currently the best to use to interact with the device
    &#34;&#34;&#34;
    for device_type, autodetect_dict in SSH_MAPPER_BASE:
        tmp_dict = autodetect_dict.copy()
        call_method = tmp_dict.pop(&#34;dispatch&#34;)
        assert isinstance(call_method, str)
        autodetect_method = getattr(self, call_method)
        accuracy = autodetect_method(**tmp_dict)
        if accuracy:
            self.potential_matches[device_type] = accuracy
            if accuracy &gt;= 99:  # Stop the loop as we are sure of our match
                best_match = sorted(
                    self.potential_matches.items(), key=lambda t: t[1], reverse=True
                )
                # WLC needs two different auto-dectect solutions
                if &#34;cisco_wlc_85&#34; in best_match[0]:
                    best_match[0] = (&#34;cisco_wlc&#34;, 99)

                self.connection.disconnect()
                return best_match[0][0]

    if not self.potential_matches:
        self.connection.disconnect()
        return None

    best_match = sorted(
        self.potential_matches.items(), key=lambda t: t[1], reverse=True
    )
    self.connection.disconnect()
    return best_match[0][0]</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-submodules">Sub-modules</a></h3>
<ul>
<li><code><a title="netmiko.a10" href="a10/index.html">netmiko.a10</a></code></li>
<li><code><a title="netmiko.accedian" href="accedian/index.html">netmiko.accedian</a></code></li>
<li><code><a title="netmiko.adtran" href="adtran/index.html">netmiko.adtran</a></code></li>
<li><code><a title="netmiko.alcatel" href="alcatel/index.html">netmiko.alcatel</a></code></li>
<li><code><a title="netmiko.allied_telesis" href="allied_telesis/index.html">netmiko.allied_telesis</a></code></li>
<li><code><a title="netmiko.apresia" href="apresia/index.html">netmiko.apresia</a></code></li>
<li><code><a title="netmiko.arista" href="arista/index.html">netmiko.arista</a></code></li>
<li><code><a title="netmiko.aruba" href="aruba/index.html">netmiko.aruba</a></code></li>
<li><code><a title="netmiko.audiocode" href="audiocode/index.html">netmiko.audiocode</a></code></li>
<li><code><a title="netmiko.base_connection" href="base_connection.html">netmiko.base_connection</a></code></li>
<li><code><a title="netmiko.broadcom" href="broadcom/index.html">netmiko.broadcom</a></code></li>
<li><code><a title="netmiko.brocade" href="brocade/index.html">netmiko.brocade</a></code></li>
<li><code><a title="netmiko.calix" href="calix/index.html">netmiko.calix</a></code></li>
<li><code><a title="netmiko.cdot" href="cdot/index.html">netmiko.cdot</a></code></li>
<li><code><a title="netmiko.centec" href="centec/index.html">netmiko.centec</a></code></li>
<li><code><a title="netmiko.channel" href="channel.html">netmiko.channel</a></code></li>
<li><code><a title="netmiko.checkpoint" href="checkpoint/index.html">netmiko.checkpoint</a></code></li>
<li><code><a title="netmiko.ciena" href="ciena/index.html">netmiko.ciena</a></code></li>
<li><code><a title="netmiko.cisco" href="cisco/index.html">netmiko.cisco</a></code></li>
<li><code><a title="netmiko.cisco_base_connection" href="cisco_base_connection.html">netmiko.cisco_base_connection</a></code></li>
<li><code><a title="netmiko.citrix" href="citrix/index.html">netmiko.citrix</a></code></li>
<li><code><a title="netmiko.cli_tools" href="cli_tools/index.html">netmiko.cli_tools</a></code></li>
<li><code><a title="netmiko.cloudgenix" href="cloudgenix/index.html">netmiko.cloudgenix</a></code></li>
<li><code><a title="netmiko.coriant" href="coriant/index.html">netmiko.coriant</a></code></li>
<li><code><a title="netmiko.dell" href="dell/index.html">netmiko.dell</a></code></li>
<li><code><a title="netmiko.dlink" href="dlink/index.html">netmiko.dlink</a></code></li>
<li><code><a title="netmiko.eltex" href="eltex/index.html">netmiko.eltex</a></code></li>
<li><code><a title="netmiko.endace" href="endace/index.html">netmiko.endace</a></code></li>
<li><code><a title="netmiko.enterasys" href="enterasys/index.html">netmiko.enterasys</a></code></li>
<li><code><a title="netmiko.ericsson" href="ericsson/index.html">netmiko.ericsson</a></code></li>
<li><code><a title="netmiko.exceptions" href="exceptions.html">netmiko.exceptions</a></code></li>
<li><code><a title="netmiko.extreme" href="extreme/index.html">netmiko.extreme</a></code></li>
<li><code><a title="netmiko.f5" href="f5/index.html">netmiko.f5</a></code></li>
<li><code><a title="netmiko.flexvnf" href="flexvnf/index.html">netmiko.flexvnf</a></code></li>
<li><code><a title="netmiko.fortinet" href="fortinet/index.html">netmiko.fortinet</a></code></li>
<li><code><a title="netmiko.hp" href="hp/index.html">netmiko.hp</a></code></li>
<li><code><a title="netmiko.huawei" href="huawei/index.html">netmiko.huawei</a></code></li>
<li><code><a title="netmiko.ipinfusion" href="ipinfusion/index.html">netmiko.ipinfusion</a></code></li>
<li><code><a title="netmiko.juniper" href="juniper/index.html">netmiko.juniper</a></code></li>
<li><code><a title="netmiko.keymile" href="keymile/index.html">netmiko.keymile</a></code></li>
<li><code><a title="netmiko.linux" href="linux/index.html">netmiko.linux</a></code></li>
<li><code><a title="netmiko.mellanox" href="mellanox/index.html">netmiko.mellanox</a></code></li>
<li><code><a title="netmiko.mikrotik" href="mikrotik/index.html">netmiko.mikrotik</a></code></li>
<li><code><a title="netmiko.mrv" href="mrv/index.html">netmiko.mrv</a></code></li>
<li><code><a title="netmiko.netapp" href="netapp/index.html">netmiko.netapp</a></code></li>
<li><code><a title="netmiko.netgear" href="netgear/index.html">netmiko.netgear</a></code></li>
<li><code><a title="netmiko.netmiko_globals" href="netmiko_globals.html">netmiko.netmiko_globals</a></code></li>
<li><code><a title="netmiko.no_config" href="no_config.html">netmiko.no_config</a></code></li>
<li><code><a title="netmiko.no_enable" href="no_enable.html">netmiko.no_enable</a></code></li>
<li><code><a title="netmiko.nokia" href="nokia/index.html">netmiko.nokia</a></code></li>
<li><code><a title="netmiko.oneaccess" href="oneaccess/index.html">netmiko.oneaccess</a></code></li>
<li><code><a title="netmiko.ovs" href="ovs/index.html">netmiko.ovs</a></code></li>
<li><code><a title="netmiko.paloalto" href="paloalto/index.html">netmiko.paloalto</a></code></li>
<li><code><a title="netmiko.pluribus" href="pluribus/index.html">netmiko.pluribus</a></code></li>
<li><code><a title="netmiko.quanta" href="quanta/index.html">netmiko.quanta</a></code></li>
<li><code><a title="netmiko.rad" href="rad/index.html">netmiko.rad</a></code></li>
<li><code><a title="netmiko.raisecom" href="raisecom/index.html">netmiko.raisecom</a></code></li>
<li><code><a title="netmiko.ruckus" href="ruckus/index.html">netmiko.ruckus</a></code></li>
<li><code><a title="netmiko.ruijie" href="ruijie/index.html">netmiko.ruijie</a></code></li>
<li><code><a title="netmiko.scp_functions" href="scp_functions.html">netmiko.scp_functions</a></code></li>
<li><code><a title="netmiko.scp_handler" href="scp_handler.html">netmiko.scp_handler</a></code></li>
<li><code><a title="netmiko.session_log" href="session_log.html">netmiko.session_log</a></code></li>
<li><code><a title="netmiko.sixwind" href="sixwind/index.html">netmiko.sixwind</a></code></li>
<li><code><a title="netmiko.snmp_autodetect" href="snmp_autodetect.html">netmiko.snmp_autodetect</a></code></li>
<li><code><a title="netmiko.sophos" href="sophos/index.html">netmiko.sophos</a></code></li>
<li><code><a title="netmiko.ssh_auth" href="ssh_auth.html">netmiko.ssh_auth</a></code></li>
<li><code><a title="netmiko.ssh_autodetect" href="ssh_autodetect.html">netmiko.ssh_autodetect</a></code></li>
<li><code><a title="netmiko.supermicro" href="supermicro/index.html">netmiko.supermicro</a></code></li>
<li><code><a title="netmiko.terminal_server" href="terminal_server/index.html">netmiko.terminal_server</a></code></li>
<li><code><a title="netmiko.tplink" href="tplink/index.html">netmiko.tplink</a></code></li>
<li><code><a title="netmiko.ubiquiti" href="ubiquiti/index.html">netmiko.ubiquiti</a></code></li>
<li><code><a title="netmiko.utilities" href="utilities.html">netmiko.utilities</a></code></li>
<li><code><a title="netmiko.vyos" href="vyos/index.html">netmiko.vyos</a></code></li>
<li><code><a title="netmiko.watchguard" href="watchguard/index.html">netmiko.watchguard</a></code></li>
<li><code><a title="netmiko.yamaha" href="yamaha/index.html">netmiko.yamaha</a></code></li>
<li><code><a title="netmiko.zte" href="zte/index.html">netmiko.zte</a></code></li>
<li><code><a title="netmiko.zyxel" href="zyxel/index.html">netmiko.zyxel</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="netmiko.ConnLogOnly" href="#netmiko.ConnLogOnly">ConnLogOnly</a></code></li>
<li><code><a title="netmiko.ConnUnify" href="#netmiko.ConnUnify">ConnUnify</a></code></li>
<li><code><a title="netmiko.ConnectHandler" href="#netmiko.ConnectHandler">ConnectHandler</a></code></li>
<li><code><a title="netmiko.FileTransfer" href="#netmiko.FileTransfer">FileTransfer</a></code></li>
<li><code><a title="netmiko.Netmiko" href="#netmiko.Netmiko">Netmiko</a></code></li>
<li><code><a title="netmiko.file_transfer" href="#netmiko.file_transfer">file_transfer</a></code></li>
<li><code><a title="netmiko.progress_bar" href="#netmiko.progress_bar">progress_bar</a></code></li>
<li><code><a title="netmiko.redispatch" href="#netmiko.redispatch">redispatch</a></code></li>
<li><code><a title="netmiko.ssh_dispatcher" href="#netmiko.ssh_dispatcher">ssh_dispatcher</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="netmiko.BaseConnection" href="#netmiko.BaseConnection">BaseConnection</a></code></h4>
<ul class="">
<li><code><a title="netmiko.BaseConnection.check_config_mode" href="#netmiko.BaseConnection.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.BaseConnection.check_enable_mode" href="#netmiko.BaseConnection.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.BaseConnection.cleanup" href="#netmiko.BaseConnection.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.BaseConnection.clear_buffer" href="#netmiko.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.BaseConnection.command_echo_read" href="#netmiko.BaseConnection.command_echo_read">command_echo_read</a></code></li>
<li><code><a title="netmiko.BaseConnection.commit" href="#netmiko.BaseConnection.commit">commit</a></code></li>
<li><code><a title="netmiko.BaseConnection.config_mode" href="#netmiko.BaseConnection.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.BaseConnection.disable_paging" href="#netmiko.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.BaseConnection.disconnect" href="#netmiko.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.BaseConnection.enable" href="#netmiko.BaseConnection.enable">enable</a></code></li>
<li><code><a title="netmiko.BaseConnection.establish_connection" href="#netmiko.BaseConnection.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.BaseConnection.exit_config_mode" href="#netmiko.BaseConnection.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.BaseConnection.exit_enable_mode" href="#netmiko.BaseConnection.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.BaseConnection.find_prompt" href="#netmiko.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.BaseConnection.is_alive" href="#netmiko.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.BaseConnection.normalize_cmd" href="#netmiko.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.BaseConnection.normalize_linefeeds" href="#netmiko.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.BaseConnection.paramiko_cleanup" href="#netmiko.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.BaseConnection.read_channel" href="#netmiko.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.BaseConnection.read_channel_timing" href="#netmiko.BaseConnection.read_channel_timing">read_channel_timing</a></code></li>
<li><code><a title="netmiko.BaseConnection.read_until_pattern" href="#netmiko.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.BaseConnection.read_until_prompt" href="#netmiko.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.BaseConnection.read_until_prompt_or_pattern" href="#netmiko.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.BaseConnection.run_ttp" href="#netmiko.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.BaseConnection.save_config" href="#netmiko.BaseConnection.save_config">save_config</a></code></li>
<li><code><a title="netmiko.BaseConnection.select_delay_factor" href="#netmiko.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.BaseConnection.send_command" href="#netmiko.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.BaseConnection.send_command_expect" href="#netmiko.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.BaseConnection.send_command_timing" href="#netmiko.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.BaseConnection.send_config_from_file" href="#netmiko.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.BaseConnection.send_config_set" href="#netmiko.BaseConnection.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.BaseConnection.send_multiline" href="#netmiko.BaseConnection.send_multiline">send_multiline</a></code></li>
<li><code><a title="netmiko.BaseConnection.send_multiline_timing" href="#netmiko.BaseConnection.send_multiline_timing">send_multiline_timing</a></code></li>
<li><code><a title="netmiko.BaseConnection.serial_login" href="#netmiko.BaseConnection.serial_login">serial_login</a></code></li>
<li><code><a title="netmiko.BaseConnection.session_preparation" href="#netmiko.BaseConnection.session_preparation">session_preparation</a></code></li>
<li><code><a title="netmiko.BaseConnection.set_base_prompt" href="#netmiko.BaseConnection.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.BaseConnection.set_terminal_width" href="#netmiko.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.BaseConnection.special_login_handler" href="#netmiko.BaseConnection.special_login_handler">special_login_handler</a></code></li>
<li><code><a title="netmiko.BaseConnection.strip_ansi_escape_codes" href="#netmiko.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.BaseConnection.strip_backspaces" href="#netmiko.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.BaseConnection.strip_command" href="#netmiko.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.BaseConnection.strip_prompt" href="#netmiko.BaseConnection.strip_prompt">strip_prompt</a></code></li>
<li><code><a title="netmiko.BaseConnection.telnet_login" href="#netmiko.BaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.BaseConnection.write_channel" href="#netmiko.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="netmiko.ConfigInvalidException" href="#netmiko.ConfigInvalidException">ConfigInvalidException</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.ConnectionException" href="#netmiko.ConnectionException">ConnectionException</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.InLineTransfer" href="#netmiko.InLineTransfer">InLineTransfer</a></code></h4>
<ul class="">
<li><code><a title="netmiko.InLineTransfer.config_md5" href="#netmiko.InLineTransfer.config_md5">config_md5</a></code></li>
<li><code><a title="netmiko.InLineTransfer.file_md5" href="#netmiko.InLineTransfer.file_md5">file_md5</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="netmiko.NetmikoAuthenticationException" href="#netmiko.NetmikoAuthenticationException">NetmikoAuthenticationException</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.NetmikoAuthenticationException" href="#netmiko.NetmikoAuthenticationException">NetmikoAuthenticationException</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.NetmikoBaseException" href="#netmiko.NetmikoBaseException">NetmikoBaseException</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.NetmikoTimeoutException" href="#netmiko.NetmikoTimeoutException">NetmikoTimeoutException</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.NetmikoTimeoutException" href="#netmiko.NetmikoTimeoutException">NetmikoTimeoutException</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.ReadException" href="#netmiko.ReadException">ReadException</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.ReadTimeout" href="#netmiko.ReadTimeout">ReadTimeout</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.SCPConn" href="#netmiko.SCPConn">SCPConn</a></code></h4>
<ul class="">
<li><code><a title="netmiko.SCPConn.close" href="#netmiko.SCPConn.close">close</a></code></li>
<li><code><a title="netmiko.SCPConn.establish_scp_conn" href="#netmiko.SCPConn.establish_scp_conn">establish_scp_conn</a></code></li>
<li><code><a title="netmiko.SCPConn.scp_get_file" href="#netmiko.SCPConn.scp_get_file">scp_get_file</a></code></li>
<li><code><a title="netmiko.SCPConn.scp_put_file" href="#netmiko.SCPConn.scp_put_file">scp_put_file</a></code></li>
<li><code><a title="netmiko.SCPConn.scp_transfer_file" href="#netmiko.SCPConn.scp_transfer_file">scp_transfer_file</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="netmiko.SSHDetect" href="#netmiko.SSHDetect">SSHDetect</a></code></h4>
<ul class="">
<li><code><a title="netmiko.SSHDetect.autodetect" href="#netmiko.SSHDetect.autodetect">autodetect</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>