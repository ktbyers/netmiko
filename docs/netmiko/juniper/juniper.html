<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>netmiko.juniper.juniper API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>netmiko.juniper.juniper</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">import re
import warnings
from typing import Optional, Any

from netmiko.no_enable import NoEnable
from netmiko.base_connection import BaseConnection, DELAY_FACTOR_DEPR_SIMPLE_MSG
from netmiko.scp_handler import BaseFileTransfer


class JuniperBase(NoEnable, BaseConnection):
    &#34;&#34;&#34;
    Implement methods for interacting with Juniper Networks devices.

    methods.  Overrides several methods for Juniper-specific compatibility.
    &#34;&#34;&#34;

    def session_preparation(self) -&gt; None:
        &#34;&#34;&#34;Prepare the session after the connection has been established.&#34;&#34;&#34;
        pattern = r&#34;[%&gt;$#]&#34;
        self._test_channel_read(pattern=pattern)
        self.enter_cli_mode()

        cmd = &#34;set cli screen-width 511&#34;
        self.set_terminal_width(command=cmd, pattern=r&#34;Screen width set to&#34;)
        # Overloading disable_paging which is confusing
        self.disable_paging(
            command=&#34;set cli complete-on-space off&#34;,
            pattern=r&#34;Disabling complete-on-space&#34;,
        )
        self.disable_paging(
            command=&#34;set cli screen-length 0&#34;, pattern=r&#34;Screen length set to&#34;
        )
        self.set_base_prompt()

    def _enter_shell(self) -&gt; str:
        &#34;&#34;&#34;Enter the Bourne Shell.&#34;&#34;&#34;
        return self._send_command_str(&#34;start shell sh&#34;, expect_string=r&#34;[\$#]&#34;)

    def _return_cli(self) -&gt; str:
        &#34;&#34;&#34;Return to the Juniper CLI.&#34;&#34;&#34;
        return self._send_command_str(&#34;exit&#34;, expect_string=r&#34;[#&gt;]&#34;)

    def _determine_mode(self, data: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Determine whether in shell or CLI.&#34;&#34;&#34;
        pattern = r&#34;[%&gt;$#]&#34;
        if not data:
            self.write_channel(self.RETURN)
            data = self.read_until_pattern(pattern=pattern, read_timeout=10)

        shell_pattern = r&#34;(?:root@|%|\$)&#34;
        if re.search(shell_pattern, data):
            return &#34;shell&#34;
        elif &#34;&gt;&#34; in data or &#34;#&#34; in data:
            return &#34;cli&#34;
        else:
            raise ValueError(f&#34;Unexpected data returned for prompt: {data}&#34;)

    def enter_cli_mode(self) -&gt; None:
        &#34;&#34;&#34;Check if at shell prompt root@ and go into CLI.&#34;&#34;&#34;
        mode = self._determine_mode()
        if mode == &#34;shell&#34;:
            shell_pattern = r&#34;(?:root@|%|\$)&#34;
            self.write_channel(self.RETURN)
            cur_prompt = self.read_until_pattern(pattern=shell_pattern, read_timeout=10)
            if re.search(r&#34;root@&#34;, cur_prompt) or re.search(r&#34;^%$&#34;, cur_prompt.strip()):
                cli_pattern = r&#34;[&gt;#]&#34;
                self.write_channel(&#34;cli&#34; + self.RETURN)
                self.read_until_pattern(pattern=cli_pattern, read_timeout=10)
        return

    def check_config_mode(
        self,
        check_string: str = &#34;]&#34;,
        pattern: str = r&#34;(?m:[&gt;#] $)&#34;,
        force_regex: bool = False,
    ) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the device is in configuration mode or not.

        ?m = Use multiline matching

        Juniper unfortunately will use # as a message indicator when not in config mode
        For example, with commit confirmed.

        &#34;&#34;&#34;
        return super().check_config_mode(check_string=check_string, pattern=pattern)

    def config_mode(
        self,
        config_command: str = &#34;configure&#34;,
        pattern: str = r&#34;(?s:Entering configuration mode.*\].*#)&#34;,
        re_flags: int = 0,
    ) -&gt; str:
        &#34;&#34;&#34;
        Enter configuration mode.

        ?s = enables re.DOTALL in regex pattern.
        &#34;&#34;&#34;
        return super().config_mode(
            config_command=config_command, pattern=pattern, re_flags=re_flags
        )

    def exit_config_mode(
        self, exit_config: str = &#34;exit configuration-mode&#34;, pattern: str = &#34;&#34;
    ) -&gt; str:
        &#34;&#34;&#34;Exit configuration mode.&#34;&#34;&#34;
        output = &#34;&#34;
        if self.check_config_mode():
            confirm_msg = &#34;Exit with uncommitted changes&#34;
            pattern = rf&#34;(?:&gt;|{confirm_msg})&#34;
            output = self._send_command_str(
                exit_config,
                expect_string=pattern,
                strip_prompt=False,
                strip_command=False,
            )
            if confirm_msg in output:
                output += self._send_command_str(
                    &#34;yes&#34;, expect_string=r&#34;&gt;&#34;, strip_prompt=False, strip_command=False
                )
            if self.check_config_mode():
                raise ValueError(&#34;Failed to exit configuration mode&#34;)
        return output

    def commit(
        self,
        confirm: bool = False,
        confirm_delay: Optional[int] = None,
        check: bool = False,
        comment: str = &#34;&#34;,
        and_quit: bool = False,
        read_timeout: float = 120.0,
        delay_factor: Optional[float] = None,
    ) -&gt; str:
        &#34;&#34;&#34;
        Commit the candidate configuration.

        Commit the entered configuration. Raise an error and return the failure
        if the commit fails.

        Automatically enters configuration mode

        default:
            command_string = commit
        check and (confirm or confirm_dely or comment):
            Exception
        confirm_delay and no confirm:
            Exception
        confirm:
            confirm_delay option
            comment option
            command_string = commit confirmed or commit confirmed &lt;confirm_delay&gt;
        check:
            command_string = commit check

        delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        &#34;&#34;&#34;

        if delay_factor is not None:
            warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)
        if check and (confirm or confirm_delay or comment):
            raise ValueError(&#34;Invalid arguments supplied with commit check&#34;)
        if confirm_delay and not confirm:
            raise ValueError(
                &#34;Invalid arguments supplied to commit method both confirm and check&#34;
            )

        # Select proper command string based on arguments provided
        command_string = &#34;commit&#34;
        commit_marker = &#34;commit complete&#34;
        if check:
            command_string = &#34;commit check&#34;
            commit_marker = &#34;configuration check succeeds&#34;
        elif confirm:
            if confirm_delay:
                command_string = &#34;commit confirmed &#34; + str(confirm_delay)
            else:
                command_string = &#34;commit confirmed&#34;
            commit_marker = &#34;commit confirmed will be automatically rolled back in&#34;

        # wrap the comment in quotes
        if comment:
            if &#39;&#34;&#39; in comment:
                raise ValueError(&#34;Invalid comment contains double quote&#34;)
            comment = f&#39;&#34;{comment}&#34;&#39;
            command_string += &#34; comment &#34; + comment

        if and_quit:
            command_string += &#34; and-quit&#34;

        # Enter config mode (if necessary)
        output = self.config_mode()
        # and_quit will get out of config mode on commit

        expect_string = re.escape(self.base_prompt) if and_quit else None

        output += self._send_command_str(
            command_string,
            expect_string=expect_string,
            strip_prompt=False,
            strip_command=False,
            read_timeout=read_timeout,
        )

        if commit_marker not in output:
            raise ValueError(f&#34;Commit failed with the following errors:\n\n{output}&#34;)

        return output

    def strip_prompt(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Strip the trailing router prompt from the output.&#34;&#34;&#34;
        a_string = super().strip_prompt(*args, **kwargs)
        return self.strip_context_items(a_string)

    def strip_context_items(self, a_string: str) -&gt; str:
        &#34;&#34;&#34;Strip Juniper-specific output.

        Juniper will also put a configuration context:
        [edit]

        and various chassis contexts:
        {master:0}, {backup:1}

        This method removes those lines.
        &#34;&#34;&#34;
        strings_to_strip = [
            r&#34;\[edit.*\]&#34;,
            r&#34;\{master:?.*\}&#34;,
            r&#34;\{backup:?.*\}&#34;,
            r&#34;\{line.*\}&#34;,
            r&#34;\{primary.*\}&#34;,
            r&#34;\{secondary.*\}&#34;,
        ]

        response_list = a_string.split(self.RESPONSE_RETURN)
        last_line = response_list[-1]
        for pattern in strings_to_strip:
            if re.search(pattern, last_line, flags=re.I):
                return self.RESPONSE_RETURN.join(response_list[:-1])
        return a_string

    def cleanup(self, command: str = &#34;exit&#34;) -&gt; None:
        &#34;&#34;&#34;Gracefully exit the SSH session.&#34;&#34;&#34;
        try:
            if self.check_config_mode():
                self.exit_config_mode()
        except Exception:
            pass
        # Always try to send final &#39;exit&#39; (command)
        self._session_log_fin = True
        self.write_channel(command + self.RETURN)


class JuniperSSH(JuniperBase):
    pass


class JuniperTelnet(JuniperBase):
    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
        default_enter = kwargs.get(&#34;default_enter&#34;)
        kwargs[&#34;default_enter&#34;] = &#34;\r\n&#34; if default_enter is None else default_enter
        super().__init__(*args, **kwargs)


class JuniperFileTransfer(BaseFileTransfer):
    &#34;&#34;&#34;Juniper SCP File Transfer driver.&#34;&#34;&#34;

    def __init__(
        self,
        ssh_conn: &#34;BaseConnection&#34;,
        source_file: str,
        dest_file: str,
        file_system: Optional[str] = &#34;/var/tmp&#34;,
        direction: str = &#34;put&#34;,
        **kwargs: Any,
    ) -&gt; None:
        super().__init__(
            ssh_conn=ssh_conn,
            source_file=source_file,
            dest_file=dest_file,
            file_system=file_system,
            direction=direction,
            **kwargs,
        )

    def remote_space_available(self, search_pattern: str = &#34;&#34;) -&gt; int:
        &#34;&#34;&#34;Return space available on remote device.&#34;&#34;&#34;
        return self._remote_space_available_unix(search_pattern=search_pattern)

    def check_file_exists(self, remote_cmd: str = &#34;&#34;) -&gt; bool:
        &#34;&#34;&#34;Check if the dest_file already exists on the file system (return boolean).&#34;&#34;&#34;
        return self._check_file_exists_unix(remote_cmd=remote_cmd)

    def remote_file_size(
        self, remote_cmd: str = &#34;&#34;, remote_file: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;Get the file size of the remote file.&#34;&#34;&#34;
        return self._remote_file_size_unix(
            remote_cmd=remote_cmd, remote_file=remote_file
        )

    def remote_md5(
        self, base_cmd: str = &#34;file checksum md5&#34;, remote_file: Optional[str] = None
    ) -&gt; str:
        return super().remote_md5(base_cmd=base_cmd, remote_file=remote_file)

    def enable_scp(self, cmd: str = &#34;&#34;) -&gt; None:
        raise NotImplementedError

    def disable_scp(self, cmd: str = &#34;&#34;) -&gt; None:
        raise NotImplementedError</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="netmiko.juniper.juniper.JuniperBase"><code class="flex name class">
<span>class <span class="ident">JuniperBase</span></span>
<span>(</span><span>ip: str = '', host: str = '', username: str = '', password: Optional[str] = None, secret: str = '', port: Optional[int] = None, device_type: str = '', verbose: bool = False, global_delay_factor: float = 1.0, global_cmd_verify: Optional[bool] = None, use_keys: bool = False, key_file: Optional[str] = None, pkey: Optional[paramiko.pkey.PKey] = None, passphrase: Optional[str] = None, disabled_algorithms: Optional[Dict[str, Any]] = None, allow_agent: bool = False, ssh_strict: bool = False, system_host_keys: bool = False, alt_host_keys: bool = False, alt_key_file: str = '', ssh_config_file: Optional[str] = None, conn_timeout: int = 10, auth_timeout: Optional[int] = None, banner_timeout: int = 15, blocking_timeout: int = 20, timeout: int = 100, session_timeout: int = 60, read_timeout_override: Optional[float] = None, keepalive: int = 0, default_enter: Optional[str] = None, response_return: Optional[str] = None, serial_settings: Optional[Dict[str, Any]] = None, fast_cli: bool = True, session_log: Optional[<a title="netmiko.session_log.SessionLog" href="../session_log.html#netmiko.session_log.SessionLog">SessionLog</a>] = None, session_log_record_writes: bool = False, session_log_file_mode: str = 'write', allow_auto_change: bool = False, encoding: str = 'utf-8', sock: Optional[socket.socket] = None, auto_connect: bool = True, delay_factor_compat: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement methods for interacting with Juniper Networks devices.</p>
<p>methods.
Overrides several methods for Juniper-specific compatibility.</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if &lt;code&gt;host&lt;/code&gt; is
        provided.

    :param host: Hostname of target device. Not required if &lt;code&gt;ip&lt;/code&gt; is
            provided.

    :param username: Username to authenticate against target device if
            required.

    :param password: Password to authenticate against target device if
            required.

    :param secret: The enable password if target device requires one.

    :param port: The destination port used to connect to the target
            device.

    :param device_type: Class selection based on device type.

    :param verbose: Enable additional messages to standard output.

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).

    :param use_keys: Connect to target device using SSH keys.

    :param key_file: Filename path of the SSH key file to use.

    :param pkey: SSH key object to use.

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.

    :param disabled_algorithms: Dictionary of SSH algorithms to disable. Refer to the Paramiko
            documentation for a description of the expected format.

    :param allow_agent: Enable use of SSH key-agent.

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).

    :param system_host_keys: Load host keys from the users known_hosts file.

    :param alt_host_keys: If &lt;code&gt;True&lt;/code&gt; host keys will be loaded from the file specified in
            alt_key_file.

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).

    :param ssh_config_file: File name of OpenSSH configuration file.

    :param timeout: Connection timeout.

    :param session_timeout: Set a timeout for parallel requests.

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: True)

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)

    :param sock: An open socket or socket-like object (such as a &lt;code&gt;.Channel&lt;/code&gt;) to use for
            communication to the target host (default: None).

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function &lt;code&gt;cmd\_verify&lt;/code&gt;
            argument. Value of &lt;code&gt;None&lt;/code&gt; indicates to use function &lt;code&gt;cmd\_verify&lt;/code&gt; argument.

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).

    :param delay_factor_compat: Set send_command and send_command_timing back to using Netmiko
            3.x behavior for delay_factor/global_delay_factor/max_loops. This argument will be
            eliminated in Netmiko 5.x (default: False).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JuniperBase(NoEnable, BaseConnection):
    &#34;&#34;&#34;
    Implement methods for interacting with Juniper Networks devices.

    methods.  Overrides several methods for Juniper-specific compatibility.
    &#34;&#34;&#34;

    def session_preparation(self) -&gt; None:
        &#34;&#34;&#34;Prepare the session after the connection has been established.&#34;&#34;&#34;
        pattern = r&#34;[%&gt;$#]&#34;
        self._test_channel_read(pattern=pattern)
        self.enter_cli_mode()

        cmd = &#34;set cli screen-width 511&#34;
        self.set_terminal_width(command=cmd, pattern=r&#34;Screen width set to&#34;)
        # Overloading disable_paging which is confusing
        self.disable_paging(
            command=&#34;set cli complete-on-space off&#34;,
            pattern=r&#34;Disabling complete-on-space&#34;,
        )
        self.disable_paging(
            command=&#34;set cli screen-length 0&#34;, pattern=r&#34;Screen length set to&#34;
        )
        self.set_base_prompt()

    def _enter_shell(self) -&gt; str:
        &#34;&#34;&#34;Enter the Bourne Shell.&#34;&#34;&#34;
        return self._send_command_str(&#34;start shell sh&#34;, expect_string=r&#34;[\$#]&#34;)

    def _return_cli(self) -&gt; str:
        &#34;&#34;&#34;Return to the Juniper CLI.&#34;&#34;&#34;
        return self._send_command_str(&#34;exit&#34;, expect_string=r&#34;[#&gt;]&#34;)

    def _determine_mode(self, data: str = &#34;&#34;) -&gt; str:
        &#34;&#34;&#34;Determine whether in shell or CLI.&#34;&#34;&#34;
        pattern = r&#34;[%&gt;$#]&#34;
        if not data:
            self.write_channel(self.RETURN)
            data = self.read_until_pattern(pattern=pattern, read_timeout=10)

        shell_pattern = r&#34;(?:root@|%|\$)&#34;
        if re.search(shell_pattern, data):
            return &#34;shell&#34;
        elif &#34;&gt;&#34; in data or &#34;#&#34; in data:
            return &#34;cli&#34;
        else:
            raise ValueError(f&#34;Unexpected data returned for prompt: {data}&#34;)

    def enter_cli_mode(self) -&gt; None:
        &#34;&#34;&#34;Check if at shell prompt root@ and go into CLI.&#34;&#34;&#34;
        mode = self._determine_mode()
        if mode == &#34;shell&#34;:
            shell_pattern = r&#34;(?:root@|%|\$)&#34;
            self.write_channel(self.RETURN)
            cur_prompt = self.read_until_pattern(pattern=shell_pattern, read_timeout=10)
            if re.search(r&#34;root@&#34;, cur_prompt) or re.search(r&#34;^%$&#34;, cur_prompt.strip()):
                cli_pattern = r&#34;[&gt;#]&#34;
                self.write_channel(&#34;cli&#34; + self.RETURN)
                self.read_until_pattern(pattern=cli_pattern, read_timeout=10)
        return

    def check_config_mode(
        self,
        check_string: str = &#34;]&#34;,
        pattern: str = r&#34;(?m:[&gt;#] $)&#34;,
        force_regex: bool = False,
    ) -&gt; bool:
        &#34;&#34;&#34;
        Checks if the device is in configuration mode or not.

        ?m = Use multiline matching

        Juniper unfortunately will use # as a message indicator when not in config mode
        For example, with commit confirmed.

        &#34;&#34;&#34;
        return super().check_config_mode(check_string=check_string, pattern=pattern)

    def config_mode(
        self,
        config_command: str = &#34;configure&#34;,
        pattern: str = r&#34;(?s:Entering configuration mode.*\].*#)&#34;,
        re_flags: int = 0,
    ) -&gt; str:
        &#34;&#34;&#34;
        Enter configuration mode.

        ?s = enables re.DOTALL in regex pattern.
        &#34;&#34;&#34;
        return super().config_mode(
            config_command=config_command, pattern=pattern, re_flags=re_flags
        )

    def exit_config_mode(
        self, exit_config: str = &#34;exit configuration-mode&#34;, pattern: str = &#34;&#34;
    ) -&gt; str:
        &#34;&#34;&#34;Exit configuration mode.&#34;&#34;&#34;
        output = &#34;&#34;
        if self.check_config_mode():
            confirm_msg = &#34;Exit with uncommitted changes&#34;
            pattern = rf&#34;(?:&gt;|{confirm_msg})&#34;
            output = self._send_command_str(
                exit_config,
                expect_string=pattern,
                strip_prompt=False,
                strip_command=False,
            )
            if confirm_msg in output:
                output += self._send_command_str(
                    &#34;yes&#34;, expect_string=r&#34;&gt;&#34;, strip_prompt=False, strip_command=False
                )
            if self.check_config_mode():
                raise ValueError(&#34;Failed to exit configuration mode&#34;)
        return output

    def commit(
        self,
        confirm: bool = False,
        confirm_delay: Optional[int] = None,
        check: bool = False,
        comment: str = &#34;&#34;,
        and_quit: bool = False,
        read_timeout: float = 120.0,
        delay_factor: Optional[float] = None,
    ) -&gt; str:
        &#34;&#34;&#34;
        Commit the candidate configuration.

        Commit the entered configuration. Raise an error and return the failure
        if the commit fails.

        Automatically enters configuration mode

        default:
            command_string = commit
        check and (confirm or confirm_dely or comment):
            Exception
        confirm_delay and no confirm:
            Exception
        confirm:
            confirm_delay option
            comment option
            command_string = commit confirmed or commit confirmed &lt;confirm_delay&gt;
        check:
            command_string = commit check

        delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

        &#34;&#34;&#34;

        if delay_factor is not None:
            warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)
        if check and (confirm or confirm_delay or comment):
            raise ValueError(&#34;Invalid arguments supplied with commit check&#34;)
        if confirm_delay and not confirm:
            raise ValueError(
                &#34;Invalid arguments supplied to commit method both confirm and check&#34;
            )

        # Select proper command string based on arguments provided
        command_string = &#34;commit&#34;
        commit_marker = &#34;commit complete&#34;
        if check:
            command_string = &#34;commit check&#34;
            commit_marker = &#34;configuration check succeeds&#34;
        elif confirm:
            if confirm_delay:
                command_string = &#34;commit confirmed &#34; + str(confirm_delay)
            else:
                command_string = &#34;commit confirmed&#34;
            commit_marker = &#34;commit confirmed will be automatically rolled back in&#34;

        # wrap the comment in quotes
        if comment:
            if &#39;&#34;&#39; in comment:
                raise ValueError(&#34;Invalid comment contains double quote&#34;)
            comment = f&#39;&#34;{comment}&#34;&#39;
            command_string += &#34; comment &#34; + comment

        if and_quit:
            command_string += &#34; and-quit&#34;

        # Enter config mode (if necessary)
        output = self.config_mode()
        # and_quit will get out of config mode on commit

        expect_string = re.escape(self.base_prompt) if and_quit else None

        output += self._send_command_str(
            command_string,
            expect_string=expect_string,
            strip_prompt=False,
            strip_command=False,
            read_timeout=read_timeout,
        )

        if commit_marker not in output:
            raise ValueError(f&#34;Commit failed with the following errors:\n\n{output}&#34;)

        return output

    def strip_prompt(self, *args: Any, **kwargs: Any) -&gt; str:
        &#34;&#34;&#34;Strip the trailing router prompt from the output.&#34;&#34;&#34;
        a_string = super().strip_prompt(*args, **kwargs)
        return self.strip_context_items(a_string)

    def strip_context_items(self, a_string: str) -&gt; str:
        &#34;&#34;&#34;Strip Juniper-specific output.

        Juniper will also put a configuration context:
        [edit]

        and various chassis contexts:
        {master:0}, {backup:1}

        This method removes those lines.
        &#34;&#34;&#34;
        strings_to_strip = [
            r&#34;\[edit.*\]&#34;,
            r&#34;\{master:?.*\}&#34;,
            r&#34;\{backup:?.*\}&#34;,
            r&#34;\{line.*\}&#34;,
            r&#34;\{primary.*\}&#34;,
            r&#34;\{secondary.*\}&#34;,
        ]

        response_list = a_string.split(self.RESPONSE_RETURN)
        last_line = response_list[-1]
        for pattern in strings_to_strip:
            if re.search(pattern, last_line, flags=re.I):
                return self.RESPONSE_RETURN.join(response_list[:-1])
        return a_string

    def cleanup(self, command: str = &#34;exit&#34;) -&gt; None:
        &#34;&#34;&#34;Gracefully exit the SSH session.&#34;&#34;&#34;
        try:
            if self.check_config_mode():
                self.exit_config_mode()
        except Exception:
            pass
        # Always try to send final &#39;exit&#39; (command)
        self._session_log_fin = True
        self.write_channel(command + self.RETURN)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.no_enable.NoEnable" href="../no_enable.html#netmiko.no_enable.NoEnable">NoEnable</a></li>
<li><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="netmiko.juniper.juniper.JuniperSSH" href="#netmiko.juniper.juniper.JuniperSSH">JuniperSSH</a></li>
<li><a title="netmiko.juniper.juniper.JuniperTelnet" href="#netmiko.juniper.juniper.JuniperTelnet">JuniperTelnet</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="netmiko.juniper.juniper.JuniperBase.check_config_mode"><code class="name flex">
<span>def <span class="ident">check_config_mode</span></span>(<span>self, check_string: str = ']', pattern: str = &#x27;(?m:[&gt;#] $)&#x27;, force_regex: bool = False) ‑> bool</span>
</code></dt>
<dd>
<div class="desc"><p>Checks if the device is in configuration mode or not.</p>
<p>?m = Use multiline matching</p>
<p>Juniper unfortunately will use # as a message indicator when not in config mode
For example, with commit confirmed.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def check_config_mode(
    self,
    check_string: str = &#34;]&#34;,
    pattern: str = r&#34;(?m:[&gt;#] $)&#34;,
    force_regex: bool = False,
) -&gt; bool:
    &#34;&#34;&#34;
    Checks if the device is in configuration mode or not.

    ?m = Use multiline matching

    Juniper unfortunately will use # as a message indicator when not in config mode
    For example, with commit confirmed.

    &#34;&#34;&#34;
    return super().check_config_mode(check_string=check_string, pattern=pattern)</code></pre>
</details>
</dd>
<dt id="netmiko.juniper.juniper.JuniperBase.cleanup"><code class="name flex">
<span>def <span class="ident">cleanup</span></span>(<span>self, command: str = 'exit') ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Gracefully exit the SSH session.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def cleanup(self, command: str = &#34;exit&#34;) -&gt; None:
    &#34;&#34;&#34;Gracefully exit the SSH session.&#34;&#34;&#34;
    try:
        if self.check_config_mode():
            self.exit_config_mode()
    except Exception:
        pass
    # Always try to send final &#39;exit&#39; (command)
    self._session_log_fin = True
    self.write_channel(command + self.RETURN)</code></pre>
</details>
</dd>
<dt id="netmiko.juniper.juniper.JuniperBase.commit"><code class="name flex">
<span>def <span class="ident">commit</span></span>(<span>self, confirm: bool = False, confirm_delay: Optional[int] = None, check: bool = False, comment: str = '', and_quit: bool = False, read_timeout: float = 120.0, delay_factor: Optional[float] = None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Commit the candidate configuration.</p>
<p>Commit the entered configuration. Raise an error and return the failure
if the commit fails.</p>
<p>Automatically enters configuration mode</p>
<p>default:
command_string = commit
check and (confirm or confirm_dely or comment):
Exception
confirm_delay and no confirm:
Exception
confirm:
confirm_delay option
comment option
command_string = commit confirmed or commit confirmed <confirm_delay>
check:
command_string = commit check</p>
<p>delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def commit(
    self,
    confirm: bool = False,
    confirm_delay: Optional[int] = None,
    check: bool = False,
    comment: str = &#34;&#34;,
    and_quit: bool = False,
    read_timeout: float = 120.0,
    delay_factor: Optional[float] = None,
) -&gt; str:
    &#34;&#34;&#34;
    Commit the candidate configuration.

    Commit the entered configuration. Raise an error and return the failure
    if the commit fails.

    Automatically enters configuration mode

    default:
        command_string = commit
    check and (confirm or confirm_dely or comment):
        Exception
    confirm_delay and no confirm:
        Exception
    confirm:
        confirm_delay option
        comment option
        command_string = commit confirmed or commit confirmed &lt;confirm_delay&gt;
    check:
        command_string = commit check

    delay_factor: Deprecated in Netmiko 4.x. Will be eliminated in Netmiko 5.

    &#34;&#34;&#34;

    if delay_factor is not None:
        warnings.warn(DELAY_FACTOR_DEPR_SIMPLE_MSG, DeprecationWarning)
    if check and (confirm or confirm_delay or comment):
        raise ValueError(&#34;Invalid arguments supplied with commit check&#34;)
    if confirm_delay and not confirm:
        raise ValueError(
            &#34;Invalid arguments supplied to commit method both confirm and check&#34;
        )

    # Select proper command string based on arguments provided
    command_string = &#34;commit&#34;
    commit_marker = &#34;commit complete&#34;
    if check:
        command_string = &#34;commit check&#34;
        commit_marker = &#34;configuration check succeeds&#34;
    elif confirm:
        if confirm_delay:
            command_string = &#34;commit confirmed &#34; + str(confirm_delay)
        else:
            command_string = &#34;commit confirmed&#34;
        commit_marker = &#34;commit confirmed will be automatically rolled back in&#34;

    # wrap the comment in quotes
    if comment:
        if &#39;&#34;&#39; in comment:
            raise ValueError(&#34;Invalid comment contains double quote&#34;)
        comment = f&#39;&#34;{comment}&#34;&#39;
        command_string += &#34; comment &#34; + comment

    if and_quit:
        command_string += &#34; and-quit&#34;

    # Enter config mode (if necessary)
    output = self.config_mode()
    # and_quit will get out of config mode on commit

    expect_string = re.escape(self.base_prompt) if and_quit else None

    output += self._send_command_str(
        command_string,
        expect_string=expect_string,
        strip_prompt=False,
        strip_command=False,
        read_timeout=read_timeout,
    )

    if commit_marker not in output:
        raise ValueError(f&#34;Commit failed with the following errors:\n\n{output}&#34;)

    return output</code></pre>
</details>
</dd>
<dt id="netmiko.juniper.juniper.JuniperBase.config_mode"><code class="name flex">
<span>def <span class="ident">config_mode</span></span>(<span>self, config_command: str = 'configure', pattern: str = '(?s:Entering configuration mode.*\\].*#)', re_flags: int = 0) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Enter configuration mode.</p>
<p>?s = enables re.DOTALL in regex pattern.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def config_mode(
    self,
    config_command: str = &#34;configure&#34;,
    pattern: str = r&#34;(?s:Entering configuration mode.*\].*#)&#34;,
    re_flags: int = 0,
) -&gt; str:
    &#34;&#34;&#34;
    Enter configuration mode.

    ?s = enables re.DOTALL in regex pattern.
    &#34;&#34;&#34;
    return super().config_mode(
        config_command=config_command, pattern=pattern, re_flags=re_flags
    )</code></pre>
</details>
</dd>
<dt id="netmiko.juniper.juniper.JuniperBase.enter_cli_mode"><code class="name flex">
<span>def <span class="ident">enter_cli_mode</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Check if at shell prompt root@ and go into CLI.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def enter_cli_mode(self) -&gt; None:
    &#34;&#34;&#34;Check if at shell prompt root@ and go into CLI.&#34;&#34;&#34;
    mode = self._determine_mode()
    if mode == &#34;shell&#34;:
        shell_pattern = r&#34;(?:root@|%|\$)&#34;
        self.write_channel(self.RETURN)
        cur_prompt = self.read_until_pattern(pattern=shell_pattern, read_timeout=10)
        if re.search(r&#34;root@&#34;, cur_prompt) or re.search(r&#34;^%$&#34;, cur_prompt.strip()):
            cli_pattern = r&#34;[&gt;#]&#34;
            self.write_channel(&#34;cli&#34; + self.RETURN)
            self.read_until_pattern(pattern=cli_pattern, read_timeout=10)
    return</code></pre>
</details>
</dd>
<dt id="netmiko.juniper.juniper.JuniperBase.exit_config_mode"><code class="name flex">
<span>def <span class="ident">exit_config_mode</span></span>(<span>self, exit_config: str = 'exit configuration-mode', pattern: str = '') ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Exit configuration mode.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def exit_config_mode(
    self, exit_config: str = &#34;exit configuration-mode&#34;, pattern: str = &#34;&#34;
) -&gt; str:
    &#34;&#34;&#34;Exit configuration mode.&#34;&#34;&#34;
    output = &#34;&#34;
    if self.check_config_mode():
        confirm_msg = &#34;Exit with uncommitted changes&#34;
        pattern = rf&#34;(?:&gt;|{confirm_msg})&#34;
        output = self._send_command_str(
            exit_config,
            expect_string=pattern,
            strip_prompt=False,
            strip_command=False,
        )
        if confirm_msg in output:
            output += self._send_command_str(
                &#34;yes&#34;, expect_string=r&#34;&gt;&#34;, strip_prompt=False, strip_command=False
            )
        if self.check_config_mode():
            raise ValueError(&#34;Failed to exit configuration mode&#34;)
    return output</code></pre>
</details>
</dd>
<dt id="netmiko.juniper.juniper.JuniperBase.session_preparation"><code class="name flex">
<span>def <span class="ident">session_preparation</span></span>(<span>self) ‑> None</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare the session after the connection has been established.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def session_preparation(self) -&gt; None:
    &#34;&#34;&#34;Prepare the session after the connection has been established.&#34;&#34;&#34;
    pattern = r&#34;[%&gt;$#]&#34;
    self._test_channel_read(pattern=pattern)
    self.enter_cli_mode()

    cmd = &#34;set cli screen-width 511&#34;
    self.set_terminal_width(command=cmd, pattern=r&#34;Screen width set to&#34;)
    # Overloading disable_paging which is confusing
    self.disable_paging(
        command=&#34;set cli complete-on-space off&#34;,
        pattern=r&#34;Disabling complete-on-space&#34;,
    )
    self.disable_paging(
        command=&#34;set cli screen-length 0&#34;, pattern=r&#34;Screen length set to&#34;
    )
    self.set_base_prompt()</code></pre>
</details>
</dd>
<dt id="netmiko.juniper.juniper.JuniperBase.strip_context_items"><code class="name flex">
<span>def <span class="ident">strip_context_items</span></span>(<span>self, a_string: str) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Strip Juniper-specific output.</p>
<p>Juniper will also put a configuration context:
[edit]</p>
<p>and various chassis contexts:
{master:0}, {backup:1}</p>
<p>This method removes those lines.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_context_items(self, a_string: str) -&gt; str:
    &#34;&#34;&#34;Strip Juniper-specific output.

    Juniper will also put a configuration context:
    [edit]

    and various chassis contexts:
    {master:0}, {backup:1}

    This method removes those lines.
    &#34;&#34;&#34;
    strings_to_strip = [
        r&#34;\[edit.*\]&#34;,
        r&#34;\{master:?.*\}&#34;,
        r&#34;\{backup:?.*\}&#34;,
        r&#34;\{line.*\}&#34;,
        r&#34;\{primary.*\}&#34;,
        r&#34;\{secondary.*\}&#34;,
    ]

    response_list = a_string.split(self.RESPONSE_RETURN)
    last_line = response_list[-1]
    for pattern in strings_to_strip:
        if re.search(pattern, last_line, flags=re.I):
            return self.RESPONSE_RETURN.join(response_list[:-1])
    return a_string</code></pre>
</details>
</dd>
<dt id="netmiko.juniper.juniper.JuniperBase.strip_prompt"><code class="name flex">
<span>def <span class="ident">strip_prompt</span></span>(<span>self, *args: Any, **kwargs: Any) ‑> str</span>
</code></dt>
<dd>
<div class="desc"><p>Strip the trailing router prompt from the output.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def strip_prompt(self, *args: Any, **kwargs: Any) -&gt; str:
    &#34;&#34;&#34;Strip the trailing router prompt from the output.&#34;&#34;&#34;
    a_string = super().strip_prompt(*args, **kwargs)
    return self.strip_context_items(a_string)</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.base_connection.BaseConnection.check_enable_mode" href="../base_connection.html#netmiko.base_connection.BaseConnection.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.clear_buffer" href="../base_connection.html#netmiko.base_connection.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.disable_paging" href="../base_connection.html#netmiko.base_connection.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.disconnect" href="../base_connection.html#netmiko.base_connection.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.enable" href="../base_connection.html#netmiko.base_connection.BaseConnection.enable">enable</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.establish_connection" href="../base_connection.html#netmiko.base_connection.BaseConnection.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.exit_enable_mode" href="../base_connection.html#netmiko.base_connection.BaseConnection.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.find_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.is_alive" href="../base_connection.html#netmiko.base_connection.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.normalize_cmd" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.normalize_linefeeds" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.paramiko_cleanup" href="../base_connection.html#netmiko.base_connection.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_channel_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel_timing">read_channel_timing</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_until_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_until_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.run_ttp" href="../base_connection.html#netmiko.base_connection.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.save_config" href="../base_connection.html#netmiko.base_connection.BaseConnection.save_config">save_config</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.select_delay_factor" href="../base_connection.html#netmiko.base_connection.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_command_expect" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_command_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_config_from_file" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_config_set" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.send_multiline" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_multiline">send_multiline</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.set_base_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.set_terminal_width" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.special_login_handler" href="../base_connection.html#netmiko.base_connection.BaseConnection.special_login_handler">special_login_handler</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.strip_ansi_escape_codes" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.strip_backspaces" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.strip_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.telnet_login" href="../base_connection.html#netmiko.base_connection.BaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.base_connection.BaseConnection.write_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="netmiko.juniper.juniper.JuniperFileTransfer"><code class="flex name class">
<span>class <span class="ident">JuniperFileTransfer</span></span>
<span>(</span><span>ssh_conn: BaseConnection, source_file: str, dest_file: str, file_system: Optional[str] = '/var/tmp', direction: str = 'put', **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Juniper SCP File Transfer driver.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JuniperFileTransfer(BaseFileTransfer):
    &#34;&#34;&#34;Juniper SCP File Transfer driver.&#34;&#34;&#34;

    def __init__(
        self,
        ssh_conn: &#34;BaseConnection&#34;,
        source_file: str,
        dest_file: str,
        file_system: Optional[str] = &#34;/var/tmp&#34;,
        direction: str = &#34;put&#34;,
        **kwargs: Any,
    ) -&gt; None:
        super().__init__(
            ssh_conn=ssh_conn,
            source_file=source_file,
            dest_file=dest_file,
            file_system=file_system,
            direction=direction,
            **kwargs,
        )

    def remote_space_available(self, search_pattern: str = &#34;&#34;) -&gt; int:
        &#34;&#34;&#34;Return space available on remote device.&#34;&#34;&#34;
        return self._remote_space_available_unix(search_pattern=search_pattern)

    def check_file_exists(self, remote_cmd: str = &#34;&#34;) -&gt; bool:
        &#34;&#34;&#34;Check if the dest_file already exists on the file system (return boolean).&#34;&#34;&#34;
        return self._check_file_exists_unix(remote_cmd=remote_cmd)

    def remote_file_size(
        self, remote_cmd: str = &#34;&#34;, remote_file: Optional[str] = None
    ) -&gt; int:
        &#34;&#34;&#34;Get the file size of the remote file.&#34;&#34;&#34;
        return self._remote_file_size_unix(
            remote_cmd=remote_cmd, remote_file=remote_file
        )

    def remote_md5(
        self, base_cmd: str = &#34;file checksum md5&#34;, remote_file: Optional[str] = None
    ) -&gt; str:
        return super().remote_md5(base_cmd=base_cmd, remote_file=remote_file)

    def enable_scp(self, cmd: str = &#34;&#34;) -&gt; None:
        raise NotImplementedError

    def disable_scp(self, cmd: str = &#34;&#34;) -&gt; None:
        raise NotImplementedError</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.scp_handler.BaseFileTransfer" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer">BaseFileTransfer</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.scp_handler.BaseFileTransfer" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer">BaseFileTransfer</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.check_file_exists" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.check_file_exists">check_file_exists</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.close_scp_chan" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.close_scp_chan">close_scp_chan</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.compare_md5" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.compare_md5">compare_md5</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.disable_scp" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.disable_scp">disable_scp</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.enable_scp" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.enable_scp">enable_scp</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.establish_scp_conn" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.establish_scp_conn">establish_scp_conn</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.file_md5" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.file_md5">file_md5</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.get_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.get_file">get_file</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.local_space_available" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.local_space_available">local_space_available</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.process_md5" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.process_md5">process_md5</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.put_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.put_file">put_file</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.remote_file_size" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_file_size">remote_file_size</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.remote_md5" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_md5">remote_md5</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.remote_space_available" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.remote_space_available">remote_space_available</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.transfer_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.transfer_file">transfer_file</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.verify_file" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.verify_file">verify_file</a></code></li>
<li><code><a title="netmiko.scp_handler.BaseFileTransfer.verify_space_available" href="../scp_handler.html#netmiko.scp_handler.BaseFileTransfer.verify_space_available">verify_space_available</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="netmiko.juniper.juniper.JuniperSSH"><code class="flex name class">
<span>class <span class="ident">JuniperSSH</span></span>
<span>(</span><span>ip: str = '', host: str = '', username: str = '', password: Optional[str] = None, secret: str = '', port: Optional[int] = None, device_type: str = '', verbose: bool = False, global_delay_factor: float = 1.0, global_cmd_verify: Optional[bool] = None, use_keys: bool = False, key_file: Optional[str] = None, pkey: Optional[paramiko.pkey.PKey] = None, passphrase: Optional[str] = None, disabled_algorithms: Optional[Dict[str, Any]] = None, allow_agent: bool = False, ssh_strict: bool = False, system_host_keys: bool = False, alt_host_keys: bool = False, alt_key_file: str = '', ssh_config_file: Optional[str] = None, conn_timeout: int = 10, auth_timeout: Optional[int] = None, banner_timeout: int = 15, blocking_timeout: int = 20, timeout: int = 100, session_timeout: int = 60, read_timeout_override: Optional[float] = None, keepalive: int = 0, default_enter: Optional[str] = None, response_return: Optional[str] = None, serial_settings: Optional[Dict[str, Any]] = None, fast_cli: bool = True, session_log: Optional[<a title="netmiko.session_log.SessionLog" href="../session_log.html#netmiko.session_log.SessionLog">SessionLog</a>] = None, session_log_record_writes: bool = False, session_log_file_mode: str = 'write', allow_auto_change: bool = False, encoding: str = 'utf-8', sock: Optional[socket.socket] = None, auto_connect: bool = True, delay_factor_compat: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement methods for interacting with Juniper Networks devices.</p>
<p>methods.
Overrides several methods for Juniper-specific compatibility.</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if &lt;code&gt;host&lt;/code&gt; is
        provided.

    :param host: Hostname of target device. Not required if &lt;code&gt;ip&lt;/code&gt; is
            provided.

    :param username: Username to authenticate against target device if
            required.

    :param password: Password to authenticate against target device if
            required.

    :param secret: The enable password if target device requires one.

    :param port: The destination port used to connect to the target
            device.

    :param device_type: Class selection based on device type.

    :param verbose: Enable additional messages to standard output.

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).

    :param use_keys: Connect to target device using SSH keys.

    :param key_file: Filename path of the SSH key file to use.

    :param pkey: SSH key object to use.

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.

    :param disabled_algorithms: Dictionary of SSH algorithms to disable. Refer to the Paramiko
            documentation for a description of the expected format.

    :param allow_agent: Enable use of SSH key-agent.

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).

    :param system_host_keys: Load host keys from the users known_hosts file.

    :param alt_host_keys: If &lt;code&gt;True&lt;/code&gt; host keys will be loaded from the file specified in
            alt_key_file.

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).

    :param ssh_config_file: File name of OpenSSH configuration file.

    :param timeout: Connection timeout.

    :param session_timeout: Set a timeout for parallel requests.

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: True)

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)

    :param sock: An open socket or socket-like object (such as a &lt;code&gt;.Channel&lt;/code&gt;) to use for
            communication to the target host (default: None).

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function &lt;code&gt;cmd\_verify&lt;/code&gt;
            argument. Value of &lt;code&gt;None&lt;/code&gt; indicates to use function &lt;code&gt;cmd\_verify&lt;/code&gt; argument.

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).

    :param delay_factor_compat: Set send_command and send_command_timing back to using Netmiko
            3.x behavior for delay_factor/global_delay_factor/max_loops. This argument will be
            eliminated in Netmiko 5.x (default: False).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JuniperSSH(JuniperBase):
    pass</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.juniper.juniper.JuniperBase" href="#netmiko.juniper.juniper.JuniperBase">JuniperBase</a></li>
<li><a title="netmiko.no_enable.NoEnable" href="../no_enable.html#netmiko.no_enable.NoEnable">NoEnable</a></li>
<li><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.juniper.juniper.JuniperBase" href="#netmiko.juniper.juniper.JuniperBase">JuniperBase</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.juniper.juniper.JuniperBase.check_config_mode" href="#netmiko.juniper.juniper.JuniperBase.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.check_enable_mode" href="../base_connection.html#netmiko.base_connection.BaseConnection.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.cleanup" href="#netmiko.juniper.juniper.JuniperBase.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.clear_buffer" href="../base_connection.html#netmiko.base_connection.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.commit" href="#netmiko.juniper.juniper.JuniperBase.commit">commit</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.config_mode" href="#netmiko.juniper.juniper.JuniperBase.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.disable_paging" href="../base_connection.html#netmiko.base_connection.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.disconnect" href="../base_connection.html#netmiko.base_connection.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.enable" href="../base_connection.html#netmiko.base_connection.BaseConnection.enable">enable</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.enter_cli_mode" href="#netmiko.juniper.juniper.JuniperBase.enter_cli_mode">enter_cli_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.establish_connection" href="../base_connection.html#netmiko.base_connection.BaseConnection.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.exit_config_mode" href="#netmiko.juniper.juniper.JuniperBase.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.exit_enable_mode" href="../base_connection.html#netmiko.base_connection.BaseConnection.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.find_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.is_alive" href="../base_connection.html#netmiko.base_connection.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.normalize_cmd" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.normalize_linefeeds" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.paramiko_cleanup" href="../base_connection.html#netmiko.base_connection.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.read_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.read_channel_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel_timing">read_channel_timing</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.read_until_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.read_until_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.read_until_prompt_or_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.run_ttp" href="../base_connection.html#netmiko.base_connection.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.save_config" href="../base_connection.html#netmiko.base_connection.BaseConnection.save_config">save_config</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.select_delay_factor" href="../base_connection.html#netmiko.base_connection.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_command_expect" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_command_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_config_from_file" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_config_set" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_multiline" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_multiline">send_multiline</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.session_preparation" href="#netmiko.juniper.juniper.JuniperBase.session_preparation">session_preparation</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.set_base_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.set_terminal_width" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.special_login_handler" href="../base_connection.html#netmiko.base_connection.BaseConnection.special_login_handler">special_login_handler</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_ansi_escape_codes" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_backspaces" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_context_items" href="#netmiko.juniper.juniper.JuniperBase.strip_context_items">strip_context_items</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_prompt" href="#netmiko.juniper.juniper.JuniperBase.strip_prompt">strip_prompt</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.telnet_login" href="../base_connection.html#netmiko.base_connection.BaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.write_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="netmiko.juniper.juniper.JuniperTelnet"><code class="flex name class">
<span>class <span class="ident">JuniperTelnet</span></span>
<span>(</span><span>*args: Any, **kwargs: Any)</span>
</code></dt>
<dd>
<div class="desc"><p>Implement methods for interacting with Juniper Networks devices.</p>
<p>methods.
Overrides several methods for Juniper-specific compatibility.</p>
<pre><code>    Initialize attributes for establishing connection to target device.

    :param ip: IP address of target device. Not required if &lt;code&gt;host&lt;/code&gt; is
        provided.

    :param host: Hostname of target device. Not required if &lt;code&gt;ip&lt;/code&gt; is
            provided.

    :param username: Username to authenticate against target device if
            required.

    :param password: Password to authenticate against target device if
            required.

    :param secret: The enable password if target device requires one.

    :param port: The destination port used to connect to the target
            device.

    :param device_type: Class selection based on device type.

    :param verbose: Enable additional messages to standard output.

    :param global_delay_factor: Multiplication factor affecting Netmiko delays (default: 1).

    :param use_keys: Connect to target device using SSH keys.

    :param key_file: Filename path of the SSH key file to use.

    :param pkey: SSH key object to use.

    :param passphrase: Passphrase to use for encrypted key; password will be used for key
            decryption if not specified.

    :param disabled_algorithms: Dictionary of SSH algorithms to disable. Refer to the Paramiko
            documentation for a description of the expected format.

    :param allow_agent: Enable use of SSH key-agent.

    :param ssh_strict: Automatically reject unknown SSH host keys (default: False, which
            means unknown SSH host keys will be accepted).

    :param system_host_keys: Load host keys from the users known_hosts file.

    :param alt_host_keys: If &lt;code&gt;True&lt;/code&gt; host keys will be loaded from the file specified in
            alt_key_file.

    :param alt_key_file: SSH host key file to use (if alt_host_keys=True).

    :param ssh_config_file: File name of OpenSSH configuration file.

    :param timeout: Connection timeout.

    :param session_timeout: Set a timeout for parallel requests.

    :param auth_timeout: Set a timeout (in seconds) to wait for an authentication response.

    :param banner_timeout: Set a timeout to wait for the SSH banner (pass to Paramiko).

    :param keepalive: Send SSH keepalive packets at a specific interval, in seconds.
            Currently defaults to 0, for backwards compatibility (it will not attempt
            to keep the connection alive).

    :param default_enter: Character(s) to send to correspond to enter key (default:
</code></pre>
<p>).</p>
<pre><code>    :param response_return: Character(s) to use in normalized return data to represent
            enter key (default:
</code></pre>
<p>)</p>
<pre><code>    :param fast_cli: Provide a way to optimize for performance. Converts select_delay_factor
            to select smallest of global and specific. Sets default global_delay_factor to .1
            (default: True)

    :param session_log: File path or BufferedIOBase subclass object to write the session log to.

    :param session_log_record_writes: The session log generally only records channel reads due
            to eliminate command duplication due to command echo. You can enable this if you
            want to record both channel reads and channel writes in the log (default: False).

    :param session_log_file_mode: "write" or "append" for session_log file mode
            (default: "write")

    :param allow_auto_change: Allow automatic configuration changes for terminal settings.
            (default: False)

    :param encoding: Encoding to be used when writing bytes to the output channel.
            (default: ascii)

    :param sock: An open socket or socket-like object (such as a &lt;code&gt;.Channel&lt;/code&gt;) to use for
            communication to the target host (default: None).

    :param global_cmd_verify: Control whether command echo verification is enabled or disabled
            (default: None). Global attribute takes precedence over function &lt;code&gt;cmd\_verify&lt;/code&gt;
            argument. Value of &lt;code&gt;None&lt;/code&gt; indicates to use function &lt;code&gt;cmd\_verify&lt;/code&gt; argument.

    :param auto_connect: Control whether Netmiko automatically establishes the connection as
            part of the object creation (default: True).

    :param delay_factor_compat: Set send_command and send_command_timing back to using Netmiko
            3.x behavior for delay_factor/global_delay_factor/max_loops. This argument will be
            eliminated in Netmiko 5.x (default: False).
</code></pre></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class JuniperTelnet(JuniperBase):
    def __init__(self, *args: Any, **kwargs: Any) -&gt; None:
        default_enter = kwargs.get(&#34;default_enter&#34;)
        kwargs[&#34;default_enter&#34;] = &#34;\r\n&#34; if default_enter is None else default_enter
        super().__init__(*args, **kwargs)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="netmiko.juniper.juniper.JuniperBase" href="#netmiko.juniper.juniper.JuniperBase">JuniperBase</a></li>
<li><a title="netmiko.no_enable.NoEnable" href="../no_enable.html#netmiko.no_enable.NoEnable">NoEnable</a></li>
<li><a title="netmiko.base_connection.BaseConnection" href="../base_connection.html#netmiko.base_connection.BaseConnection">BaseConnection</a></li>
</ul>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="netmiko.juniper.juniper.JuniperBase" href="#netmiko.juniper.juniper.JuniperBase">JuniperBase</a></b></code>:
<ul class="hlist">
<li><code><a title="netmiko.juniper.juniper.JuniperBase.check_config_mode" href="#netmiko.juniper.juniper.JuniperBase.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.check_enable_mode" href="../base_connection.html#netmiko.base_connection.BaseConnection.check_enable_mode">check_enable_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.cleanup" href="#netmiko.juniper.juniper.JuniperBase.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.clear_buffer" href="../base_connection.html#netmiko.base_connection.BaseConnection.clear_buffer">clear_buffer</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.commit" href="#netmiko.juniper.juniper.JuniperBase.commit">commit</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.config_mode" href="#netmiko.juniper.juniper.JuniperBase.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.disable_paging" href="../base_connection.html#netmiko.base_connection.BaseConnection.disable_paging">disable_paging</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.disconnect" href="../base_connection.html#netmiko.base_connection.BaseConnection.disconnect">disconnect</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.enable" href="../base_connection.html#netmiko.base_connection.BaseConnection.enable">enable</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.enter_cli_mode" href="#netmiko.juniper.juniper.JuniperBase.enter_cli_mode">enter_cli_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.establish_connection" href="../base_connection.html#netmiko.base_connection.BaseConnection.establish_connection">establish_connection</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.exit_config_mode" href="#netmiko.juniper.juniper.JuniperBase.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.exit_enable_mode" href="../base_connection.html#netmiko.base_connection.BaseConnection.exit_enable_mode">exit_enable_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.find_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.find_prompt">find_prompt</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.is_alive" href="../base_connection.html#netmiko.base_connection.BaseConnection.is_alive">is_alive</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.normalize_cmd" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_cmd">normalize_cmd</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.normalize_linefeeds" href="../base_connection.html#netmiko.base_connection.BaseConnection.normalize_linefeeds">normalize_linefeeds</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.paramiko_cleanup" href="../base_connection.html#netmiko.base_connection.BaseConnection.paramiko_cleanup">paramiko_cleanup</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.read_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel">read_channel</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.read_channel_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_channel_timing">read_channel_timing</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.read_until_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_pattern">read_until_pattern</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.read_until_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt">read_until_prompt</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.read_until_prompt_or_pattern" href="../base_connection.html#netmiko.base_connection.BaseConnection.read_until_prompt_or_pattern">read_until_prompt_or_pattern</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.run_ttp" href="../base_connection.html#netmiko.base_connection.BaseConnection.run_ttp">run_ttp</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.save_config" href="../base_connection.html#netmiko.base_connection.BaseConnection.save_config">save_config</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.select_delay_factor" href="../base_connection.html#netmiko.base_connection.BaseConnection.select_delay_factor">select_delay_factor</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command">send_command</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_command_expect" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_expect">send_command_expect</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_command_timing" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_command_timing">send_command_timing</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_config_from_file" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_from_file">send_config_from_file</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_config_set" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_config_set">send_config_set</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.send_multiline" href="../base_connection.html#netmiko.base_connection.BaseConnection.send_multiline">send_multiline</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.session_preparation" href="#netmiko.juniper.juniper.JuniperBase.session_preparation">session_preparation</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.set_base_prompt" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_base_prompt">set_base_prompt</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.set_terminal_width" href="../base_connection.html#netmiko.base_connection.BaseConnection.set_terminal_width">set_terminal_width</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.special_login_handler" href="../base_connection.html#netmiko.base_connection.BaseConnection.special_login_handler">special_login_handler</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_ansi_escape_codes" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_ansi_escape_codes">strip_ansi_escape_codes</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_backspaces" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_backspaces">strip_backspaces</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_command" href="../base_connection.html#netmiko.base_connection.BaseConnection.strip_command">strip_command</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_context_items" href="#netmiko.juniper.juniper.JuniperBase.strip_context_items">strip_context_items</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_prompt" href="#netmiko.juniper.juniper.JuniperBase.strip_prompt">strip_prompt</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.telnet_login" href="../base_connection.html#netmiko.base_connection.BaseConnection.telnet_login">telnet_login</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.write_channel" href="../base_connection.html#netmiko.base_connection.BaseConnection.write_channel">write_channel</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="netmiko.juniper" href="index.html">netmiko.juniper</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="netmiko.juniper.juniper.JuniperBase" href="#netmiko.juniper.juniper.JuniperBase">JuniperBase</a></code></h4>
<ul class="two-column">
<li><code><a title="netmiko.juniper.juniper.JuniperBase.check_config_mode" href="#netmiko.juniper.juniper.JuniperBase.check_config_mode">check_config_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.cleanup" href="#netmiko.juniper.juniper.JuniperBase.cleanup">cleanup</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.commit" href="#netmiko.juniper.juniper.JuniperBase.commit">commit</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.config_mode" href="#netmiko.juniper.juniper.JuniperBase.config_mode">config_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.enter_cli_mode" href="#netmiko.juniper.juniper.JuniperBase.enter_cli_mode">enter_cli_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.exit_config_mode" href="#netmiko.juniper.juniper.JuniperBase.exit_config_mode">exit_config_mode</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.session_preparation" href="#netmiko.juniper.juniper.JuniperBase.session_preparation">session_preparation</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_context_items" href="#netmiko.juniper.juniper.JuniperBase.strip_context_items">strip_context_items</a></code></li>
<li><code><a title="netmiko.juniper.juniper.JuniperBase.strip_prompt" href="#netmiko.juniper.juniper.JuniperBase.strip_prompt">strip_prompt</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="netmiko.juniper.juniper.JuniperFileTransfer" href="#netmiko.juniper.juniper.JuniperFileTransfer">JuniperFileTransfer</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.juniper.juniper.JuniperSSH" href="#netmiko.juniper.juniper.JuniperSSH">JuniperSSH</a></code></h4>
</li>
<li>
<h4><code><a title="netmiko.juniper.juniper.JuniperTelnet" href="#netmiko.juniper.juniper.JuniperTelnet">JuniperTelnet</a></code></h4>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>